==========
Exponentiation
==========

<?php
$foo = 2 ** 2;

---

(program (expression_statement (assignment_expression (variable_name (name)) (exponentiation_expression (float) (float)))))

==========
Reserved Identifiers as Names
==========

<?php
$foo = new self();

---

(program (expression_statement (assignment_expression (variable_name (name)) (object_creation_expression (qualified_name (name)) (arguments)))))

==========
Unary op with assignment expressions
==========

<?php

if (!$foo = $bar) {
}

---
(program (if_statement (unary_op_expression (assignment_expression (variable_name (name)) (variable_name (name)))) (compound_statement)))

==========
Trait use clauses
==========

<?php

trait AbstractTrait
{
    use LoggerAwareTrait;
    use LoggerAwareTrait, OtherTrait {}
    use LoggerAwareTrait, OtherTrait;
}

---

(program (trait_declaration (name) (trait_use_clause (qualified_name (name))) (trait_use_clause (qualified_name (name)) (qualified_name (name)) (trait_use_specification)) (trait_use_clause (qualified_name (name)) (qualified_name (name)))))

==========
Heredocs
==========

<?php

<<<HERE
foo #{bar} HERE;

<<<HERE
foo #{bar}
HERE;

?>

<?php

<<<HERE
foo #{bar} HERE;

<<<HERE
foo #{bar}
HERE;

---
(program (expression_statement (heredoc)) (expression_statement (heredoc)) (text_interpolation) (expression_statement (heredoc)) (expression_statement (heredoc)))

==========
Cast expressions in assignments
==========

<?php

(int) $foo = (float)$bar;

---

(program (expression_statement (assignment_expression (cast_expression (cast_type) (variable_name (name))) (cast_expression (cast_type) (variable_name (name))))))

==========
Reserved words as function calls
==========

<?php
$foo = new static($this->current());

---

(program (expression_statement (assignment_expression (variable_name (name)) (object_creation_expression (qualified_name (name)) (arguments (member_call_expression (dereferencable_expression (variable_name (name))) (name) (arguments)))))))


==========
Trait use clauses
==========

<?php
class AbstractCache
{
    use AbstractTrait {
        deleteItems as private;
        AbstractTrait::deleteItem as delete;
        AbstractTrait::hasItem as has;
    }
}


---

(program (class_declaration (name) (trait_use_clause (qualified_name (name)) (trait_use_specification (trait_alias_as_clause (name) (visibility_modifier)) (trait_alias_as_clause (class_constant_access_expression (qualified_name (name)) (name)) (name)) (trait_alias_as_clause (class_constant_access_expression (qualified_name (name)) (name)) (name))))))