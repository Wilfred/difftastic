=================
Function examples
=================

fn add(x: Int, y: Int) -> Int {
  x + y
}
fn twice(f: fn(t) -> t, x: t) -> t {
  f(f(x))
}
fn inferred_identity(x) {
  x
}
fn replace(
  in string: String,
  each pattern: String,
  with replacement: String
) {
  string.replace(in: in, each: each, with: with)
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)
        type: (type))
      (function_parameter
        name: (identifier)
        type: (type)))
    return_type: (type)
    (function_body
      (binary_expression
        (var)
        (var))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)
        type: (function_type
          parameter_types: (function_parameter_types
            (type_var))
          return_type: (type_var)))
      (function_parameter
        name: (identifier)
        type: (type_var)))
    return_type: (type_var)
    (function_body
      (function_call
        (var)
        (arguments
          (argument
            value: (function_call
              (var)
              (arguments
                (argument
                  value: (var)))))))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (var)))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type))
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type))
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type)))
    (function_body
      (function_call
        (field_access
          record: (var)
          field: (identifier))
        (arguments
          (argument
            label: (identifier)
            value: (var))
          (argument
            label: (identifier)
            value: (var))
          (argument
            label: (identifier)
            value: (var)))))))

========================
Public function examples
========================

pub fn add(x: Int, y: Int) -> Int {
  x + y
}
pub fn twice(f: fn(t) -> t, x: t) -> t {
  f(f(x))
}
pub fn inferred_identity(x) {
  x
}
pub fn replace(
  in string: String,
  each pattern: String,
  with replacement: String
) {
  string.replace(in: in, each: each, with: with)
}

---

(source_file
  (public_function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)
        type: (type))
      (function_parameter
        name: (identifier)
        type: (type)))
    return_type: (type)
    (function_body
      (binary_expression
        (var)
        (var))))
  (public_function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)
        type: (function_type
          parameter_types: (function_parameter_types
            (type_var))
          return_type: (type_var)))
      (function_parameter
        name: (identifier)
        type: (type_var)))
    return_type: (type_var)
    (function_body
      (function_call
        (var)
        (arguments
          (argument
            value: (function_call
              (var)
              (arguments
                (argument
                  value: (var)))))))))
  (public_function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (var)))
  (public_function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type))
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type))
      (function_parameter
        label: (identifier)
        name: (identifier)
        type: (type)))
    (function_body
      (function_call
        (field_access
          record: (var)
          field: (identifier))
        (arguments
          (argument
            label: (identifier)
            value: (var))
          (argument
            label: (identifier)
            value: (var))
          (argument
            label: (identifier)
            value: (var)))))))

===============
Basic functions
===============

fn str() {
  "Hello, World!"
}
fn integer() {
  42
}
fn float() {
  12.34
}
fn record() {
  Cat(name: "Nubi")
}
fn remote_record() {
  cats.Cat(name: "Nubi")
}
fn var(x) {
  x
}
fn funcall() {
  myfun()
}
fn unfinished() {
  todo("Finish me!")
}
fn tuple(x) {
  #(x, 1)
}
fn list(x) {
  [1, 2, ..x]
}
fn bit_string() {
  <<0:4, 1:3, 1:1>>
}
fn return_fun(x) {
  fn(foo y: Int) { x + y }
}
fn expression_group() {
  {
    1 + 1
    "Hello, World!"
  }
}
fn foob(x, y) {
  case x, y {
    1, 2 | 3, 4 -> True
    _else -> False
  }
}
fn assignment() {
  let x = {
    1 + 1
    "Hello, World!"
  }
  let y = x
  let #(x, _) = #(1, 2)
}
fn assertations() {
  assert x = {
    1 + 1
    "Hello, World!"
  }
  assert y = x
  assert #(x, _) = #(1, 2)
}
fn update(x) {
  Cat(..x, name: "Nubi", cuteness: 1000 + 1001)
  animals.Dog(..myfun(), name: "Rey", cuteness: 1950)
}
fn tuple_access(x) {
  x.1
}
fn field_access(x) {
  x.name
}

---

(source_file
  (function
    name: (identifier)
    (function_body
      (string)))
  (function
    name: (identifier)
    (function_body
      (integer)))
  (function
    name: (identifier)
    (function_body
      (float)))
  (function
    name: (identifier)
    (function_body
      (record
        (arguments
          (argument
            label: (identifier)
            value: (string))))))
  (function
    name: (identifier)
    (function_body
      (remote_record
        module: (identifier)
        (record
          (arguments
             (argument
               label: (identifier)
               value: (string)))))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (var)))
  (function
    name: (identifier)
    (function_body
      (function_call
        (var))))
  (function
    name: (identifier)
    (function_body
      (todo
        message: (string))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (tuple
        (var)
        (integer))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (list
        (integer)
        (integer)
        spread: (var))))
  (function
    name: (identifier)
    (function_body
      (bit_string
        (bit_string_segment
          value: (integer)
          options: (bit_string_segment_options
            (integer)))
        (bit_string_segment
          value: (integer)
          options: (bit_string_segment_options
            (integer)))
        (bit_string_segment
          value: (integer)
          options: (bit_string_segment_options
            (integer))))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (anonymous_function
        parameters: (function_parameters
          (function_parameter
            label: (identifier)
            name: (identifier)
            type: (type)))
        (function_body
          (binary_expression
            (var)
            (var))))))
  (function
    name: (identifier)
    (function_body
      (expression_group
        (binary_expression
          (integer)
          (integer))
        (string))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier)))
    (function_body
      (case
        subjects: (case_subjects
          (var)
          (var))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (integer)
              (integer))
            (case_clause_pattern
              (integer)
              (integer)))
          (record))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (discard_var)))
          (record)))))
  (function
    name: (identifier)
    (function_body
      (let
        pattern: (var)
        value: (expression_group
          (binary_expression
            (integer)
            (integer))
          (string)))
      (let
        pattern: (var)
        value: (var))
      (let
        pattern: (tuple_pattern
          (var)
          (discard_var))
        value: (tuple
          (integer)
          (integer)))))
  (function
    name: (identifier)
    (function_body
      (assert
        pattern: (var)
        value: (expression_group
          (binary_expression
            (integer)
            (integer))
          (string)))
      (assert
        pattern: (var)
        value: (var))
      (assert
        pattern: (tuple_pattern
          (var)
          (discard_var))
        value: (tuple
          (integer)
          (integer)))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (record_update
        constructor: (record)
        spread: (var)
        arguments: (record_update_arguments
          (record_update_argument
            label: (identifier)
            value: (string))
          (record_update_argument
            label: (identifier)
            value: (binary_expression
              (integer)
              (integer)))))
      (record_update
        constructor: (remote_record
          module: (identifier))
        spread: (function_call
          (var))
        arguments: (record_update_arguments
          (record_update_argument
            label: (identifier)
            value: (string))
          (record_update_argument
            label: (identifier)
            value: (integer))))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (tuple_access
        tuple: (var)
        index: (integer))))
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (field_access
        record: (var)
        field: (identifier)))))

=====
Cases
=====

fn trial(x, y) {
  case x {
    1 -> 2
    2 -> 3
    _ -> 4
  }

  case y {
    #(z, _) | #(_, z) if z.1 == 5 -> True
    #(_, z) if z.2 >= 4 < 5 || z.1 > 6 -> True
  }

  case #(x, y) {
    #(1, 2) -> #(3, 4)
    _ -> #(5, 6)
  }
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier)))
    (function_body
      (case
        subjects: (case_subjects
          (var))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (integer)))
          (integer))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (integer)))
          (integer))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (discard_var)))
          (integer)))
      (case
        subjects: (case_subjects
          (var))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (tuple_pattern
                (var)
                (discard_var)))
            (case_clause_pattern
              (tuple_pattern
                (discard_var)
                (var))))
          guard: (case_clause_guard
            (binary_expression
              (tuple_access
                tuple: (var)
                index: (integer))
              (integer)))
          (record))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (tuple_pattern
                (discard_var)
                (var))))
          guard: (case_clause_guard
            (binary_expression
              (binary_expression
                (binary_expression
                  (tuple_access
                    tuple: (var)
                    index: (integer))
                  (integer))
                (integer))
              (binary_expression
                (tuple_access
                  tuple: (var)
                  index: (integer))
                (integer))))
          (record)))
      (case
        subjects: (case_subjects
          (tuple
            (var)
            (var)))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (tuple_pattern
                (integer)
                (integer))))
          (tuple
            (integer)
            (integer)))
        (case_clause
          patterns: (case_clause_patterns
            (case_clause_pattern
              (discard_var)))
          (tuple
            (integer)
            (integer)))))))

============
Try patterns
============

fn try_try_again(x, y) -> Int {
  try int_x = todo
  try _who_cares = todo
  try file.IODevice() = todo
  try Node = todo
  try "hello" = todo
  try 1 = todo
  try 12.34 = todo
  try #(a, b) = todo
  try <<a:utf8, b:size(8)>> = todo
  try [a, b] = todo
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter 
        name: (identifier))
      (function_parameter
        name: (identifier)))
    return_type: (type)
    (function_body
      (try
        pattern: (var)
        value: (todo))
      (try
        pattern: (discard_var)
        value: (todo))
      (try
        pattern: (remote_constructor_pattern
          (pattern_constructor_args))
        value: (todo))
      (try
        pattern: (constructor_pattern)
        value: (todo))
      (try
        pattern: (string)
        value: (todo))
      (try
        pattern: (integer)
        value: (todo))
      (try
        pattern: (float)
        value: (todo))
      (try
        pattern: (tuple_pattern
          (var)
          (var))
        value: (todo))
      (try
        pattern: (bit_string_pattern
          (bit_string_segment
            value: (var)
            options: (bit_string_segment_options
              (bit_string_segment_option_utf8)))
          (bit_string_segment
            value: (var)
            options: (bit_string_segment_options
              (bit_string_segment_option_size
                (integer)))))
        value: (todo))
      (try
        pattern: (list_pattern
          (var)
          (var))
        value: (todo)))))

==========================
Complex binary expressions
==========================

fn complicated(x, y) {
  x > y && x >= y || x + y |> fun() < x * y + 1
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier)))
    (function_body
      (binary_expression
        (binary_expression
          (binary_expression
            (var)
            (var))
          (binary_expression
            (var)
            (var)))
        (binary_expression
          (binary_expression
            (binary_expression
              (var)
              (var))
            (function_call
              (var)))
          (binary_expression
            (binary_expression
              (var)
              (var))
            (integer)))))))

=========================================
Complex nesting of field and tuple access
=========================================

fn complex_data_fun(x, y) {
  y.barbaz.2.thing
  x.1.qux.10
  x.2.foobar.1("Hello", 1)
  y.quux.2.quuz(12.34, "a")
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier)))
    (function_body
      (field_access
        record: (tuple_access
          tuple: (field_access
            record: (var)
            field: (identifier))
          index: (integer))
        field: (identifier))
      (tuple_access
        tuple: (field_access
          record: (tuple_access
            tuple: (var)
            index: (integer))
          field: (identifier))
        index: (integer))
      (function_call
        (tuple_access
          tuple: (field_access
            record: (tuple_access
              tuple: (var)
              index: (integer))
            field: (identifier))
          index: (integer))
        (arguments
          (argument
            value: (string))
          (argument
            value: (integer))))
      (function_call
        (field_access
          record: (tuple_access
            tuple: (field_access
              record: (var)
              field: (identifier))
            index: (integer))
          field: (identifier))
        (arguments
          (argument
            value: (float))
          (argument
            value: (string)))))))

============================
Unusual function invocations
============================

fn weird(x) {
  x(name: "Nubi")
  fn (x) { x + 1 }(3)
  {
    let fun = fn (x) { x + 1 }
  }(3)
  case 5 {
    5 -> fn (x) { x + 1 }
  }(3)
  returns_fun(1)(5)
}

---

(source_file
  (function
    name: (identifier)
    parameters: (function_parameters
      (function_parameter
        name: (identifier)))
    (function_body
      (function_call
        (var)
        (arguments
          (argument
            label: (identifier)
            value: (string))))
      (function_call
        (anonymous_function
          parameters: (function_parameters
            (function_parameter
              name: (identifier)))
          (function_body
            (binary_expression
              (var)
              (integer))))
        (arguments
          (argument
            value: (integer))))
      (function_call
        (expression_group
          (let
            pattern: (var)
            value: (anonymous_function
              parameters: (function_parameters
                (function_parameter
                  name: (identifier)))
              (function_body
                (binary_expression
                  (var)
                  (integer))))))
        (arguments
          (argument
            value: (integer))))
      (function_call
        (case
          subjects: (case_subjects
            (integer))
          (case_clause
            patterns: (case_clause_patterns
              (case_clause_pattern
                (integer)))
            (anonymous_function
              parameters: (function_parameters
                (function_parameter
                  name: (identifier)))
              (function_body
                (binary_expression
                  (var)
                  (integer))))))
        (arguments
          (argument
            value: (integer))))
      (function_call
        (function_call
          (var)
          (arguments
            (argument
              value: (integer))))
        (arguments
          (argument
            value: (integer)))))))