===========================================
Returning braced initializer lists
===========================================

T main() {
  return {0, 5};
}

---

(translation_unit
  (function_definition
    (type_identifier)
    (function_declarator (identifier) (parameter_list))
    (compound_statement
      (return_statement (initializer_list (number_literal) (number_literal))))))

===========================================
Range-based for loops
===========================================

T main() {
  for (Value &value : values) {
    cout << value;
  }

  for (const auto &value : values) {
    cout << value;
  }

  for (const auto &value : {1, 2, 3}) {
    cout << value;
  }
}

---

(translation_unit
  (function_definition
    (type_identifier)
    (function_declarator (identifier) (parameter_list))
    (compound_statement
      (for_range_loop
        (for_range_declaration (type_identifier) (reference_declarator (identifier)))
        (identifier)
        (compound_statement
          (expression_statement (shift_expression (identifier) (identifier)))))
      (for_range_loop
        (for_range_declaration (type_qualifier) (auto) (reference_declarator (identifier)))
        (identifier)
        (compound_statement
          (expression_statement (shift_expression (identifier) (identifier)))))
      (for_range_loop
        (for_range_declaration (type_qualifier) (auto) (reference_declarator (identifier)))
        (initializer_list (number_literal) (number_literal) (number_literal))
        (compound_statement
          (expression_statement (shift_expression (identifier) (identifier)))))))) 

===========================================
Constexpr if statements
===========================================

T f() {
  if constexpr (std::is_pointer_v<T>)
    return *t;
  else
    return t;
}

---

(translation_unit
  (function_definition
    (type_identifier)
    (function_declarator (identifier) (parameter_list))
    (compound_statement
      (if_statement
        (template_function
          (scoped_identifier (namespace_identifier) (identifier))
          (template_argument_list (type_descriptor (type_identifier))))
        (return_statement (pointer_expression (identifier)))
        (return_statement (identifier))))))

===========================================
Try/catch statements
===========================================

void main() {
  try {
      f();
  } catch (const std::overflow_error) {
      // f() throws std::overflow_error (same type rule)
  } catch (const exception &e) {
      // f() throws std::logic_error (base class rule)
  } catch (...) {
      // f() throws std::string or int or any other unrelated type
  }
}

---

(translation_unit
  (function_definition
    (primitive_type)
    (function_declarator (identifier) (parameter_list))
    (compound_statement
      (try_statement
        (compound_statement
          (expression_statement (call_expression (identifier) (argument_list))))
        (catch_clause
          (parameter_list (parameter_declaration (type_qualifier) (scoped_type_identifier (namespace_identifier) (type_identifier))))
          (compound_statement (comment)))
        (catch_clause
          (parameter_list (parameter_declaration (type_qualifier) (type_identifier) (reference_declarator (identifier))))
          (compound_statement (comment)))
        (catch_clause
          (parameter_list)
          (compound_statement (comment)))))))

===========================================
Throw statements
===========================================

void main() {
     throw e;
     throw x + 1;
     throw "exception";
}

---

(translation_unit
  (function_definition
    (primitive_type)
    (function_declarator
      (identifier)
      (parameter_list))
      (compound_statement
        (throw_statement (identifier))
        (throw_statement (math_expression (identifier) (number_literal)))
        (throw_statement (string_literal)))))
