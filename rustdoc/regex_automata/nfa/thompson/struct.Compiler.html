<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A builder for compiling an NFA from a regex’s high-level intermediate representation (HIR)."><title>Compiler in regex_automata::nfa::thompson - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.9</span></h2></div><h2 class="location"><a href="#">Compiler</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.build">build</a></li><li><a href="#method.build_from_hir">build_from_hir</a></li><li><a href="#method.build_many">build_many</a></li><li><a href="#method.build_many_from_hir">build_many_from_hir</a></li><li><a href="#method.configure">configure</a></li><li><a href="#method.new">new</a></li><li><a href="#method.syntax">syntax</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Compiler">Clone</a></li><li><a href="#impl-Debug-for-Compiler">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Compiler">!RefUnwindSafe</a></li><li><a href="#impl-Sync-for-Compiler">!Sync</a></li><li><a href="#impl-Send-for-Compiler">Send</a></li><li><a href="#impl-Unpin-for-Compiler">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Compiler">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../regex_automata/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">thompson</a>::<wbr><a class="struct" href="#">Compiler</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#696-714">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Compiler { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A builder for compiling an NFA from a regex’s high-level intermediate
representation (HIR).</p>
<p>This compiler provides a way to translate a parsed regex pattern into an
NFA state graph. The NFA state graph can either be used directly to execute
a search (e.g., with a Pike VM), or it can be further used to build a DFA.</p>
<p>This compiler provides APIs both for compiling regex patterns directly from
their concrete syntax, or via a <a href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir"><code>regex_syntax::hir::Hir</code></a>.</p>
<p>This compiler has various options that may be configured via
<a href="struct.Config.html" title="struct regex_automata::nfa::thompson::Config"><code>thompson::Config</code></a>.</p>
<p>Note that a compiler is not the same as a <a href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder"><code>thompson::Builder</code></a>.
A <code>Builder</code> provides a lower level API that is uncoupled from a regex
pattern’s concrete syntax or even its HIR. Instead, it permits stitching
together an NFA by hand. See its docs for examples.</p>
<h2 id="example-compilation-from-concrete-syntax"><a href="#example-compilation-from-concrete-syntax">Example: compilation from concrete syntax</a></h2>
<p>This shows how to compile an NFA from a pattern string while setting a size
limit on how big the NFA is allowed to be (in terms of bytes of heap used).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{NFA, pikevm::PikeVM},
    Match,
};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
<h2 id="example-compilation-from-hir"><a href="#example-compilation-from-hir">Example: compilation from HIR</a></h2>
<p>This shows how to hand assemble a regular expression via its HIR, and then
compile an NFA directly from it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hir = Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
    ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
    ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
    ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
    ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
])));

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_from_hir(<span class="kw-2">&amp;</span>hir)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#716-931">source</a><a href="#impl-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#718-727">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Create a new NFA builder with its default configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#756-758">source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>(&amp;self, pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given regular expression pattern into an NFA.</p>
<p>If there was a problem parsing the regex, then that error is returned.</p>
<p>Otherwise, if there was a problem building the NFA, then an error is
returned. The only error that can occur is if the compiled regex would
exceed the size limits configured on this builder, or if any part of
the NFA would exceed the integer representations used. (For example,
too many states might plausibly occur on a 16-bit target.)</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_many" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#785-800">source</a><h4 class="code-header">pub fn <a href="#method.build_many" class="fn">build_many</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.str.html">str</a>&gt;&gt;(
    &amp;self,
    patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.slice.html">[P]</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given regular expression patterns into a single NFA.</p>
<p>When matches are returned, the pattern ID corresponds to the index of
the pattern in the slice given.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_many(<span class="kw-2">&amp;</span>[
    <span class="string">r"(?-u)\s"</span>,
    <span class="string">r"(?-u)\w"</span>,
])<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">1</span>..<span class="number">2</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!A! !A!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_from_hir" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#836-838">source</a><h4 class="code-header">pub fn <a href="#method.build_from_hir" class="fn">build_from_hir</a>(&amp;self, expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given high level intermediate representation of a regular
expression into an NFA.</p>
<p>If there was a problem building the NFA, then an error is returned. The
only error that can occur is if the compiled regex would exceed the
size limits configured on this builder, or if any part of the NFA would
exceed the integer representations used. (For example, too many states
might plausibly occur on a 16-bit target.)</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hir = Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
    ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
    ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
    ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
    ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
])));

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_from_hir(<span class="kw-2">&amp;</span>hir)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_many_from_hir" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#877-882">source</a><h4 class="code-header">pub fn <a href="#method.build_many_from_hir" class="fn">build_many_from_hir</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>&gt;&gt;(
    &amp;self,
    exprs: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.slice.html">[H]</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given high level intermediate representations of regular
expressions into a single NFA.</p>
<p>When matches are returned, the pattern ID corresponds to the index of
the pattern in the slice given.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hirs = <span class="kw-2">&amp;</span>[
    Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
        ClassBytesRange::new(<span class="string">b'\t'</span>, <span class="string">b'\r'</span>),
        ClassBytesRange::new(<span class="string">b' '</span>, <span class="string">b' '</span>),
    ]))),
    Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
        ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
        ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
        ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
        ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
    ]))),
];

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_many_from_hir(hirs)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">1</span>..<span class="number">2</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!A! !A!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.configure" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#897-900">source</a><h4 class="code-header">pub fn <a href="#method.configure" class="fn">configure</a>(&amp;mut self, config: <a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::Config">Config</a>) -&gt; &amp;mut <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Apply the given NFA configuration options to this builder.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(nfa.pattern_len(), <span class="number">1</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.syntax" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#924-930">source</a><h4 class="code-header">pub fn <a href="#method.syntax" class="fn">syntax</a>(&amp;mut self, config: <a class="struct" href="../../util/syntax/struct.Config.html" title="struct regex_automata::util::syntax::Config">Config</a>) -&gt; &amp;mut <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Set the syntax configuration for this builder using
<a href="../../util/syntax/struct.Config.html" title="struct regex_automata::util::syntax::Config"><code>syntax::Config</code></a>.</p>
<p>This permits setting things like case insensitivity, Unicode and multi
line mode.</p>
<p>This syntax configuration only applies when an NFA is built directly
from a pattern string. If an NFA is built from an HIR, then all syntax
settings are ignored.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, util::syntax};

<span class="kw">let </span>syntax_config = syntax::Config::new().unicode(<span class="bool-val">false</span>);
<span class="kw">let </span>nfa = NFA::compiler().syntax(syntax_config).build(<span class="string">r"\w"</span>)<span class="question-mark">?</span>;
<span class="comment">// If Unicode were enabled, the number of states would be much bigger.
</span><span class="macro">assert!</span>(nfa.states().len() &lt; <span class="number">15</span>);
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#impl-Clone-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.76.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#impl-Debug-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.76.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Compiler" class="impl"><a href="#impl-RefUnwindSafe-for-Compiler" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section><section id="impl-Send-for-Compiler" class="impl"><a href="#impl-Send-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section><section id="impl-Sync-for-Compiler" class="impl"><a href="#impl-Sync-for-Compiler" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section><section id="impl-Unpin-for-Compiler" class="impl"><a href="#impl-Unpin-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section><section id="impl-UnwindSafe-for-Compiler" class="impl"><a href="#impl-UnwindSafe-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>