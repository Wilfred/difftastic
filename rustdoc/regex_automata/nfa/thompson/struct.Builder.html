<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An abstraction for building Thompson NFAs by hand."><title>Builder in regex_automata::nfa::thompson - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.13</span></h2></div><h2 class="location"><a href="#">Builder</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_capture_end">add_capture_end</a></li><li><a href="#method.add_capture_start">add_capture_start</a></li><li><a href="#method.add_empty">add_empty</a></li><li><a href="#method.add_fail">add_fail</a></li><li><a href="#method.add_look">add_look</a></li><li><a href="#method.add_match">add_match</a></li><li><a href="#method.add_range">add_range</a></li><li><a href="#method.add_sparse">add_sparse</a></li><li><a href="#method.add_union">add_union</a></li><li><a href="#method.add_union_reverse">add_union_reverse</a></li><li><a href="#method.build">build</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.current_pattern_id">current_pattern_id</a></li><li><a href="#method.finish_pattern">finish_pattern</a></li><li><a href="#method.get_look_matcher">get_look_matcher</a></li><li><a href="#method.get_reverse">get_reverse</a></li><li><a href="#method.get_size_limit">get_size_limit</a></li><li><a href="#method.get_utf8">get_utf8</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.new">new</a></li><li><a href="#method.patch">patch</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.set_look_matcher">set_look_matcher</a></li><li><a href="#method.set_reverse">set_reverse</a></li><li><a href="#method.set_size_limit">set_size_limit</a></li><li><a href="#method.set_utf8">set_utf8</a></li><li><a href="#method.start_pattern">start_pattern</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Builder">Clone</a></li><li><a href="#impl-Debug-for-Builder">Debug</a></li><li><a href="#impl-Default-for-Builder">Default</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Builder">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Builder">Send</a></li><li><a href="#impl-Sync-for-Builder">Sync</a></li><li><a href="#impl-Unpin-for-Builder">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Builder">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../regex_automata/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">thompson</a>::<wbr><a class="struct" href="#">Builder</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#313-357">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Builder { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An abstraction for building Thompson NFAs by hand.</p>
<p>A builder is what a <a href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler"><code>thompson::Compiler</code></a>
uses internally to translate a regex’s high-level intermediate
representation into an <a href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA"><code>NFA</code></a>.</p>
<p>The primary function of this builder is to abstract away the internal
representation of an NFA and make it difficult to produce NFAs are that
internally invalid or inconsistent. This builder also provides a way to
add “empty” states (which can be thought of as unconditional epsilon
transitions), despite the fact that <a href="enum.State.html" title="enum regex_automata::nfa::thompson::State"><code>thompson::State</code></a> does
not have any “empty” representation. The advantage of “empty” states is
that they make the code for constructing a Thompson NFA logically simpler.</p>
<p>Many of the routines on this builder may panic or return errors. Generally
speaking, panics occur when an invalid sequence of method calls were made,
where as an error occurs if things get too big. (Where “too big” might mean
exhausting identifier space or using up too much heap memory in accordance
with the configured <a href="struct.Builder.html#method.set_size_limit" title="method regex_automata::nfa::thompson::Builder::set_size_limit"><code>size_limit</code></a>.)</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2><h3 id="adding-multiple-patterns"><a class="doc-anchor" href="#adding-multiple-patterns">§</a>Adding multiple patterns</h3>
<p>Each pattern you add to an NFA should correspond to a pair of
<a href="struct.Builder.html#method.start_pattern" title="method regex_automata::nfa::thompson::Builder::start_pattern"><code>Builder::start_pattern</code></a> and <a href="struct.Builder.html#method.finish_pattern" title="method regex_automata::nfa::thompson::Builder::finish_pattern"><code>Builder::finish_pattern</code></a> calls, with
calls inbetween that add NFA states for that pattern. NFA states may be
added without first calling <code>start_pattern</code>, with the exception of adding
capturing states.</p>
<h3 id="adding-nfa-states"><a class="doc-anchor" href="#adding-nfa-states">§</a>Adding NFA states</h3>
<p>Here is a very brief overview of each of the methods that add NFA states.
Every method adds a single state.</p>
<ul>
<li><a href="struct.Builder.html#method.add_empty" title="method regex_automata::nfa::thompson::Builder::add_empty"><code>add_empty</code></a>: Add a state with a single
unconditional epsilon transition to another state.</li>
<li><a href="struct.Builder.html#method.add_union" title="method regex_automata::nfa::thompson::Builder::add_union"><code>add_union</code></a>: Adds a state with unconditional
epsilon transitions to two or more states, with earlier transitions
preferred over later ones.</li>
<li><a href="struct.Builder.html#method.add_union_reverse" title="method regex_automata::nfa::thompson::Builder::add_union_reverse"><code>add_union_reverse</code></a>: Adds a state with
unconditional epsilon transitions to two or more states, with later
transitions preferred over earlier ones.</li>
<li><a href="struct.Builder.html#method.add_range" title="method regex_automata::nfa::thompson::Builder::add_range"><code>add_range</code></a>: Adds a state with a single transition
to another state that can only be followed if the current input byte is
within the range given.</li>
<li><a href="struct.Builder.html#method.add_sparse" title="method regex_automata::nfa::thompson::Builder::add_sparse"><code>add_sparse</code></a>: Adds a state with two or more
range transitions to other states, where a transition is only followed
if the current input byte is within one of the ranges. All transitions
in this state have equal priority, and the corresponding ranges must be
non-overlapping.</li>
<li><a href="struct.Builder.html#method.add_look" title="method regex_automata::nfa::thompson::Builder::add_look"><code>add_look</code></a>: Adds a state with a single <em>conditional</em>
epsilon transition to another state, where the condition depends on a
limited look-around property.</li>
<li><a href="struct.Builder.html#method.add_capture_start" title="method regex_automata::nfa::thompson::Builder::add_capture_start"><code>add_capture_start</code></a>: Adds a state with
a single unconditional epsilon transition that also instructs an NFA
simulation to record the current input position to a specific location in
memory. This is intended to represent the starting location of a capturing
group.</li>
<li><a href="struct.Builder.html#method.add_capture_end" title="method regex_automata::nfa::thompson::Builder::add_capture_end"><code>add_capture_end</code></a>: Adds a state with
a single unconditional epsilon transition that also instructs an NFA
simulation to record the current input position to a specific location in
memory. This is intended to represent the ending location of a capturing
group.</li>
<li><a href="struct.Builder.html#method.add_fail" title="method regex_automata::nfa::thompson::Builder::add_fail"><code>add_fail</code></a>: Adds a state that never transitions to
another state.</li>
<li><a href="struct.Builder.html#method.add_match" title="method regex_automata::nfa::thompson::Builder::add_match"><code>add_match</code></a>: Add a state that indicates a match has
been found for a particular pattern. A match state is a final state with
no outgoing transitions.</li>
</ul>
<h3 id="setting-transitions-between-nfa-states"><a class="doc-anchor" href="#setting-transitions-between-nfa-states">§</a>Setting transitions between NFA states</h3>
<p>The <a href="struct.Builder.html#method.patch" title="method regex_automata::nfa::thompson::Builder::patch"><code>Builder::patch</code></a> method creates a transition from one state to the
next. If the <code>from</code> state corresponds to a state that supports multiple
outgoing transitions (such as “union”), then this adds the corresponding
transition. Otherwise, it sets the single transition. (This routine panics
if <code>from</code> corresponds to a state added by <code>add_sparse</code>, since sparse states
need more specialized handling.)</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>This annotated example shows how to hand construct the regex <code>[a-z]+</code>
(without an unanchored prefix).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{pikevm::PikeVM, Builder, Transition},
    util::primitives::StateID,
    Match,
};

<span class="kw">let </span><span class="kw-2">mut </span>builder = Builder::new();
<span class="comment">// Before adding NFA states for our pattern, we need to tell the builder
// that we are starting the pattern.
</span>builder.start_pattern()<span class="question-mark">?</span>;
<span class="comment">// Since we use the Pike VM below for searching, we need to add capturing
// states. If you're just going to build a DFA from the NFA, then capturing
// states do not need to be added.
</span><span class="kw">let </span>start = builder.add_capture_start(StateID::ZERO, <span class="number">0</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>range = builder.add_range(Transition {
    <span class="comment">// We don't know the state ID of the 'next' state yet, so we just fill
    // in a dummy 'ZERO' value.
    </span>start: <span class="string">b'a'</span>, end: <span class="string">b'z'</span>, next: StateID::ZERO,
})<span class="question-mark">?</span>;
<span class="comment">// This state will point back to 'range', but also enable us to move ahead.
// That is, this implements the '+' repetition operator. We add 'range' and
// then 'end' below to this alternation.
</span><span class="kw">let </span>alt = builder.add_union(<span class="macro">vec!</span>[])<span class="question-mark">?</span>;
<span class="comment">// The final state before the match state, which serves to capture the
// end location of the match.
</span><span class="kw">let </span>end = builder.add_capture_end(StateID::ZERO, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="comment">// The match state for our pattern.
</span><span class="kw">let </span>mat = builder.add_match()<span class="question-mark">?</span>;
<span class="comment">// Now we fill in the transitions between states.
</span>builder.patch(start, range)<span class="question-mark">?</span>;
builder.patch(range, alt)<span class="question-mark">?</span>;
<span class="comment">// If we added 'end' before 'range', then we'd implement non-greedy
// matching, i.e., '+?'.
</span>builder.patch(alt, range)<span class="question-mark">?</span>;
builder.patch(alt, end)<span class="question-mark">?</span>;
builder.patch(end, mat)<span class="question-mark">?</span>;
<span class="comment">// We must explicitly finish pattern and provide the starting state ID for
// this particular pattern.
</span>builder.finish_pattern(start)<span class="question-mark">?</span>;
<span class="comment">// Finally, when we build the NFA, we provide the anchored and unanchored
// starting state IDs. Since we didn't bother with an unanchored prefix
// here, we only support anchored searching. Thus, both starting states are
// the same.
</span><span class="kw">let </span>nfa = builder.build(start, start)<span class="question-mark">?</span>;

<span class="comment">// Now build a Pike VM from our NFA, and use it for searching. This shows
// how we can use a regex engine without ever worrying about syntax!
</span><span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foo0"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Builder" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#359-1311">source</a><a href="#impl-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#361-363">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h4></section></summary><div class="docblock"><p>Create a new builder for hand-assembling NFAs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#371-377">source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clear this builder.</p>
<p>Clearing removes all state associated with building an NFA, but does
not reset configuration (such as size limits and whether the NFA
should only match UTF-8). After clearing, the builder can be reused to
assemble an entirely new NFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#410-603">source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>(
    &amp;self,
    start_anchored: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    start_unanchored: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Assemble a <a href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA"><code>NFA</code></a> from the states added so far.</p>
<p>After building an NFA, more states may be added and <code>build</code> may be
called again. To reuse a builder to produce an entirely new NFA from
scratch, call the <a href="struct.Builder.html#method.clear" title="method regex_automata::nfa::thompson::Builder::clear"><code>clear</code></a> method first.</p>
<p><code>start_anchored</code> refers to the ID of the starting state that anchored
searches should use. That is, searches who matches are limited to the
starting position of the search.</p>
<p><code>start_unanchored</code> refers to the ID of the starting state that
unanchored searches should use. This permits searches to report matches
that start after the beginning of the search. In cases where unanchored
searches are not supported, the unanchored starting state ID must be
the same as the anchored starting state ID.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error if there was a problem producing the final NFA.
In particular, this might include an error if the capturing groups
added to this builder violate any of the invariants documented on
<a href="../../util/captures/struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo"><code>GroupInfo</code></a>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>If <code>start_pattern</code> was called, then <code>finish_pattern</code> must be called
before <code>build</code>, otherwise this panics.</p>
<p>This may panic for other invalid uses of a builder. For example, if
a “start capture” state was added without a corresponding “end capture”
state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.start_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#622-632">source</a><h4 class="code-header">pub fn <a href="#method.start_pattern" class="fn">start_pattern</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Start the assembly of a pattern in this NFA.</p>
<p>Upon success, this returns the identifier for the new pattern.
Identifiers start at <code>0</code> and are incremented by 1 for each new pattern.</p>
<p>It is necessary to call this routine before adding capturing states.
Otherwise, any other NFA state may be added before starting a pattern.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>If the pattern identifier space is exhausted, then this returns an
error.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>If this is called while assembling another pattern (i.e., before
<code>finish_pattern</code> is called), then this panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.finish_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#653-661">source</a><h4 class="code-header">pub fn <a href="#method.finish_pattern" class="fn">finish_pattern</a>(
    &amp;mut self,
    start_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Finish the assembly of a pattern in this NFA.</p>
<p>Upon success, this returns the identifier for the new pattern.
Identifiers start at <code>0</code> and are incremented by 1 for each new
pattern. This is the same identifier returned by the corresponding
<code>start_pattern</code> call.</p>
<p>Note that <code>start_pattern</code> and <code>finish_pattern</code> pairs cannot be
interleaved or nested. A correct <code>finish_pattern</code> call <em>always</em>
corresponds to the most recently called <code>start_pattern</code> routine.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This currently never returns an error, but this is subject to change.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>If this is called without a corresponding <code>start_pattern</code> call, then
this panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.current_pattern_id" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#669-671">source</a><h4 class="code-header">pub fn <a href="#method.current_pattern_id" class="fn">current_pattern_id</a>(&amp;self) -&gt; <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section></summary><div class="docblock"><p>Returns the pattern identifier of the current pattern.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>If this doesn’t occur after a <code>start_pattern</code> call and before the
corresponding <code>finish_pattern</code> call, then this panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_len" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#677-679">source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fn">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of patterns added to this builder so far.</p>
<p>This only includes patterns that have had <code>finish_pattern</code> called
for them.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_empty" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#692-694">source</a><h4 class="code-header">pub fn <a href="#method.add_empty" class="fn">add_empty</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add an “empty” NFA state.</p>
<p>An “empty” NFA state is a state with a single unconditional epsilon
transition to another NFA state. Such empty states are removed before
building the final <a href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA"><code>NFA</code></a> (which has no such “empty” states), but they
can be quite useful in the construction process of an NFA.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_union" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#713-718">source</a><h4 class="code-header">pub fn <a href="#method.add_union" class="fn">add_union</a>(
    &amp;mut self,
    alternates: <a class="struct" href="https://doc.rust-lang.org/1.77.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “union” NFA state.</p>
<p>A “union” NFA state that contains zero or more unconditional epsilon
transitions to other NFA states. The order of these transitions
reflects a priority order where earlier transitions are preferred over
later transitions.</p>
<p>Callers may provide an empty set of alternates to this method call, and
then later add transitions via <code>patch</code>. At final build time, a “union”
state with no alternates is converted to a “fail” state, and a “union”
state with exactly one alternate is treated as if it were an “empty”
state.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_union_reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#739-744">source</a><h4 class="code-header">pub fn <a href="#method.add_union_reverse" class="fn">add_union_reverse</a>(
    &amp;mut self,
    alternates: <a class="struct" href="https://doc.rust-lang.org/1.77.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “reverse union” NFA state.</p>
<p>A “reverse union” NFA state contains zero or more unconditional epsilon
transitions to other NFA states. The order of these transitions
reflects a priority order where later transitions are preferred
over earlier transitions. This is an inverted priority order when
compared to <code>add_union</code>. This is useful, for example, for implementing
non-greedy repetition operators.</p>
<p>Callers may provide an empty set of alternates to this method call, and
then later add transitions via <code>patch</code>. At final build time, a “reverse
union” state with no alternates is converted to a “fail” state, and a
“reverse union” state with exactly one alternate is treated as if it
were an “empty” state.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_range" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#756-761">source</a><h4 class="code-header">pub fn <a href="#method.add_range" class="fn">add_range</a>(&amp;mut self, trans: <a class="struct" href="struct.Transition.html" title="struct regex_automata::nfa::thompson::Transition">Transition</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “range” NFA state.</p>
<p>A “range” NFA state is a state with one outgoing transition to another
state, where that transition may only be followed if the current input
byte falls between a range of bytes given.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_sparse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#793-798">source</a><h4 class="code-header">pub fn <a href="#method.add_sparse" class="fn">add_sparse</a>(
    &amp;mut self,
    transitions: <a class="struct" href="https://doc.rust-lang.org/1.77.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Transition.html" title="struct regex_automata::nfa::thompson::Transition">Transition</a>&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “sparse” NFA state.</p>
<p>A “sparse” NFA state contains zero or more outgoing transitions, where
the transition to be followed (if any) is chosen based on whether the
current input byte falls in the range of one such transition. The
transitions given <em>must</em> be non-overlapping and in ascending order. (A
“sparse” state with no transitions is equivalent to a “fail” state.)</p>
<p>A “sparse” state is like adding a “union” state and pointing it at a
bunch of “range” states, except that the different alternates have
equal priority.</p>
<p>Note that a “sparse” state is the only state that cannot be patched.
This is because a “sparse” state has many transitions, each of which
may point to a different NFA state. Moreover, adding more such
transitions requires more than just an NFA state ID to point to. It
also requires a byte range. The <code>patch</code> routine does not support the
additional information required. Therefore, callers must ensure that
all outgoing transitions for this state are included when <code>add_sparse</code>
is called. There is no way to add more later.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>This routine <em>may</em> panic if the transitions given overlap or are not
in ascending order.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_look" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#813-819">source</a><h4 class="code-header">pub fn <a href="#method.add_look" class="fn">add_look</a>(
    &amp;mut self,
    next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    look: <a class="enum" href="../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “look” NFA state.</p>
<p>A “look” NFA state corresponds to a state with exactly one
<em>conditional</em> epsilon transition to another NFA state. Namely, it
represents one of a small set of simplistic look-around operators.</p>
<p>Callers may provide a “dummy” state ID (typically <a href="../../util/primitives/struct.StateID.html#associatedconstant.ZERO" title="associated constant regex_automata::util::primitives::StateID::ZERO"><code>StateID::ZERO</code></a>),
and then change it later with <a href="struct.Builder.html#method.patch" title="method regex_automata::nfa::thompson::Builder::patch"><code>patch</code></a>.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_capture_start" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#991-1026">source</a><h4 class="code-header">pub fn <a href="#method.add_capture_start" class="fn">add_capture_start</a>(
    &amp;mut self,
    next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    group_index: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u32.html">u32</a>,
    name: <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.77.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.str.html">str</a>&gt;&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “start capture” NFA state.</p>
<p>A “start capture” NFA state corresponds to a state with exactly one
outgoing unconditional epsilon transition to another state. Unlike
“empty” states, a “start capture” state also carries with it an
instruction for saving the current position of input to a particular
location in memory. NFA simulations, like the Pike VM, may use this
information to report the match locations of capturing groups in a
regex pattern.</p>
<p>If the corresponding capturing group has a name, then callers should
include it here.</p>
<p>Callers may provide a “dummy” state ID (typically <a href="../../util/primitives/struct.StateID.html#associatedconstant.ZERO" title="associated constant regex_automata::util::primitives::StateID::ZERO"><code>StateID::ZERO</code></a>),
and then change it later with <a href="struct.Builder.html#method.patch" title="method regex_automata::nfa::thompson::Builder::patch"><code>patch</code></a>.</p>
<p>Note that unlike <code>start_pattern</code>/<code>finish_pattern</code>, capturing start and
end states may be interleaved. Indeed, it is typical for many “start
capture” NFA states to appear before the first “end capture” state.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded or if the given
capture index overflows <code>usize</code>.</p>
<p>While the above are the only conditions in which this routine can
currently return an error, it is possible to call this method with an
inputs that results in the final <code>build()</code> step failing to produce an
NFA. For example, if one adds two distinct capturing groups with the
same name, then that will result in <code>build()</code> failing with an error.</p>
<p>See the <a href="../../util/captures/struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo"><code>GroupInfo</code></a> type for
more information on what qualifies as valid capturing groups.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This example shows that an error occurs when one tries to add multiple
capturing groups with the same name to the same pattern.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::Builder,
    util::primitives::StateID,
};

<span class="kw">let </span>name = <span class="prelude-val">Some</span>(std::sync::Arc::from(<span class="string">"foo"</span>));
<span class="kw">let </span><span class="kw-2">mut </span>builder = Builder::new();
builder.start_pattern()<span class="question-mark">?</span>;
<span class="comment">// 0th capture group should always be unnamed.
</span><span class="kw">let </span>start = builder.add_capture_start(StateID::ZERO, <span class="number">0</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;
<span class="comment">// OK
</span>builder.add_capture_start(StateID::ZERO, <span class="number">1</span>, name.clone())<span class="question-mark">?</span>;
<span class="comment">// This is not OK, but 'add_capture_start' still succeeds. We don't
// get an error until we call 'build' below. Without this call, the
// call to 'build' below would succeed.
</span>builder.add_capture_start(StateID::ZERO, <span class="number">2</span>, name.clone())<span class="question-mark">?</span>;
<span class="comment">// Finish our pattern so we can try to build the NFA.
</span>builder.finish_pattern(start)<span class="question-mark">?</span>;
<span class="kw">let </span>result = builder.build(start, start);
<span class="macro">assert!</span>(result.is_err());
</code></pre></div>
<p>However, adding multiple capturing groups with the same name to
distinct patterns is okay:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::Arc;

<span class="kw">use </span>regex_automata::{
    nfa::thompson::{pikevm::PikeVM, Builder, Transition},
    util::{
        captures::Captures,
        primitives::{PatternID, StateID},
    },
    Span,
};

<span class="comment">// Hand-compile the patterns '(?P&lt;foo&gt;[a-z])' and '(?P&lt;foo&gt;[A-Z])'.
</span><span class="kw">let </span><span class="kw-2">mut </span>builder = Builder::new();
<span class="comment">// We compile them to support an unanchored search, which requires
// adding an implicit '(?s-u:.)*?' prefix before adding either pattern.
</span><span class="kw">let </span>unanchored_prefix = builder.add_union_reverse(<span class="macro">vec!</span>[])<span class="question-mark">?</span>;
<span class="kw">let </span>any = builder.add_range(Transition {
    start: <span class="string">b'\x00'</span>, end: <span class="string">b'\xFF'</span>, next: StateID::ZERO,
})<span class="question-mark">?</span>;
builder.patch(unanchored_prefix, any)<span class="question-mark">?</span>;
builder.patch(any, unanchored_prefix)<span class="question-mark">?</span>;

<span class="comment">// Compile an alternation that permits matching multiple patterns.
</span><span class="kw">let </span>alt = builder.add_union(<span class="macro">vec!</span>[])<span class="question-mark">?</span>;
builder.patch(unanchored_prefix, alt)<span class="question-mark">?</span>;

<span class="comment">// Compile '(?P&lt;foo&gt;[a-z]+)'.
</span>builder.start_pattern()<span class="question-mark">?</span>;
<span class="kw">let </span>start0 = builder.add_capture_start(StateID::ZERO, <span class="number">0</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;
<span class="comment">// N.B. 0th capture group must always be unnamed.
</span><span class="kw">let </span>foo_start0 = builder.add_capture_start(
    StateID::ZERO, <span class="number">1</span>, <span class="prelude-val">Some</span>(Arc::from(<span class="string">"foo"</span>)),
)<span class="question-mark">?</span>;
<span class="kw">let </span>lowercase = builder.add_range(Transition {
    start: <span class="string">b'a'</span>, end: <span class="string">b'z'</span>, next: StateID::ZERO,
})<span class="question-mark">?</span>;
<span class="kw">let </span>foo_end0 = builder.add_capture_end(StateID::ZERO, <span class="number">1</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>end0 = builder.add_capture_end(StateID::ZERO, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>match0 = builder.add_match()<span class="question-mark">?</span>;
builder.patch(start0, foo_start0)<span class="question-mark">?</span>;
builder.patch(foo_start0, lowercase)<span class="question-mark">?</span>;
builder.patch(lowercase, foo_end0)<span class="question-mark">?</span>;
builder.patch(foo_end0, end0)<span class="question-mark">?</span>;
builder.patch(end0, match0)<span class="question-mark">?</span>;
builder.finish_pattern(start0)<span class="question-mark">?</span>;

<span class="comment">// Compile '(?P&lt;foo&gt;[A-Z]+)'.
</span>builder.start_pattern()<span class="question-mark">?</span>;
<span class="kw">let </span>start1 = builder.add_capture_start(StateID::ZERO, <span class="number">0</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;
<span class="comment">// N.B. 0th capture group must always be unnamed.
</span><span class="kw">let </span>foo_start1 = builder.add_capture_start(
    StateID::ZERO, <span class="number">1</span>, <span class="prelude-val">Some</span>(Arc::from(<span class="string">"foo"</span>)),
)<span class="question-mark">?</span>;
<span class="kw">let </span>uppercase = builder.add_range(Transition {
    start: <span class="string">b'A'</span>, end: <span class="string">b'Z'</span>, next: StateID::ZERO,
})<span class="question-mark">?</span>;
<span class="kw">let </span>foo_end1 = builder.add_capture_end(StateID::ZERO, <span class="number">1</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>end1 = builder.add_capture_end(StateID::ZERO, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>match1 = builder.add_match()<span class="question-mark">?</span>;
builder.patch(start1, foo_start1)<span class="question-mark">?</span>;
builder.patch(foo_start1, uppercase)<span class="question-mark">?</span>;
builder.patch(uppercase, foo_end1)<span class="question-mark">?</span>;
builder.patch(foo_end1, end1)<span class="question-mark">?</span>;
builder.patch(end1, match1)<span class="question-mark">?</span>;
builder.finish_pattern(start1)<span class="question-mark">?</span>;

<span class="comment">// Now add the patterns to our alternation that we started above.
</span>builder.patch(alt, start0)<span class="question-mark">?</span>;
builder.patch(alt, start1)<span class="question-mark">?</span>;

<span class="comment">// Finally build the NFA. The first argument is the anchored starting
// state (the pattern alternation) where as the second is the
// unanchored starting state (the unanchored prefix).
</span><span class="kw">let </span>nfa = builder.build(alt, unanchored_prefix)<span class="question-mark">?</span>;

<span class="comment">// Now build a Pike VM from our NFA and access the 'foo' capture
// group regardless of which pattern matched, since it is defined
// for both patterns.
</span><span class="kw">let </span>vm = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = vm.create_cache();
<span class="kw">let </span>caps: Vec&lt;Captures&gt; =
    vm.captures_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"0123aAaAA"</span>).collect();
<span class="macro">assert_eq!</span>(<span class="number">5</span>, caps.len());

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">0</span>)), caps[<span class="number">0</span>].pattern());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">4</span>..<span class="number">5</span>)), caps[<span class="number">0</span>].get_group_by_name(<span class="string">"foo"</span>));

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">1</span>)), caps[<span class="number">1</span>].pattern());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">5</span>..<span class="number">6</span>)), caps[<span class="number">1</span>].get_group_by_name(<span class="string">"foo"</span>));

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">0</span>)), caps[<span class="number">2</span>].pattern());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">6</span>..<span class="number">7</span>)), caps[<span class="number">2</span>].get_group_by_name(<span class="string">"foo"</span>));

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">1</span>)), caps[<span class="number">3</span>].pattern());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">7</span>..<span class="number">8</span>)), caps[<span class="number">3</span>].get_group_by_name(<span class="string">"foo"</span>));

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">1</span>)), caps[<span class="number">4</span>].pattern());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">8</span>..<span class="number">9</span>)), caps[<span class="number">4</span>].get_group_by_name(<span class="string">"foo"</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_capture_end" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1058-1071">source</a><h4 class="code-header">pub fn <a href="#method.add_capture_end" class="fn">add_capture_end</a>(
    &amp;mut self,
    next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    group_index: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u32.html">u32</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a “end capture” NFA state.</p>
<p>A “end capture” NFA state corresponds to a state with exactly one
outgoing unconditional epsilon transition to another state. Unlike
“empty” states, a “end capture” state also carries with it an
instruction for saving the current position of input to a particular
location in memory. NFA simulations, like the Pike VM, may use this
information to report the match locations of capturing groups in a</p>
<p>Callers may provide a “dummy” state ID (typically <a href="../../util/primitives/struct.StateID.html#associatedconstant.ZERO" title="associated constant regex_automata::util::primitives::StateID::ZERO"><code>StateID::ZERO</code></a>),
and then change it later with <a href="struct.Builder.html#method.patch" title="method regex_automata::nfa::thompson::Builder::patch"><code>patch</code></a>.</p>
<p>Note that unlike <code>start_pattern</code>/<code>finish_pattern</code>, capturing start and
end states may be interleaved. Indeed, it is typical for many “start
capture” NFA states to appear before the first “end capture” state.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded or if the given
capture index overflows <code>usize</code>.</p>
<p>While the above are the only conditions in which this routine can
currently return an error, it is possible to call this method with an
inputs that results in the final <code>build()</code> step failing to produce an
NFA. For example, if one adds two distinct capturing groups with the
same name, then that will result in <code>build()</code> failing with an error.</p>
<p>See the <a href="../../util/captures/struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo"><code>GroupInfo</code></a> type for
more information on what qualifies as valid capturing groups.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_fail" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1084-1086">source</a><h4 class="code-header">pub fn <a href="#method.add_fail" class="fn">add_fail</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a “fail” NFA state.</p>
<p>A “fail” state is simply a state that has no outgoing transitions. It
acts as a way to cause a search to stop without reporting a match.
For example, one way to represent an NFA with zero patterns is with a
single “fail” state.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_match" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1105-1109">source</a><h4 class="code-header">pub fn <a href="#method.add_match" class="fn">add_match</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a “match” NFA state.</p>
<p>A “match” state has no outgoing transitions (just like a “fail”
state), but it has special significance in that if a search enters
this state, then a match has been found. The match state that is added
automatically has the current pattern ID associated with it. This is
used to report the matching pattern ID at search time.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This returns an error if the state identifier space is exhausted, or if
the configured heap size limit has been exceeded.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>This must be called after a <code>start_pattern</code> call but before the
corresponding <code>finish_pattern</code> call. Otherwise, it panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.patch" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1143-1183">source</a><h4 class="code-header">pub fn <a href="#method.patch" class="fn">patch</a>(&amp;mut self, from: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, to: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.unit.html">()</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a transition from one state to another.</p>
<p>This routine is called “patch” since it is very common to add the
states you want, typically with “dummy” state ID transitions, and then
“patch” in the real state IDs later. This is because you don’t always
know all of the necessary state IDs to add because they might not
exist yet.</p>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>This may error if patching leads to an increase in heap usage beyond
the configured size limit. Heap usage only grows when patching adds a
new transition (as in the case of a “union” state).</p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h5>
<p>This panics if <code>from</code> corresponds to a “sparse” state. When “sparse”
states are added, there is no way to patch them after-the-fact. (If you
have a use case where this would be helpful, please file an issue. It
will likely require a new API.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_utf8" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1219-1221">source</a><h4 class="code-header">pub fn <a href="#method.set_utf8" class="fn">set_utf8</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Set whether the NFA produced by this builder should only match UTF-8.</p>
<p>This should be set when both of the following are true:</p>
<ol>
<li>The caller guarantees that the NFA created by this build will only
report non-empty matches with spans that are valid UTF-8.</li>
<li>The caller desires regex engines using this NFA to avoid reporting
empty matches with a span that splits a valid UTF-8 encoded codepoint.</li>
</ol>
<p>Property (1) is not checked. Instead, this requires the caller to
promise that it is true. Property (2) corresponds to the behavior of
regex engines using the NFA created by this builder. Namely, there
is no way in the NFA’s graph itself to say that empty matches found
by, for example, the regex <code>a*</code> will fall on valid UTF-8 boundaries.
Instead, this option is used to communicate the UTF-8 semantic to regex
engines that will typically implement it as a post-processing step by
filtering out empty matches that don’t fall on UTF-8 boundaries.</p>
<p>If you’re building an NFA from an HIR (and not using a
<a href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler"><code>thompson::Compiler</code></a>), then you can
use the <a href="../../util/syntax/struct.Config.html#method.utf8" title="method regex_automata::util::syntax::Config::utf8"><code>syntax::Config::utf8</code></a>
option to guarantee that if the HIR detects a non-empty match, then it
is guaranteed to be valid UTF-8.</p>
<p>Note that property (2) does <em>not</em> specify the behavior of executing
a search on a haystack that is not valid UTF-8. Therefore, if you’re
<em>not</em> running this NFA on strings that are guaranteed to be valid
UTF-8, you almost certainly do not want to enable this option.
Similarly, if you are running the NFA on strings that <em>are</em> guaranteed
to be valid UTF-8, then you almost certainly want to enable this option
unless you can guarantee that your NFA will never produce a zero-width
match.</p>
<p>It is disabled by default.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_utf8" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1226-1228">source</a><h4 class="code-header">pub fn <a href="#method.get_utf8" class="fn">get_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether UTF-8 mode is enabled for this builder.</p>
<p>See <a href="struct.Builder.html#method.set_utf8" title="method regex_automata::nfa::thompson::Builder::set_utf8"><code>Builder::set_utf8</code></a> for more details about what “UTF-8 mode” is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1239-1241">source</a><h4 class="code-header">pub fn <a href="#method.set_reverse" class="fn">set_reverse</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets whether the NFA produced by this builder should be matched in
reverse or not. Generally speaking, when enabled, the NFA produced
should be matched by moving backwards through a haystack, from a higher
memory address to a lower memory address.</p>
<p>See also <a href="struct.NFA.html#method.is_reverse" title="method regex_automata::nfa::thompson::NFA::is_reverse"><code>NFA::is_reverse</code></a> for more details.</p>
<p>This is disabled by default, which means NFAs are by default matched
in the forward direction.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1247-1249">source</a><h4 class="code-header">pub fn <a href="#method.get_reverse" class="fn">get_reverse</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether reverse mode is enabled for this builder.</p>
<p>See <a href="struct.Builder.html#method.set_reverse" title="method regex_automata::nfa::thompson::Builder::set_reverse"><code>Builder::set_reverse</code></a> for more details about what “reverse mode”
is.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_look_matcher" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1257-1259">source</a><h4 class="code-header">pub fn <a href="#method.set_look_matcher" class="fn">set_look_matcher</a>(&amp;mut self, m: <a class="struct" href="../../util/look/struct.LookMatcher.html" title="struct regex_automata::util::look::LookMatcher">LookMatcher</a>)</h4></section></summary><div class="docblock"><p>Sets the look-around matcher that should be used for the resulting NFA.</p>
<p>A look-around matcher can be used to configure how look-around
assertions are matched. For example, a matcher might carry
configuration that changes the line terminator used for <code>(?m:^)</code> and
<code>(?m:$)</code> assertions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_look_matcher" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1265-1267">source</a><h4 class="code-header">pub fn <a href="#method.get_look_matcher" class="fn">get_look_matcher</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/look/struct.LookMatcher.html" title="struct regex_automata::util::look::LookMatcher">LookMatcher</a></h4></section></summary><div class="docblock"><p>Returns the look-around matcher used for this builder.</p>
<p>If a matcher was not explicitly set, then <code>LookMatcher::default()</code> is
returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1276-1282">source</a><h4 class="code-header">pub fn <a href="#method.set_size_limit" class="fn">set_size_limit</a>(&amp;mut self, limit: <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.unit.html">()</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Set the size limit on this builder.</p>
<p>Setting the size limit will also check whether the NFA built so far
fits within the given size limit. If it doesn’t, then an error is
returned.</p>
<p>By default, there is no configured size limit.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1288-1290">source</a><h4 class="code-header">pub fn <a href="#method.get_size_limit" class="fn">get_size_limit</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Return the currently configured size limit.</p>
<p>By default, this returns <code>None</code>, which corresponds to no configured
size limit.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#1299-1301">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the heap memory usage, in bytes, used by the NFA states added
so far.</p>
<p>Note that this is an approximation of how big the final NFA will be.
In practice, the final NFA will likely be a bit smaller because of
its simpler state representation. (For example, using things like
<code>Box&lt;[StateID]&gt;</code> instead of <code>Vec&lt;StateID&gt;</code>.)</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Builder" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#impl-Clone-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.77.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Builder" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#impl-Debug-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.77.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Builder" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#impl-Default-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/builder.rs.html#312">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.77.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Builder" class="impl"><a href="#impl-RefUnwindSafe-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section><section id="impl-Send-for-Builder" class="impl"><a href="#impl-Send-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section><section id="impl-Sync-for-Builder" class="impl"><a href="#impl-Sync-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section><section id="impl-Unpin-for-Builder" class="impl"><a href="#impl-Unpin-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section><section id="impl-UnwindSafe-for-Builder" class="impl"><a href="#impl-UnwindSafe-for-Builder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::Builder">Builder</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#764">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#767">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#757">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.77.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#804-806">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#811">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#789-791">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#796">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>