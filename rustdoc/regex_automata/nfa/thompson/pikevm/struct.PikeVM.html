<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A virtual machine for executing regex searches with capturing groups."><title>PikeVM in regex_automata::nfa::thompson::pikevm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.9</span></h2></div><h2 class="location"><a href="#">PikeVM</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.always_match">always_match</a></li><li><a href="#method.builder">builder</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.config">config</a></li><li><a href="#method.create_cache">create_cache</a></li><li><a href="#method.create_captures">create_captures</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.get_config">get_config</a></li><li><a href="#method.get_nfa">get_nfa</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.never_match">never_match</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_from_nfa">new_from_nfa</a></li><li><a href="#method.new_many">new_many</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.reset_cache">reset_cache</a></li><li><a href="#method.search">search</a></li><li><a href="#method.search_slots">search_slots</a></li><li><a href="#method.which_overlapping_matches">which_overlapping_matches</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-PikeVM">Clone</a></li><li><a href="#impl-Debug-for-PikeVM">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-PikeVM">RefUnwindSafe</a></li><li><a href="#impl-Send-for-PikeVM">Send</a></li><li><a href="#impl-Sync-for-PikeVM">Sync</a></li><li><a href="#impl-Unpin-for-PikeVM">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PikeVM">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson::pikevm</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../regex_automata/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../../index.html">regex_automata</a>::<wbr><a href="../../index.html">nfa</a>::<wbr><a href="../index.html">thompson</a>::<wbr><a href="index.html">pikevm</a>::<wbr><a class="struct" href="#">PikeVM</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#387-390">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct PikeVM { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A virtual machine for executing regex searches with capturing groups.</p>
<h2 id="infallible-apis"><a href="#infallible-apis">Infallible APIs</a></h2>
<p>Unlike most other regex engines in this crate, a <code>PikeVM</code> never returns an
error at search time. It supports all <a href="../../../enum.Anchored.html" title="enum regex_automata::Anchored"><code>Anchored</code></a> configurations, never
quits and works on haystacks of arbitrary length.</p>
<p>There are two caveats to mention though:</p>
<ul>
<li>If an invalid pattern ID is given to a search via <a href="../../../enum.Anchored.html#variant.Pattern" title="variant regex_automata::Anchored::Pattern"><code>Anchored::Pattern</code></a>,
then the PikeVM will report “no match.” This is consistent with all other
regex engines in this crate.</li>
<li>When using <a href="struct.PikeVM.html#method.which_overlapping_matches" title="method regex_automata::nfa::thompson::pikevm::PikeVM::which_overlapping_matches"><code>PikeVM::which_overlapping_matches</code></a> with a <a href="../../../struct.PatternSet.html" title="struct regex_automata::PatternSet"><code>PatternSet</code></a>
that has insufficient capacity to store all valid pattern IDs, then if a
match occurs for a <code>PatternID</code> that cannot be inserted, it is silently
dropped as if it did not match.</li>
</ul>
<h2 id="advice"><a href="#advice">Advice</a></h2>
<p>The <code>PikeVM</code> is generally the most “powerful” regex engine in this crate.
“Powerful” in this context means that it can handle any regular expression
that is parseable by <code>regex-syntax</code> and any size haystack. Regretably,
the <code>PikeVM</code> is also simultaneously often the <em>slowest</em> regex engine in
practice. This results in an annoying situation where one generally tries
to pick any other regex engine (or perhaps none at all) before being
forced to fall back to a <code>PikeVM</code>.</p>
<p>For example, a common strategy for dealing with capturing groups is to
actually look for the overall match of the regex using a faster regex
engine, like a <a href="../../../hybrid/regex/struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">lazy DFA</a>. Once the overall
match is found, one can then run the <code>PikeVM</code> on just the match span to
find the spans of the capturing groups. In this way, the faster regex
engine does the majority of the work, while the <code>PikeVM</code> only lends its
power in a more limited role.</p>
<p>Unfortunately, this isn’t always possible because the faster regex engines
don’t support all of the regex features in <code>regex-syntax</code>. This notably
includes (and is currently limited to) Unicode word boundaries. So if
your pattern has Unicode word boundaries, you typically can’t use a
DFA-based regex engine at all (unless you <a href="../../../hybrid/dfa/struct.Config.html#method.unicode_word_boundary" title="method regex_automata::hybrid::dfa::Config::unicode_word_boundary">enable heuristic support for
it</a>). (The <a href="../../../dfa/onepass/struct.DFA.html" title="struct regex_automata::dfa::onepass::DFA">one-pass
DFA</a> can handle Unicode word boundaries for
anchored searches only, but in a cruel sort of joke, many Unicode features
tend to result in making the regex <em>not</em> one-pass.)</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This example shows that the <code>PikeVM</code> implements Unicode word boundaries
correctly by default.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r"\b\w+\b"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"Шерлок Холмс"</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">12</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">13</span>..<span class="number">23</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-PikeVM" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#392-706">source</a><a href="#impl-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#413-415">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expression using the default configuration and
return the corresponding <code>PikeVM</code>.</p>
<p>If you want a non-default configuration, then use the <a href="struct.Builder.html" title="struct regex_automata::nfa::thompson::pikevm::Builder"><code>Builder</code></a> to
set your own configuration.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">14</span>)),
    re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"zzzfoo12345barzzz"</span>).next(),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_many" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#439-443">source</a><h4 class="code-header">pub fn <a href="#method.new_many" class="fn">new_many</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.str.html">str</a>&gt;&gt;(patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.slice.html">[P]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Like <code>new</code>, but parses multiple patterns into a single “multi regex.”
This similarly uses the default regex configuration.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new_many(<span class="kw-2">&amp;</span>[<span class="string">"[a-z]+"</span>, <span class="string">"[0-9]+"</span>])<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"abc 1 foo 4567 0 quux"</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">4</span>..<span class="number">5</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">6</span>..<span class="number">9</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">10</span>..<span class="number">14</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">15</span>..<span class="number">16</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">17</span>..<span class="number">21</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_from_nfa" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#475-477">source</a><h4 class="code-header">pub fn <a href="#method.new_from_nfa" class="fn">new_from_nfa</a>(nfa: <a class="struct" href="../struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Like <code>new</code>, but builds a PikeVM directly from an NFA. This is useful
if you already have an NFA, or even if you hand-assembled the NFA.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This shows how to hand assemble a regular expression via its HIR,
compile an NFA from it and build a PikeVM from the NFA.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hir = Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
    ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
    ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
    ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
    ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
])));

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_from_hir(<span class="kw-2">&amp;</span>hir)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.always_match" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#494-497">source</a><h4 class="code-header">pub fn <a href="#method.always_match" class="fn">always_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>PikeVM</code> that matches every input.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::always_match()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>expected = Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">""</span>).next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foo"</span>).next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.never_match" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#513-516">source</a><h4 class="code-header">pub fn <a href="#method.never_match" class="fn">never_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>PikeVM</code> that never matches any input.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::pikevm::PikeVM;

<span class="kw">let </span>re = PikeVM::never_match()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">""</span>).next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foo"</span>).next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.config" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#552-554">source</a><h4 class="code-header">pub fn <a href="#method.config" class="fn">config</a>() -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::pikevm::Config">Config</a></h4></section></summary><div class="docblock"><p>Return a default configuration for a <code>PikeVM</code>.</p>
<p>This is a convenience routine to avoid needing to import the <code>Config</code>
type when customizing the construction of a <code>PikeVM</code>.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to disable UTF-8 mode. When UTF-8 mode is
disabled, zero-width matches that split a codepoint are allowed.
Otherwise they are never reported.</p>
<p>In the code below, notice that <code>&quot;&quot;</code> is permitted to match positions
that split the encoding of a codepoint.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{<span class="self">self</span>, pikevm::PikeVM}, Match};

<span class="kw">let </span>re = PikeVM::builder()
    .thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r""</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>haystack = <span class="string">"a☃z"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="kw-2">&amp;mut </span>cache, haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">1</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">2</span>..<span class="number">2</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">4</span>..<span class="number">4</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">5</span>..<span class="number">5</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.builder" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#586-588">source</a><h4 class="code-header">pub fn <a href="#method.builder" class="fn">builder</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::pikevm::Builder">Builder</a></h4></section></summary><div class="docblock"><p>Return a builder for configuring the construction of a <code>PikeVM</code>.</p>
<p>This is a convenience routine to avoid needing to import the
<a href="struct.Builder.html" title="struct regex_automata::nfa::thompson::pikevm::Builder"><code>Builder</code></a> type in common cases.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<p>This example shows how to use the builder to disable UTF-8 mode
everywhere.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{<span class="self">self</span>, pikevm::PikeVM},
    util::syntax,
    Match,
};

<span class="kw">let </span>re = PikeVM::builder()
    .syntax(syntax::Config::new().utf8(<span class="bool-val">false</span>))
    .thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r"foo(?-u:[^b])ar.*"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="kw">let </span>haystack = <span class="string">b"\xFEfoo\xFFarzz\xE2\x98\xFF\n"</span>;
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">9</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, haystack, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.create_captures" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#600-602">source</a><h4 class="code-header">pub fn <a href="#method.create_captures" class="fn">create_captures</a>(&amp;self) -&gt; <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a></h4></section></summary><div class="docblock"><p>Create a new empty set of capturing groups that is guaranteed to be
valid for the search APIs on this <code>PikeVM</code>.</p>
<p>A <code>Captures</code> value created for a specific <code>PikeVM</code> cannot be used with
any other <code>PikeVM</code>.</p>
<p>This is a convenience function for <a href="../../../util/captures/struct.Captures.html#method.all" title="associated function regex_automata::util::captures::Captures::all"><code>Captures::all</code></a>. See the
<a href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures"><code>Captures</code></a> documentation for an explanation of its alternative
constructors that permit the <code>PikeVM</code> to do less work during a search,
and thus might make it faster.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.create_cache" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#610-612">source</a><h4 class="code-header">pub fn <a href="#method.create_cache" class="fn">create_cache</a>(&amp;self) -&gt; <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a></h4></section></summary><div class="docblock"><p>Create a new cache for this <code>PikeVM</code>.</p>
<p>The cache returned should only be used for searches for this
<code>PikeVM</code>. If you want to reuse the cache for another <code>PikeVM</code>, then
you must call <a href="struct.Cache.html#method.reset" title="method regex_automata::nfa::thompson::pikevm::Cache::reset"><code>Cache::reset</code></a> with that <code>PikeVM</code> (or, equivalently,
<a href="struct.PikeVM.html#method.reset_cache" title="method regex_automata::nfa::thompson::pikevm::PikeVM::reset_cache"><code>PikeVM::reset_cache</code></a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_cache" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#651-653">source</a><h4 class="code-header">pub fn <a href="#method.reset_cache" class="fn">reset_cache</a>(&amp;self, cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>)</h4></section></summary><div class="docblock"><p>Reset the given cache such that it can be used for searching with the
this <code>PikeVM</code> (and only this <code>PikeVM</code>).</p>
<p>A cache reset permits reusing memory already allocated in this cache
with a different <code>PikeVM</code>.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<p>This shows how to re-purpose a cache for use with a different <code>PikeVM</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re1 = PikeVM::new(<span class="string">r"\w"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>re2 = PikeVM::new(<span class="string">r"\W"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>cache = re1.create_cache();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">2</span>)),
    re1.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"Δ"</span>).next(),
);

<span class="comment">// Using 'cache' with re2 is not allowed. It may result in panics or
// incorrect results. In order to re-purpose the cache, we must reset
// it with the PikeVM we'd like to use it with.
//
// Similarly, after this reset, using the cache with 're1' is also not
// allowed.
</span>re2.reset_cache(<span class="kw-2">&amp;mut </span>cache);
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)),
    re2.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">"☃"</span>).next(),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_len" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#691-693">source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fn">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns compiled into this <code>PikeVM</code>.</p>
<p>In the case of a <code>PikeVM</code> that contains no patterns, this returns <code>0</code>.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<p>This example shows the pattern length for a <code>PikeVM</code> that never
matches:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::pikevm::PikeVM;

<span class="kw">let </span>re = PikeVM::never_match()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(re.pattern_len(), <span class="number">0</span>);</code></pre></div>
<p>And another example for a <code>PikeVM</code> that matches at every position:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::pikevm::PikeVM;

<span class="kw">let </span>re = PikeVM::always_match()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(re.pattern_len(), <span class="number">1</span>);</code></pre></div>
<p>And finally, a <code>PikeVM</code> that was constructed from multiple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::pikevm::PikeVM;

<span class="kw">let </span>re = PikeVM::new_many(<span class="kw-2">&amp;</span>[<span class="string">"[0-9]+"</span>, <span class="string">"[a-z]+"</span>, <span class="string">"[A-Z]+"</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(re.pattern_len(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_config" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#697-699">source</a><h4 class="code-header">pub fn <a href="#method.get_config" class="fn">get_config</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::pikevm::Config">Config</a></h4></section></summary><div class="docblock"><p>Return the config for this <code>PikeVM</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_nfa" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#703-705">source</a><h4 class="code-header">pub fn <a href="#method.get_nfa" class="fn">get_nfa</a>(&amp;self) -&gt; &amp;<a class="struct" href="../struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying NFA.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PikeVM-1" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#708-941">source</a><a href="#impl-PikeVM-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#767-774">source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>&lt;'h, I: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;self,
    cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: I
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this <code>PikeVM</code> matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future
input will never lead to a different result. In particular, if the
underlying NFA enters a match state, then this routine will return
<code>true</code> immediately without inspecting any future input. (Consider how
this might make a difference given the regex <code>a+</code> on the haystack
<code>aaaaaaaaaaaaaaa</code>. This routine can stop after it sees the first <code>a</code>,
but routines like <code>find</code> need to continue searching because <code>+</code> is
greedy by default.)</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<p>This shows basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::pikevm::PikeVM;

<span class="kw">let </span>re = PikeVM::new(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="macro">assert!</span>(re.is_match(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foo12345bar"</span>));
<span class="macro">assert!</span>(!re.is_match(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foobar"</span>));</code></pre></div>
<h5 id="example-consistency-with-search-apis"><a href="#example-consistency-with-search-apis">Example: consistency with search APIs</a></h5>
<p><code>is_match</code> is guaranteed to return <code>true</code> whenever <code>find</code> returns a
match. This includes searches that are executed entirely within a
codepoint:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Input};

<span class="kw">let </span>re = PikeVM::new(<span class="string">"a*"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="macro">assert!</span>(!re.is_match(<span class="kw-2">&amp;mut </span>cache, Input::new(<span class="string">"☃"</span>).span(<span class="number">1</span>..<span class="number">2</span>)));</code></pre></div>
<p>Notice that when UTF-8 mode is disabled, then the above reports a
match because the restriction against zero-width matches that split a
codepoint has been lifted:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{pikevm::PikeVM, NFA}, Input};

<span class="kw">let </span>re = PikeVM::builder()
    .thompson(NFA::config().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">"a*"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="macro">assert!</span>(re.is_match(<span class="kw-2">&amp;mut </span>cache, Input::new(<span class="string">"☃"</span>).span(<span class="number">1</span>..<span class="number">2</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#815-835">source</a><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'h, I: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;self,
    cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: I
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and returns a <code>Match</code> if one exists.</p>
<p>This routine only includes the overall match span. To get access to the
individual spans of each capturing group, use <a href="struct.PikeVM.html#method.captures" title="method regex_automata::nfa::thompson::pikevm::PikeVM::captures"><code>PikeVM::captures</code></a>.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>Leftmost first match semantics corresponds to the match with the
smallest starting offset, but where the end offset is determined by
preferring earlier branches in the original regular expression. For
example, <code>Sam|Samwise</code> will match <code>Sam</code> in <code>Samwise</code>, but <code>Samwise|Sam</code>
will match <code>Samwise</code> in <code>Samwise</code>.</p>
<p>Generally speaking, the “leftmost first” match is how most backtracking
regular expressions tend to work. This is in contrast to POSIX-style
regular expressions that yield “leftmost longest” matches. Namely,
both <code>Sam|Samwise</code> and <code>Samwise|Sam</code> match <code>Samwise</code> when using
leftmost longest semantics. (This crate does not currently support
leftmost longest semantics.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span>expected = Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">"foo12345"</span>));

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the leftmost first match semantics demand that we find the earliest
// match that prefers earlier parts of the pattern over later parts.
</span><span class="kw">let </span>re = PikeVM::new(<span class="string">"abc|a"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span>expected = Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">"abc"</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#859-866">source</a><h4 class="code-header">pub fn <a href="#method.captures" class="fn">captures</a>&lt;'h, I: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;self,
    cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: I,
    caps: &amp;mut <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a>
)</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <a href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures"><code>Captures</code></a>
value. If no match was found, then <a href="../../../util/captures/struct.Captures.html#method.is_match" title="method regex_automata::util::captures::Captures::is_match"><code>Captures::is_match</code></a> is guaranteed
to return <code>false</code>.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Span};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r"^([0-9]{4})-([0-9]{2})-([0-9]{2})$"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"2010-03-14"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert!</span>(caps.is_match());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">0</span>..<span class="number">4</span>)), caps.get_group(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">5</span>..<span class="number">7</span>)), caps.get_group(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">8</span>..<span class="number">10</span>)), caps.get_group(<span class="number">3</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_iter" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#889-897">source</a><h4 class="code-header">pub fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'r, 'c, 'h, I: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;'r self,
    cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: I
) -&gt; <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::nfa::thompson::pikevm::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt; <a href="#" class="tooltip" data-notable-ty="FindMatches&lt;&#39;r, &#39;c, &#39;h&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>text = <span class="string">"foo1 foo12 foo123"</span>;
<span class="kw">let </span>matches: Vec&lt;Match&gt; = re.find_iter(<span class="kw-2">&amp;mut </span>cache, text).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[
    Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">4</span>),
    Match::must(<span class="number">0</span>, <span class="number">5</span>..<span class="number">10</span>),
    Match::must(<span class="number">0</span>, <span class="number">11</span>..<span class="number">17</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_iter" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#932-940">source</a><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fn">captures_iter</a>&lt;'r, 'c, 'h, I: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;'r self,
    cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: I
) -&gt; <a class="struct" href="struct.CapturesMatches.html" title="struct regex_automata::nfa::thompson::pikevm::CapturesMatches">CapturesMatches</a>&lt;'r, 'c, 'h&gt; <a href="#" class="tooltip" data-notable-ty="CapturesMatches&lt;&#39;r, &#39;c, &#39;h&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping <code>Captures</code> values. If no
match exists, then the iterator yields no elements.</p>
<p>This yields the same matches as <a href="struct.PikeVM.html#method.find_iter" title="method regex_automata::nfa::thompson::pikevm::PikeVM::find_iter"><code>PikeVM::find_iter</code></a>, but it includes
the spans of all capturing groups that participate in each match.</p>
<p><strong>Tip:</strong> See <a href="../../../util/iter/struct.Searcher.html" title="struct regex_automata::util::iter::Searcher"><code>util::iter::Searcher</code></a> for
how to correctly iterate over all matches in a haystack while avoiding
the creation of a new <code>Captures</code> value for every match. (Which you are
forced to do with an <code>Iterator</code>.)</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Span};

<span class="kw">let </span>re = PikeVM::new(<span class="string">"foo(?P&lt;numbers&gt;[0-9]+)"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>text = <span class="string">"foo1 foo12 foo123"</span>;
<span class="kw">let </span>matches: Vec&lt;Span&gt; = re
    .captures_iter(<span class="kw-2">&amp;mut </span>cache, text)
    <span class="comment">// The unwrap is OK since 'numbers' matches if the pattern matches.
    </span>.map(|caps| caps.get_group_by_name(<span class="string">"numbers"</span>).unwrap())
    .collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[
    Span::from(<span class="number">3</span>..<span class="number">4</span>),
    Span::from(<span class="number">8</span>..<span class="number">10</span>),
    Span::from(<span class="number">14</span>..<span class="number">17</span>),
]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PikeVM-2" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#943-1216">source</a><a href="#impl-PikeVM-2" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.search" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1020-1029">source</a><h4 class="code-header">pub fn <a href="#method.search" class="fn">search</a>(&amp;self, cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;, caps: &amp;mut <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a>)</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <a href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures"><code>Captures</code></a>
value. If no match was found, then <a href="../../../util/captures/struct.Captures.html#method.is_match" title="method regex_automata::util::captures::Captures::is_match"><code>Captures::is_match</code></a> is guaranteed
to return <code>false</code>.</p>
<p>This is like <a href="struct.PikeVM.html#method.captures" title="method regex_automata::nfa::thompson::pikevm::PikeVM::captures"><code>PikeVM::captures</code></a>, but it accepts a concrete <code>&amp;Input</code>
instead of an <code>Into&lt;Input&gt;</code>.</p>
<h5 id="example-specific-pattern-search"><a href="#example-specific-pattern-search">Example: specific pattern search</a></h5>
<p>This example shows how to build a multi-PikeVM that permits searching
for specific patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    Anchored, Match, PatternID, Input,
};

<span class="kw">let </span>re = PikeVM::new_many(<span class="kw-2">&amp;</span>[<span class="string">"[a-z0-9]{6}"</span>, <span class="string">"[a-z][a-z0-9]{5}"</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>haystack = <span class="string">"foo123"</span>;

<span class="comment">// Since we are using the default leftmost-first match and both
// patterns match at the same starting position, only the first pattern
// will be returned in this case when doing a search for any of the
// patterns.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">6</span>));
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>Input::new(haystack), <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());

<span class="comment">// But if we want to check whether some other pattern matches, then we
// can provide its pattern ID.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">0</span>..<span class="number">6</span>));
<span class="kw">let </span>input = Input::new(haystack)
    .anchored(Anchored::Pattern(PatternID::must(<span class="number">1</span>)));
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
<h5 id="example-specifying-the-bounds-of-a-search"><a href="#example-specifying-the-bounds-of-a-search">Example: specifying the bounds of a search</a></h5>
<p>This example shows how providing the bounds of a search can produce
different results than simply sub-slicing the haystack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match, Input};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r"\b[0-9]{3}\b"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>haystack = <span class="string">"foo123bar"</span>;

<span class="comment">// Since we sub-slice the haystack, the search doesn't know about
// the larger context and assumes that `123` is surrounded by word
// boundaries. And of course, the match position is reported relative
// to the sub-slice as well, which means we get `0..3` instead of
// `3..6`.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>));
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>Input::new(<span class="kw-2">&amp;</span>haystack[<span class="number">3</span>..<span class="number">6</span>]), <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());

<span class="comment">// But if we provide the bounds of the search within the context of the
// entire haystack, then the search can take the surrounding context
// into account. (And if we did find a match, it would be reported
// as a valid offset into `haystack` instead of its sub-slice.)
</span><span class="kw">let </span>expected = <span class="prelude-val">None</span>;
<span class="kw">let </span>input = Input::new(haystack).range(<span class="number">3</span>..<span class="number">6</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.search_slots" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1091-1132">source</a><h4 class="code-header">pub fn <a href="#method.search_slots" class="fn">search_slots</a>(
    &amp;self,
    cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
    slots: &amp;mut [<a class="enum" href="https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../util/primitives/struct.NonMaxUsize.html" title="struct regex_automata::util::primitives::NonMaxUsize">NonMaxUsize</a>&gt;]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <code>slots</code>, and
returns the matching pattern ID. The contents of the slots for patterns
other than the matching pattern are unspecified. If no match was found,
then <code>None</code> is returned and the contents of <code>slots</code> is unspecified.</p>
<p>This is like <a href="struct.PikeVM.html#method.search" title="method regex_automata::nfa::thompson::pikevm::PikeVM::search"><code>PikeVM::search</code></a>, but it accepts a raw slots slice
instead of a <code>Captures</code> value. This is useful in contexts where you
don’t want or need to allocate a <code>Captures</code>.</p>
<p>It is legal to pass <em>any</em> number of slots to this routine. If the regex
engine would otherwise write a slot offset that doesn’t fit in the
provided slice, then it is simply skipped. In general though, there are
usually three slice lengths you might want to use:</p>
<ul>
<li>An empty slice, if you only care about which pattern matched.</li>
<li>A slice with
<a href="../struct.NFA.html#method.pattern_len" title="method regex_automata::nfa::thompson::NFA::pattern_len"><code>pattern_len() * 2</code></a>
slots, if you only care about the overall match spans for each matching
pattern.</li>
<li>A slice with
<a href="../../../util/captures/struct.GroupInfo.html#method.slot_len" title="method regex_automata::util::captures::GroupInfo::slot_len"><code>slot_len()</code></a> slots, which
permits recording match offsets for every capturing group in every
pattern.</li>
</ul>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<p>This example shows how to find the overall match offsets in a
multi-pattern search without allocating a <code>Captures</code> value. Indeed, we
can put our slots right on the stack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID, Input};

<span class="kw">let </span>re = PikeVM::new_many(<span class="kw-2">&amp;</span>[
    <span class="string">r"\pL+"</span>,
    <span class="string">r"\d+"</span>,
])<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span>input = Input::new(<span class="string">"!@#123"</span>);

<span class="comment">// We only care about the overall match offsets here, so we just
// allocate two slots for each pattern. Each slot records the start
// and end of the match.
</span><span class="kw">let </span><span class="kw-2">mut </span>slots = [<span class="prelude-val">None</span>; <span class="number">4</span>];
<span class="kw">let </span>pid = re.search_slots(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>slots);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(PatternID::must(<span class="number">1</span>)), pid);

<span class="comment">// The overall match offsets are always at 'pid * 2' and 'pid * 2 + 1'.
// See 'GroupInfo' for more details on the mapping between groups and
// slot indices.
</span><span class="kw">let </span>slot_start = pid.unwrap().as_usize() * <span class="number">2</span>;
<span class="kw">let </span>slot_end = slot_start + <span class="number">1</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), slots[slot_start].map(|s| s.get()));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>), slots[slot_end].map(|s| s.get()));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.which_overlapping_matches" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1208-1215">source</a><h4 class="code-header">pub fn <a href="#method.which_overlapping_matches" class="fn">which_overlapping_matches</a>(
    &amp;self,
    cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>,
    input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
    patset: &amp;mut <a class="struct" href="../../../struct.PatternSet.html" title="struct regex_automata::PatternSet">PatternSet</a>
)</h4></section></summary><div class="docblock"><p>Writes the set of patterns that match anywhere in the given search
configuration to <code>patset</code>. If multiple patterns match at the same
position and this <code>PikeVM</code> was configured with <a href="../../../enum.MatchKind.html#variant.All" title="variant regex_automata::MatchKind::All"><code>MatchKind::All</code></a>
semantics, then all matching patterns are written to the given set.</p>
<p>Unless all of the patterns in this <code>PikeVM</code> are anchored, then
generally speaking, this will visit every byte in the haystack.</p>
<p>This search routine <em>does not</em> clear the pattern set. This gives some
flexibility to the caller (e.g., running multiple searches with the
same pattern set), but does make the API bug-prone if you’re reusing
the same pattern set for multiple searches but intended them to be
independent.</p>
<p>If a pattern ID matched but the given <code>PatternSet</code> does not have
sufficient capacity to store it, then it is not inserted and silently
dropped.</p>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<p>This example shows how to find all matching patterns in a haystack,
even when some patterns match at the same position as other patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    Input, MatchKind, PatternSet,
};

<span class="kw">let </span>patterns = <span class="kw-2">&amp;</span>[
    <span class="string">r"\w+"</span>, <span class="string">r"\d+"</span>, <span class="string">r"\pL+"</span>, <span class="string">r"foo"</span>, <span class="string">r"bar"</span>, <span class="string">r"barfoo"</span>, <span class="string">r"foobar"</span>,
];
<span class="kw">let </span>re = PikeVM::builder()
    .configure(PikeVM::config().match_kind(MatchKind::All))
    .build_many(patterns)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>input = Input::new(<span class="string">"foobar"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>patset = PatternSet::new(re.pattern_len());
re.which_overlapping_matches(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>patset);
<span class="kw">let </span>expected = <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>];
<span class="kw">let </span>got: Vec&lt;usize&gt; = patset.iter().map(|p| p.as_usize()).collect();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-PikeVM" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a><a href="#impl-Clone-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.76.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-PikeVM" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a><a href="#impl-Debug-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.76.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-PikeVM" class="impl"><a href="#impl-RefUnwindSafe-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Send-for-PikeVM" class="impl"><a href="#impl-Send-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Sync-for-PikeVM" class="impl"><a href="#impl-Sync-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Unpin-for-PikeVM" class="impl"><a href="#impl-Unpin-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-UnwindSafe-for-PikeVM" class="impl"><a href="#impl-UnwindSafe-for-PikeVM" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"CapturesMatches<'r, 'c, 'h>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CapturesMatches.html\" title=\"struct regex_automata::nfa::thompson::pikevm::CapturesMatches\">CapturesMatches</a>&lt;'r, 'c, 'h&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'r, 'c, 'h&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CapturesMatches.html\" title=\"struct regex_automata::nfa::thompson::pikevm::CapturesMatches\">CapturesMatches</a>&lt;'r, 'c, 'h&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.76.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../../util/captures/struct.Captures.html\" title=\"struct regex_automata::util::captures::Captures\">Captures</a>;</div>","FindMatches<'r, 'c, 'h>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindMatches.html\" title=\"struct regex_automata::nfa::thompson::pikevm::FindMatches\">FindMatches</a>&lt;'r, 'c, 'h&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'r, 'c, 'h&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.76.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindMatches.html\" title=\"struct regex_automata::nfa::thompson::pikevm::FindMatches\">FindMatches</a>&lt;'r, 'c, 'h&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.76.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../../struct.Match.html\" title=\"struct regex_automata::Match\">Match</a>;</div>"}</script></section></div></main></body></html>