<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A byte oriented Thompson non-deterministic finite automaton (NFA)."><meta name="keywords" content="rust, rustlang, rust-lang, NFA"><title>NFA in regex_automata::nfa::thompson - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">NFA</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.always_match">always_match</a></li><li><a href="#method.byte_classes">byte_classes</a></li><li><a href="#method.compiler">compiler</a></li><li><a href="#method.config">config</a></li><li><a href="#method.group_info">group_info</a></li><li><a href="#method.has_capture">has_capture</a></li><li><a href="#method.has_empty">has_empty</a></li><li><a href="#method.is_always_start_anchored">is_always_start_anchored</a></li><li><a href="#method.is_reverse">is_reverse</a></li><li><a href="#method.is_utf8">is_utf8</a></li><li><a href="#method.look_matcher">look_matcher</a></li><li><a href="#method.look_set_any">look_set_any</a></li><li><a href="#method.look_set_prefix_any">look_set_prefix_any</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.never_match">never_match</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_many">new_many</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.patterns">patterns</a></li><li><a href="#method.start_anchored">start_anchored</a></li><li><a href="#method.start_pattern">start_pattern</a></li><li><a href="#method.start_unanchored">start_unanchored</a></li><li><a href="#method.state">state</a></li><li><a href="#method.states">states</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone-for-NFA">Clone</a></li><li><a href="#impl-Debug-for-NFA">Debug</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-NFA">RefUnwindSafe</a></li><li><a href="#impl-Send-for-NFA">Send</a></li><li><a href="#impl-Sync-for-NFA">Sync</a></li><li><a href="#impl-Unpin-for-NFA">Unpin</a></li><li><a href="#impl-UnwindSafe-for-NFA">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-NFA">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-NFA">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-NFA">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-NFA">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-NFA">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-NFA">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-NFA">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-NFA">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_automata::nfa::thompson</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">thompson</a>::<wbr><a class="struct" href="#">NFA</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#190-202">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct NFA(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A byte oriented Thompson non-deterministic finite automaton (NFA).</p>
<p>A Thompson NFA is a finite state machine that permits unconditional epsilon
transitions, but guarantees that there exists at most one non-epsilon
transition for each element in the alphabet for each state.</p>
<p>An NFA may be used directly for searching, for analysis or to build
a deterministic finite automaton (DFA).</p>
<h2 id="cheap-clones"><a href="#cheap-clones">Cheap clones</a></h2>
<p>Since an NFA is a core data type in this crate that many other regex
engines are based on top of, it is convenient to give ownership of an NFA
to said regex engines. Because of this, an NFA uses reference counting
internally. Therefore, it is cheap to clone and it is encouraged to do so.</p>
<h2 id="capabilities"><a href="#capabilities">Capabilities</a></h2>
<p>Using an NFA for searching via the
<a href="pikevm/struct.PikeVM.html"><code>PikeVM</code></a> provides the most amount
of “power” of any regex engine in this crate. Namely, it supports the
following in all cases:</p>
<ol>
<li>Detection of a match.</li>
<li>Location of a match, including both the start and end offset, in a
single pass of the haystack.</li>
<li>Location of matching capturing groups.</li>
<li>Handles multiple patterns, including (1)-(3) when multiple patterns are
present.</li>
</ol>
<h2 id="capturing-groups"><a href="#capturing-groups">Capturing Groups</a></h2>
<p>Groups refer to parenthesized expressions inside a regex pattern. They look
like this, where <code>exp</code> is an arbitrary regex:</p>
<ul>
<li><code>(exp)</code> - An unnamed capturing group.</li>
<li><code>(?P&lt;name&gt;exp)</code> or <code>(?&lt;name&gt;exp)</code> - A named capturing group.</li>
<li><code>(?:exp)</code> - A non-capturing group.</li>
<li><code>(?i:exp)</code> - A non-capturing group that sets flags.</li>
</ul>
<p>Only the first two forms are said to be <em>capturing</em>. Capturing
means that the last position at which they match is reportable. The
<a href="../../util/captures/struct.Captures.html"><code>Captures</code></a> type provides convenient
access to the match positions of capturing groups, which includes looking
up capturing groups by their name.</p>
<h2 id="byte-oriented"><a href="#byte-oriented">Byte oriented</a></h2>
<p>This NFA is byte oriented, which means that all of its transitions are
defined on bytes. In other words, the alphabet of an NFA consists of the
256 different byte values.</p>
<p>While DFAs nearly demand that they be byte oriented for performance
reasons, an NFA could conceivably be <em>Unicode codepoint</em> oriented. Indeed,
a previous version of this NFA supported both byte and codepoint oriented
modes. A codepoint oriented mode can work because an NFA fundamentally uses
a sparse representation of transitions, which works well with the large
sparse space of Unicode codepoints.</p>
<p>Nevertheless, this NFA is only byte oriented. This choice is primarily
driven by implementation simplicity, and also in part memory usage. In
practice, performance between the two is roughly comparable. However,
building a DFA (including a hybrid DFA) really wants a byte oriented NFA.
So if we do have a codepoint oriented NFA, then we also need to generate
byte oriented NFA in order to build an hybrid NFA/DFA. Thus, by only
generating byte oriented NFAs, we can produce one less NFA. In other words,
if we made our NFA codepoint oriented, we’d need to <em>also</em> make it support
a byte oriented mode, which is more complicated. But a byte oriented mode
can support everything.</p>
<h2 id="differences-with-dfas"><a href="#differences-with-dfas">Differences with DFAs</a></h2>
<p>At the theoretical level, the precise difference between an NFA and a DFA
is that, in a DFA, for every state, an input symbol unambiguously refers
to a single transition <em>and</em> that an input symbol is required for each
transition. At a practical level, this permits DFA implementations to be
implemented at their core with a small constant number of CPU instructions
for each byte of input searched. In practice, this makes them quite a bit
faster than NFAs <em>in general</em>. Namely, in order to execute a search for any
Thompson NFA, one needs to keep track of a <em>set</em> of states, and execute
the possible transitions on all of those states for each input symbol.
Overall, this results in much more overhead. To a first approximation, one
can expect DFA searches to be about an order of magnitude faster.</p>
<p>So why use an NFA at all? The main advantage of an NFA is that it takes
linear time (in the size of the pattern string after repetitions have been
expanded) to build and linear memory usage. A DFA, on the other hand, may
take exponential time and/or space to build. Even in non-pathological
cases, DFAs often take quite a bit more memory than their NFA counterparts,
<em>especially</em> if large Unicode character classes are involved. Of course,
an NFA also provides additional capabilities. For example, it can match
Unicode word boundaries on non-ASCII text and resolve the positions of
capturing groups.</p>
<p>Note that a <a href="../../hybrid/regex/struct.Regex.html"><code>hybrid::regex::Regex</code></a> strikes a
good balance between an NFA and a DFA. It avoids the exponential build time
of a DFA while maintaining its fast search time. The downside of a hybrid
NFA/DFA is that in some cases it can be slower at search time than the NFA.
(It also has less functionality than a pure NFA. It cannot handle Unicode
word boundaries on non-ASCII text and cannot resolve capturing groups.)</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This shows how to build an NFA with the default configuration and execute a
search using the Pike VM.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">8</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;foo12345&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
<h2 id="example-resolving-capturing-groups"><a href="#example-resolving-capturing-groups">Example: resolving capturing groups</a></h2>
<p>This example shows how to parse some simple dates and extract the
components of each date via capturing groups.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    util::captures::Captures,
};

<span class="kw">let </span>vm = PikeVM::new(<span class="string">r&quot;(?P&lt;y&gt;\d{4})-(?P&lt;m&gt;\d{2})-(?P&lt;d&gt;\d{2})&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = vm.create_cache();

<span class="kw">let </span>haystack = <span class="string">&quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;</span>;
<span class="kw">let </span>all: Vec&lt;Captures&gt; = vm.captures_iter(
    <span class="kw-2">&amp;mut </span>cache, haystack.as_bytes()
).collect();
<span class="comment">// There should be a total of 3 matches.
</span><span class="macro">assert_eq!</span>(<span class="number">3</span>, all.len());
<span class="comment">// The year from the second match is &#39;2013&#39;.
</span><span class="kw">let </span>span = all[<span class="number">1</span>].get_group_by_name(<span class="string">&quot;y&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">&quot;2013&quot;</span>, <span class="kw-2">&amp;</span>haystack[span]);
</code></pre></div>
<p>This example shows that only the last match of a capturing group is
reported, even if it had to match multiple times for an overall match
to occur.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Span};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;([a-z]){4}&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();

<span class="kw">let </span>haystack = <span class="string">b&quot;quux&quot;</span>;
re.captures(<span class="kw-2">&amp;mut </span>cache, haystack, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert!</span>(caps.is_match());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Span::from(<span class="number">3</span>..<span class="number">4</span>)), caps.get_group(<span class="number">1</span>));
</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-NFA" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#204-1178">source</a><a href="#impl-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#226-228">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expression using a default configuration and
build an NFA from it.</p>
<p>If you want a non-default configuration, then use the NFA
<a href="struct.Compiler.html" title="Compiler"><code>Compiler</code></a> with a <a href="struct.Config.html" title="Config"><code>Config</code></a>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">8</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;foo12345&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_many" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#251-253">source</a><h4 class="code-header">pub fn <a href="#method.new_many" class="fnname">new_many</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;&gt;(patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[P]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expressions using a default configuration and
build a multi-NFA from them.</p>
<p>If you want a non-default configuration, then use the NFA
<a href="struct.Compiler.html" title="Compiler"><code>Compiler</code></a> with a <a href="struct.Config.html" title="Config"><code>Config</code></a>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match};

<span class="kw">let </span>re = PikeVM::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">0</span>..<span class="number">3</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;foo12345bar&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.always_match" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#274-297">source</a><h4 class="code-header">pub fn <a href="#method.always_match" class="fnname">always_match</a>() -&gt; <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h4></section></summary><div class="docblock"><p>Returns an NFA with a single regex pattern that always matches at every
position.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};

<span class="kw">let </span>re = PikeVM::new_from_nfa(NFA::always_match())<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;foo&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.never_match" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#318-324">source</a><h4 class="code-header">pub fn <a href="#method.never_match" class="fnname">never_match</a>() -&gt; <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h4></section></summary><div class="docblock"><p>Returns an NFA that never matches at any position.</p>
<p>This is a convenience routine for creating an NFA with zero patterns.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::{NFA, pikevm::PikeVM};

<span class="kw">let </span>re = PikeVM::new_from_nfa(NFA::never_match())<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert!</span>(!caps.is_match());
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;foo&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert!</span>(!caps.is_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.config" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#347-349">source</a><h4 class="code-header">pub fn <a href="#method.config" class="fnname">config</a>() -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::Config">Config</a></h4></section></summary><div class="docblock"><p>Return a default configuration for an <code>NFA</code>.</p>
<p>This is a convenience routine to avoid needing to import the <code>Config</code>
type when customizing the construction of an NFA.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>This example shows how to build an NFA with a small size limit that
results in a compilation error for any regex that tries to use more
heap memory than the configured limit.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::{NFA, pikevm::PikeVM};

<span class="kw">let </span>result = PikeVM::builder()
    .thompson(NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>)))
    <span class="comment">// Remember, \w is Unicode-aware by default and thus huge.
    </span>.build(<span class="string">r&quot;\w+&quot;</span>);
<span class="macro">assert!</span>(result.is_err());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.compiler" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#381-383">source</a><h4 class="code-header">pub fn <a href="#method.compiler" class="fnname">compiler</a>() -&gt; <a class="struct" href="struct.Compiler.html" title="struct regex_automata::nfa::thompson::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Return a compiler for configuring the construction of an <code>NFA</code>.</p>
<p>This is a convenience routine to avoid needing to import the
<a href="struct.Compiler.html" title="Compiler"><code>Compiler</code></a> type in common cases.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to build an NFA that is permitted match invalid
UTF-8. Without the additional syntax configuration here, compilation of
<code>(?-u:.)</code> would fail because it is permitted to match invalid UTF-8.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    util::syntax,
    Match,
};

<span class="kw">let </span>re = PikeVM::builder()
    .syntax(syntax::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r&quot;[a-z]+(?-u:.)&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">5</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;\xFFabc\xFF&quot;</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.patterns" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#406-411">source</a><h4 class="code-header">pub fn <a href="#method.patterns" class="fnname">patterns</a>(&amp;self) -&gt; <a class="struct" href="struct.PatternIter.html" title="struct regex_automata::nfa::thompson::PatternIter">PatternIter</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.PatternIter.html" title="struct regex_automata::nfa::thompson::PatternIter">PatternIter</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.PatternIter.html" title="struct regex_automata::nfa::thompson::PatternIter">PatternIter</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all pattern identifiers in this NFA.</p>
<p>Pattern IDs are allocated in sequential order starting from zero,
where the order corresponds to the order of patterns provided to the
<a href="struct.NFA.html#method.new_many" title="NFA::new_many"><code>NFA::new_many</code></a> constructor.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[A-Z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>pids: Vec&lt;PatternID&gt; = nfa.patterns().collect();
<span class="macro">assert_eq!</span>(pids, <span class="macro">vec!</span>[
    PatternID::must(<span class="number">0</span>),
    PatternID::must(<span class="number">1</span>),
    PatternID::must(<span class="number">2</span>),
]);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pattern_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#440-442">source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fnname">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of regex patterns in this NFA.</p>
<p>This may return zero if the NFA was constructed with no patterns. In
this case, the NFA can never produce a match for any input.</p>
<p>This is guaranteed to be no bigger than <a href="../../struct.PatternID.html#associatedconstant.LIMIT" title="PatternID::LIMIT"><code>PatternID::LIMIT</code></a> because
NFA construction will fail if too many patterns are added.</p>
<p>It is always true that <code>nfa.patterns().count() == nfa.pattern_len()</code>.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[A-Z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">3</span>, nfa.pattern_len());

<span class="kw">let </span>nfa = NFA::never_match();
<span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.pattern_len());

<span class="kw">let </span>nfa = NFA::always_match();
<span class="macro">assert_eq!</span>(<span class="number">1</span>, nfa.pattern_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.start_anchored" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#473-475">source</a><h4 class="code-header">pub fn <a href="#method.start_anchored" class="fnname">start_anchored</a>(&amp;self) -&gt; <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></h4></section></summary><div class="docblock"><p>Return the state identifier of the initial anchored state of this NFA.</p>
<p>The returned identifier is guaranteed to be a valid index into the
slice returned by <a href="struct.NFA.html#method.states" title="NFA::states"><code>NFA::states</code></a>, and is also a valid argument to
<a href="struct.NFA.html#method.state" title="NFA::state"><code>NFA::state</code></a>.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<p>This example shows a somewhat contrived example where we can easily
predict the anchored starting state.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::{NFA, State, WhichCaptures};

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>state = nfa.state(nfa.start_anchored());
<span class="kw">match </span><span class="kw-2">*</span>state {
    State::ByteRange { trans } =&gt; {
        <span class="macro">assert_eq!</span>(<span class="string">b&#39;a&#39;</span>, trans.start);
        <span class="macro">assert_eq!</span>(<span class="string">b&#39;a&#39;</span>, trans.end);
    }
    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;unexpected state&quot;</span>),
}
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.start_unanchored" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#501-503">source</a><h4 class="code-header">pub fn <a href="#method.start_unanchored" class="fnname">start_unanchored</a>(&amp;self) -&gt; <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></h4></section></summary><div class="docblock"><p>Return the state identifier of the initial unanchored state of this
NFA.</p>
<p>This is equivalent to the identifier returned by
<a href="struct.NFA.html#method.start_anchored" title="NFA::start_anchored"><code>NFA::start_anchored</code></a> when the NFA has no unanchored starting state.</p>
<p>The returned identifier is guaranteed to be a valid index into the
slice returned by <a href="struct.NFA.html#method.states" title="NFA::states"><code>NFA::states</code></a>, and is also a valid argument to
<a href="struct.NFA.html#method.state" title="NFA::state"><code>NFA::state</code></a>.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<p>This example shows that the anchored and unanchored starting states
are equivalent when an anchored NFA is built.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;^a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(nfa.start_anchored(), nfa.start_unanchored());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.start_pattern" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#545-547">source</a><h4 class="code-header">pub fn <a href="#method.start_pattern" class="fnname">start_pattern</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</h4></section></summary><div class="docblock"><p>Return the state identifier of the initial anchored state for the given
pattern, or <code>None</code> if there is no pattern corresponding to the given
identifier.</p>
<p>If one uses the starting state for a particular pattern, then the only
match that can be returned is for the corresponding pattern.</p>
<p>The returned identifier is guaranteed to be a valid index into the
slice returned by <a href="struct.NFA.html#method.states" title="NFA::states"><code>NFA::states</code></a>, and is also a valid argument to
<a href="struct.NFA.html#method.state" title="NFA::state"><code>NFA::state</code></a>.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>If the pattern doesn’t exist in this NFA, then this returns an error.
This occurs when <code>pid.as_usize() &gt;= nfa.pattern_len()</code>.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>This example shows that the anchored and unanchored starting states
are equivalent when an anchored NFA is built.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;^a&quot;</span>, <span class="string">&quot;^b&quot;</span>])<span class="question-mark">?</span>;
<span class="comment">// The anchored and unanchored states for the entire NFA are the same,
// since all of the patterns are anchored.
</span><span class="macro">assert_eq!</span>(nfa.start_anchored(), nfa.start_unanchored());
<span class="comment">// But the anchored starting states for each pattern are distinct,
// because these starting states can only lead to matches for the
// corresponding pattern.
</span><span class="kw">let </span>anchored = <span class="prelude-val">Some</span>(nfa.start_anchored());
<span class="macro">assert_ne!</span>(anchored, nfa.start_pattern(PatternID::must(<span class="number">0</span>)));
<span class="macro">assert_ne!</span>(anchored, nfa.start_pattern(PatternID::must(<span class="number">1</span>)));
<span class="comment">// Requesting a pattern not in the NFA will result in None:
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, nfa.start_pattern(PatternID::must(<span class="number">2</span>)));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.byte_classes" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#598-600">source</a><h4 class="code-header">pub fn <a href="#method.byte_classes" class="fnname">byte_classes</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct regex_automata::util::alphabet::ByteClasses">ByteClasses</a></h4></section></summary><div class="docblock"><p>Get the byte classes for this NFA.</p>
<p>Byte classes represent a partitioning of this NFA’s alphabet into
equivalence classes. Any two bytes in the same equivalence class are
guaranteed to never discriminate between a match or a non-match. (The
partitioning may not be minimal.)</p>
<p>Byte classes are used internally by this crate when building DFAs.
Namely, among other optimizations, they enable a space optimization
where the DFA’s internal alphabet is defined over the equivalence
classes of bytes instead of all possible byte values. The former is
often quite a bit smaller than the latter, which permits the DFA to use
less space for its transition table.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<p>This example shows how to query the class of various bytes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;[a-z]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>classes = nfa.byte_classes();
<span class="comment">// &#39;a&#39; and &#39;z&#39; are in the same class for this regex.
</span><span class="macro">assert_eq!</span>(classes.get(<span class="string">b&#39;a&#39;</span>), classes.get(<span class="string">b&#39;z&#39;</span>));
<span class="comment">// But &#39;a&#39; and &#39;A&#39; are not.
</span><span class="macro">assert_ne!</span>(classes.get(<span class="string">b&#39;a&#39;</span>), classes.get(<span class="string">b&#39;A&#39;</span>));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.state" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#632-634">source</a><h4 class="code-header">pub fn <a href="#method.state" class="fnname">state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; &amp;<a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h4></section></summary><div class="docblock"><p>Return a reference to the NFA state corresponding to the given ID.</p>
<p>This is a convenience routine for <code>nfa.states()[id]</code>.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This panics when the given identifier does not reference a valid state.
That is, when <code>id.as_usize() &gt;= nfa.states().len()</code>.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<p>The anchored state for a pattern will typically correspond to a
capturing state for that pattern. (Although, this is not an API
guarantee!)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, State}, PatternID};

<span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>state = nfa.state(nfa.start_pattern(PatternID::ZERO).unwrap());
<span class="kw">match </span><span class="kw-2">*</span>state {
    State::Capture { slot, .. } =&gt; {
        <span class="macro">assert_eq!</span>(<span class="number">0</span>, slot.as_usize());
    }
    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;unexpected state&quot;</span>),
}
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.states" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#659-661">source</a><h4 class="code-header">pub fn <a href="#method.states" class="fnname">states</a>(&amp;self) -&gt; &amp;[<a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a>]</h4></section></summary><div class="docblock"><p>Returns a slice of all states in this NFA.</p>
<p>The slice returned is indexed by <code>StateID</code>. This provides a convenient
way to access states while following transitions among those states.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<p>This demonstrates that disabling UTF-8 mode can shrink the size of the
NFA considerably in some cases, especially when using Unicode character
classes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa_unicode = NFA::new(<span class="string">r&quot;\w&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>nfa_ascii = NFA::new(<span class="string">r&quot;(?-u)\w&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Yes, a factor of 45 difference. No lie.
</span><span class="macro">assert!</span>(<span class="number">40 </span>* nfa_ascii.states().len() &lt; nfa_unicode.states().len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.group_info" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#696-698">source</a><h4 class="code-header">pub fn <a href="#method.group_info" class="fnname">group_info</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/captures/struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h4></section></summary><div class="docblock"><p>Returns the capturing group info for this NFA.</p>
<p>The <a href="../../util/captures/struct.GroupInfo.html" title="GroupInfo"><code>GroupInfo</code></a> provides a way to map to and from capture index
and capture name for each pattern. It also provides a mapping from
each of the capturing groups in every pattern to their corresponding
slot offsets encoded in <a href="enum.State.html#variant.Capture" title="State::Capture"><code>State::Capture</code></a> states.</p>
<p>Note that <code>GroupInfo</code> uses reference counting internally, such that
cloning a <code>GroupInfo</code> is very cheap.</p>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<p>This example shows how to get a list of all capture group names for
a particular pattern.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;(a)(?P&lt;foo&gt;b)(c)(d)(?P&lt;bar&gt;e)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// The first is the implicit group that is always unnammed. The next
// 5 groups are the explicit groups found in the concrete syntax above.
</span><span class="kw">let </span>expected = <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>)];
<span class="kw">let </span>got: Vec&lt;<span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>str&gt;&gt; =
    nfa.group_info().pattern_names(PatternID::ZERO).collect();
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// Using an invalid pattern ID will result in nothing yielded.
</span><span class="kw">let </span>got = nfa.group_info().pattern_names(PatternID::must(<span class="number">999</span>)).count();
<span class="macro">assert_eq!</span>(<span class="number">0</span>, got);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.has_capture" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#743-745">source</a><h4 class="code-header">pub fn <a href="#method.has_capture" class="fnname">has_capture</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this NFA has at least one
<a href="enum.State.html#variant.Capture"><code>Capture</code></a> in its sequence of states.</p>
<p>This is useful as a way to perform a quick test before attempting
something that does or does not require capture states. For example,
some regex engines (like the PikeVM) require capture states in order to
work at all.</p>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<p>This example shows a few different NFAs and whether they have captures
or not.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::{NFA, WhichCaptures};

<span class="comment">// Obviously has capture states.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_capture());

<span class="comment">// Less obviously has capture states, because every pattern has at
// least one anonymous capture group corresponding to the match for the
// entire pattern.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_capture());

<span class="comment">// Other than hand building your own NFA, this is the only way to build
// an NFA without capturing groups. In general, you should only do this
// if you don&#39;t intend to use any of the NFA-oriented regex engines.
// Overall, capturing groups don&#39;t have many downsides. Although they
// can add a bit of noise to simple NFAs, so it can be nice to disable
// them for debugging purposes.
//
// Notice that &#39;has_capture&#39; is false here even when we have an
// explicit capture group in the pattern.
</span><span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.has_capture());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.has_empty" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#818-820">source</a><h4 class="code-header">pub fn <a href="#method.has_empty" class="fnname">has_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this NFA can match the empty string.
When it returns false, all possible matches are guaranteed to have a
non-zero length.</p>
<p>This is useful as cheap way to know whether code needs to handle the
case of a zero length match. This is particularly important when UTF-8
modes are enabled, as when UTF-8 mode is enabled, empty matches that
split a codepoint must never be reported. This extra handling can
sometimes be costly, and since regexes matching an empty string are
somewhat rare, it can be beneficial to treat such regexes specially.</p>
<h5 id="example-17"><a href="#example-17">Example</a></h5>
<p>This example shows a few different NFAs and whether they match the
empty string or not. Notice the empty string isn’t merely a matter
of a string of length literally <code>0</code>, but rather, whether a match can
occur between specific pairs of bytes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, util::syntax};

<span class="comment">// The empty regex matches the empty string.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;empty matches empty&quot;</span>);
<span class="comment">// The &#39;+&#39; repetition operator requires at least one match, and so
// does not match the empty string.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.has_empty(), <span class="string">&quot;+ does not match empty&quot;</span>);
<span class="comment">// But the &#39;*&#39; repetition operator does.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a*&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;* does match empty&quot;</span>);
<span class="comment">// And wrapping &#39;+&#39; in an operator that can match an empty string also
// causes it to match the empty string too.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;(a+)*&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;+ inside of * matches empty&quot;</span>);

<span class="comment">// If a regex is just made of a look-around assertion, even if the
// assertion requires some kind of non-empty string around it (such as
// \b), then it is still treated as if it matches the empty string.
// Namely, if a match occurs of just a look-around assertion, then the
// match returned is empty.
</span><span class="kw">let </span>nfa = NFA::compiler()
    .syntax(syntax::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r&quot;^$\A\z\b\B(?-u:\b\B)&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;assertions match empty&quot;</span>);
<span class="comment">// Even when an assertion is wrapped in a &#39;+&#39;, it still matches the
// empty string.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;\b+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;+ of an assertion matches empty&quot;</span>);

<span class="comment">// An alternation with even one branch that can match the empty string
// is also said to match the empty string overall.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;foo|(bar)?|quux&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;alternations can match empty&quot;</span>);

<span class="comment">// An NFA that matches nothing does not match the empty string.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;[a&amp;&amp;b]&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.has_empty(), <span class="string">&quot;never matching means not matching empty&quot;</span>);
<span class="comment">// But if it&#39;s wrapped in something that doesn&#39;t require a match at
// all, then it can match the empty string!
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;[a&amp;&amp;b]*&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.has_empty(), <span class="string">&quot;* on never-match still matches empty&quot;</span>);
<span class="comment">// Since a &#39;+&#39; requires a match, using it on something that can never
// match will itself produce a regex that can never match anything,
// and thus does not match the empty string.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;[a&amp;&amp;b]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.has_empty(), <span class="string">&quot;+ on never-match still matches nothing&quot;</span>);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_utf8" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#882-884">source</a><h4 class="code-header">pub fn <a href="#method.is_utf8" class="fnname">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Whether UTF-8 mode is enabled for this NFA or not.</p>
<p>When UTF-8 mode is enabled, all matches reported by a regex engine
derived from this NFA are guaranteed to correspond to spans of valid
UTF-8. This includes zero-width matches. For example, the regex engine
must guarantee that the empty regex will not match at the positions
between code units in the UTF-8 encoding of a single codepoint.</p>
<p>See <a href="struct.Config.html#method.utf8" title="Config::utf8"><code>Config::utf8</code></a> for more information.</p>
<p>This is enabled by default.</p>
<h5 id="example-18"><a href="#example-18">Example</a></h5>
<p>This example shows how UTF-8 mode can impact the match spans that may
be reported in certain cases.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{<span class="self">self</span>, pikevm::PikeVM},
    Match, Input,
};

<span class="kw">let </span>re = PikeVM::new(<span class="string">&quot;&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());

<span class="comment">// UTF-8 mode is enabled by default.
</span><span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;☃&quot;</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>)), caps.get_match());

<span class="comment">// Even though an empty regex matches at 1..1, our next match is
// 3..3 because 1..1 and 2..2 split the snowman codepoint (which is
// three bytes long).
</span>input.set_start(<span class="number">1</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">3</span>)), caps.get_match());

<span class="comment">// But if we disable UTF-8, then we&#39;ll get matches at 1..1 and 2..2:
</span><span class="kw">let </span>re = PikeVM::builder()
    .thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">&quot;&quot;</span>)<span class="question-mark">?</span>;
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">1</span>)), caps.get_match());

input.set_start(<span class="number">2</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">2</span>..<span class="number">2</span>)), caps.get_match());

input.set_start(<span class="number">3</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">3</span>)), caps.get_match());

input.set_start(<span class="number">4</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_reverse" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#908-910">source</a><h4 class="code-header">pub fn <a href="#method.is_reverse" class="fnname">is_reverse</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true when this NFA is meant to be matched in reverse.</p>
<p>Generally speaking, when this is true, it means the NFA is supposed to
be used in conjunction with moving backwards through the haystack. That
is, from a higher memory address to a lower memory address.</p>
<p>It is often the case that lower level routines dealing with an NFA
don’t need to care about whether it is “meant” to be matched in reverse
or not. However, there are some specific cases where it matters. For
example, the implementation of CRLF-aware <code>^</code> and <code>$</code> line anchors
needs to know whether the search is in the forward or reverse
direction. In the forward direction, neither <code>^</code> nor <code>$</code> should match
when a <code>\r</code> has been seen previously and a <code>\n</code> is next. However, in
the reverse direction, neither <code>^</code> nor <code>$</code> should match when a <code>\n</code>
has been seen previously and a <code>\r</code> is next. This fundamentally changes
how the state machine is constructed, and thus needs to be altered
based on the direction of the search.</p>
<p>This is automatically set when using a <a href="struct.Compiler.html" title="Compiler"><code>Compiler</code></a> with a configuration
where <a href="struct.Config.html#method.reverse" title="Config::reverse"><code>Config::reverse</code></a> is enabled. If you’re building your own NFA
by hand via a <a href="struct.Builder.html" title="Builder"><code>Builder</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_always_start_anchored" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#964-966">source</a><h4 class="code-header">pub fn <a href="#method.is_always_start_anchored" class="fnname">is_always_start_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if all starting states for this NFA correspond
to the beginning of an anchored search.</p>
<p>Typically, an NFA will have both an anchored and an unanchored starting
state. Namely, because it tends to be useful to have both and the cost
of having an unanchored starting state is almost zero (for an NFA).
However, if all patterns in the NFA are themselves anchored, then even
the unanchored starting state will correspond to an anchored search
since the pattern doesn’t permit anything else.</p>
<h5 id="example-19"><a href="#example-19">Example</a></h5>
<p>This example shows a few different scenarios where this method’s
return value varies.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="comment">// The unanchored starting state permits matching this pattern anywhere
// in a haystack, instead of just at the beginning.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.is_always_start_anchored());

<span class="comment">// In this case, the pattern is itself anchored, so there is no way
// to run an unanchored search.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;^a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.is_always_start_anchored());

<span class="comment">// When multiline mode is enabled, &#39;^&#39; can match at the start of a line
// in addition to the start of a haystack, so an unanchored search is
// actually possible.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;(?m)^a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.is_always_start_anchored());

<span class="comment">// Weird cases also work. A pattern is only considered anchored if all
// matches may only occur at the start of a haystack.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;(^a)|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.is_always_start_anchored());

<span class="comment">// When multiple patterns are present, if they are all anchored, then
// the NFA is always anchored too.
</span><span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;^a&quot;</span>, <span class="string">&quot;^b&quot;</span>, <span class="string">&quot;^c&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.is_always_start_anchored());

<span class="comment">// But if one pattern is unanchored, then the NFA must permit an
// unanchored search.
</span><span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;^a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;^c&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert!</span>(!nfa.is_always_start_anchored());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_matcher" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1013-1015">source</a><h4 class="code-header">pub fn <a href="#method.look_matcher" class="fnname">look_matcher</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/look/struct.LookMatcher.html" title="struct regex_automata::util::look::LookMatcher">LookMatcher</a></h4></section></summary><div class="docblock"><p>Returns the look-around matcher associated with this NFA.</p>
<p>A look-around matcher determines how to match look-around assertions.
In particular, some assertions are configurable. For example, the
<code>(?m:^)</code> and <code>(?m:$)</code> assertions can have their line terminator changed
from the default of <code>\n</code> to any other byte.</p>
<p>If the NFA was built using a <a href="struct.Compiler.html" title="Compiler"><code>Compiler</code></a>, then this matcher
can be set via the <a href="struct.Config.html#method.look_matcher" title="Config::look_matcher"><code>Config::look_matcher</code></a> configuration
knob. Otherwise, if you’ve built an NFA by hand, it is set via
<a href="struct.Builder.html#method.set_look_matcher" title="Builder::set_look_matcher"><code>Builder::set_look_matcher</code></a>.</p>
<h5 id="example-20"><a href="#example-20">Example</a></h5>
<p>This shows how to change the line terminator for multi-line assertions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{<span class="self">self</span>, pikevm::PikeVM},
    util::look::LookMatcher,
    Match, Input,
};

<span class="kw">let </span><span class="kw-2">mut </span>lookm = LookMatcher::new();
lookm.set_line_terminator(<span class="string">b&#39;\x00&#39;</span>);

<span class="kw">let </span>re = PikeVM::builder()
    .thompson(thompson::Config::new().look_matcher(lookm))
    .build(<span class="string">r&quot;(?m)^[a-z]+$&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="comment">// Multi-line assertions now use NUL as a terminator.
</span><span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">4</span>)),
    re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;\x00abc\x00&quot;</span>),
);
<span class="comment">// ... and \n is no longer recognized as a terminator.
</span><span class="macro">assert_eq!</span>(
    <span class="prelude-val">None</span>,
    re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">b&quot;\nabc\n&quot;</span>),
);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_any" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1059-1061">source</a><h4 class="code-header">pub fn <a href="#method.look_set_any" class="fnname">look_set_any</a>(&amp;self) -&gt; <a class="struct" href="../../util/look/struct.LookSet.html" title="struct regex_automata::util::look::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns the union of all look-around assertions used throughout this
NFA. When the returned set is empty, it implies that the NFA has no
look-around assertions and thus zero conditional epsilon transitions.</p>
<p>This is useful in some cases enabling optimizations. It is not
unusual, for example, for optimizations to be of the form, “for any
regex with zero conditional epsilon transitions, do …” where “…”
is some kind of optimization.</p>
<p>This isn’t only helpful for optimizations either. Sometimes look-around
assertions are difficult to support. For example, many of the DFAs in
this crate don’t support Unicode word boundaries or handle them using
heuristics. Handling that correctly typically requires some kind of
cheap check of whether the NFA has a Unicode word boundary in the first
place.</p>
<h5 id="example-21"><a href="#example-21">Example</a></h5>
<p>This example shows how this routine varies based on the regex pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, util::look::Look};

<span class="comment">// No look-around at all.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.look_set_any().is_empty());

<span class="comment">// When multiple patterns are present, since this returns the union,
// it will include look-around assertions that only appear in one
// pattern.
</span><span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a^b&quot;</span>, <span class="string">&quot;c&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.look_set_any().contains(Look::Start));

<span class="comment">// Some groups of assertions have various shortcuts. For example:
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;(?-u:\b)&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.look_set_any().contains_word());
<span class="macro">assert!</span>(!nfa.look_set_any().contains_word_unicode());
<span class="macro">assert!</span>(nfa.look_set_any().contains_word_ascii());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_prefix_any" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1099-1101">source</a><h4 class="code-header">pub fn <a href="#method.look_set_prefix_any" class="fnname">look_set_prefix_any</a>(&amp;self) -&gt; <a class="struct" href="../../util/look/struct.LookSet.html" title="struct regex_automata::util::look::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns the union of all prefix look-around assertions for every
pattern in this NFA. When the returned set is empty, it implies none of
the patterns require moving through a conditional epsilon transition
before inspecting the first byte in the haystack.</p>
<p>This can be useful for determining what kinds of assertions need to be
satisfied at the beginning of a search. For example, typically DFAs
in this crate will build a distinct starting state for each possible
starting configuration that might result in look-around assertions
being satisfied differently. However, if the set returned here is
empty, then you know that the start state is invariant because there
are no conditional epsilon transitions to consider.</p>
<h5 id="example-22"><a href="#example-22">Example</a></h5>
<p>This example shows how this routine varies based on the regex pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, util::look::Look};

<span class="comment">// No look-around at all.
</span><span class="kw">let </span>nfa = NFA::new(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.look_set_prefix_any().is_empty());

<span class="comment">// When multiple patterns are present, since this returns the union,
// it will include look-around assertions that only appear in one
// pattern. But it will only include assertions that are in the prefix
// of a pattern. For example, this includes &#39;^&#39; but not &#39;$&#39; even though
// &#39;$&#39; does appear.
</span><span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;^ab$&quot;</span>, <span class="string">&quot;c&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert!</span>(nfa.look_set_prefix_any().contains(Look::Start));
<span class="macro">assert!</span>(!nfa.look_set_prefix_any().contains(Look::End));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.memory_usage" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1169-1177">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fnname">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the memory usage, in bytes, of this NFA.</p>
<p>This does <strong>not</strong> include the stack size used up by this NFA. To
compute that, use <code>std::mem::size_of::&lt;NFA&gt;()</code>.</p>
<h5 id="example-23"><a href="#example-23">Example</a></h5>
<p>This example shows that large Unicode character classes can use quite
a bit of memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa_unicode = NFA::new(<span class="string">r&quot;\w&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>nfa_ascii = NFA::new(<span class="string">r&quot;(?-u:\w)&quot;</span>)<span class="question-mark">?</span>;

<span class="macro">assert!</span>(<span class="number">10 </span>* nfa_ascii.memory_usage() &lt; nfa_unicode.memory_usage());
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#189">source</a><a href="#impl-Clone-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#189">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1180-1184">source</a><a href="#impl-Debug-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1181-1183">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-NFA" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section><section id="impl-Send-for-NFA" class="impl has-srclink"><a href="#impl-Send-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section><section id="impl-Sync-for-NFA" class="impl has-srclink"><a href="#impl-Sync-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section><section id="impl-Unpin-for-NFA" class="impl has-srclink"><a href="#impl-Unpin-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section><section id="impl-UnwindSafe-for-NFA" class="impl has-srclink"><a href="#impl-UnwindSafe-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#83">source</a><a href="#impl-ToOwned-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-NFA" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-NFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>