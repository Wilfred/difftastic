<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A state in an NFA."><title>State in regex_automata::nfa::thompson - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.9</span></h2></div><h2 class="location"><a href="#">State</a></h2><div class="sidebar-elems"><section><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.BinaryUnion">BinaryUnion</a></li><li><a href="#variant.ByteRange">ByteRange</a></li><li><a href="#variant.Capture">Capture</a></li><li><a href="#variant.Dense">Dense</a></li><li><a href="#variant.Fail">Fail</a></li><li><a href="#variant.Look">Look</a></li><li><a href="#variant.Match">Match</a></li><li><a href="#variant.Sparse">Sparse</a></li><li><a href="#variant.Union">Union</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.is_epsilon">is_epsilon</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-State">Clone</a></li><li><a href="#impl-Debug-for-State">Debug</a></li><li><a href="#impl-Eq-for-State">Eq</a></li><li><a href="#impl-PartialEq-for-State">PartialEq</a></li><li><a href="#impl-StructuralEq-for-State">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq-for-State">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-State">RefUnwindSafe</a></li><li><a href="#impl-Send-for-State">Send</a></li><li><a href="#impl-Sync-for-State">Sync</a></li><li><a href="#impl-Unpin-for-State">Unpin</a></li><li><a href="#impl-UnwindSafe-for-State">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../regex_automata/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Enum <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">thompson</a>::<wbr><a class="enum" href="#">State</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1512-1619">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub enum State {
    ByteRange {
        trans: <a class="struct" href="struct.Transition.html" title="struct regex_automata::nfa::thompson::Transition">Transition</a>,
    },
    Sparse(<a class="struct" href="struct.SparseTransitions.html" title="struct regex_automata::nfa::thompson::SparseTransitions">SparseTransitions</a>),
    Dense(<a class="struct" href="struct.DenseTransitions.html" title="struct regex_automata::nfa::thompson::DenseTransitions">DenseTransitions</a>),
    Look {
        look: <a class="enum" href="../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a>,
        next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    Union {
        alternates: <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>]&gt;,
    },
    BinaryUnion {
        alt1: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
        alt2: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    Capture {
        next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
        pattern_id: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>,
        group_index: <a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a>,
        slot: <a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a>,
    },
    Fail,
    Match {
        pattern_id: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>,
    },
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A state in an NFA.</p>
<p>In theory, it can help to conceptualize an <code>NFA</code> as a graph consisting of
<code>State</code>s. Each <code>State</code> contains its complete set of outgoing transitions.</p>
<p>In practice, it can help to conceptualize an <code>NFA</code> as a sequence of
instructions for a virtual machine. Each <code>State</code> says what to do and where
to go next.</p>
<p>Strictly speaking, the practical interpretation is the most correct one,
because of the <a href="enum.State.html#variant.Capture" title="variant regex_automata::nfa::thompson::State::Capture"><code>Capture</code></a> state. Namely, a <code>Capture</code>
state always forwards execution to another state unconditionally. Its only
purpose is to cause a side effect: the recording of the current input
position at a particular location in memory. In this sense, an <code>NFA</code>
has more power than a theoretical non-deterministic finite automaton.</p>
<p>For most uses of this crate, it is likely that one may never even need to
be aware of this type at all. The main use cases for looking at <code>State</code>s
directly are if you need to write your own search implementation or if you
need to do some kind of analysis on the NFA.</p>
</div></details><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.ByteRange" class="variant"><a href="#variant.ByteRange" class="anchor">§</a><h3 class="code-header">ByteRange</h3></section><div class="sub-variant" id="variant.ByteRange.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ByteRange.field.trans" class="section-header"><a href="#variant.ByteRange.field.trans" class="anchor field">§</a><code>trans: <a class="struct" href="struct.Transition.html" title="struct regex_automata::nfa::thompson::Transition">Transition</a></code></span><div class="docblock"><p>The transition from this state to the next.</p>
</div></div></div><div class="docblock"><p>A state with a single transition that can only be taken if the current
input symbol is in a particular range of bytes.</p>
</div><section id="variant.Sparse" class="variant"><a href="#variant.Sparse" class="anchor">§</a><h3 class="code-header">Sparse(<a class="struct" href="struct.SparseTransitions.html" title="struct regex_automata::nfa::thompson::SparseTransitions">SparseTransitions</a>)</h3></section><div class="docblock"><p>A state with possibly many transitions represented in a sparse fashion.
Transitions are non-overlapping and ordered lexicographically by input
range.</p>
<p>In practice, this is used for encoding UTF-8 automata. Its presence is
primarily an optimization that avoids many additional unconditional
epsilon transitions (via <a href="enum.State.html#variant.Union" title="variant regex_automata::nfa::thompson::State::Union"><code>Union</code></a> states), and thus
decreases the overhead of traversing the NFA. This can improve both
matching time and DFA construction time.</p>
</div><section id="variant.Dense" class="variant"><a href="#variant.Dense" class="anchor">§</a><h3 class="code-header">Dense(<a class="struct" href="struct.DenseTransitions.html" title="struct regex_automata::nfa::thompson::DenseTransitions">DenseTransitions</a>)</h3></section><div class="docblock"><p>A dense representation of a state with multiple transitions.</p>
</div><section id="variant.Look" class="variant"><a href="#variant.Look" class="anchor">§</a><h3 class="code-header">Look</h3></section><div class="sub-variant" id="variant.Look.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Look.field.look" class="section-header"><a href="#variant.Look.field.look" class="anchor field">§</a><code>look: <a class="enum" href="../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a></code></span><div class="docblock"><p>The look-around assertion that must be satisfied before moving
to <code>next</code>.</p>
</div></div><div class="sub-variant-field"><span id="variant.Look.field.next" class="section-header"><a href="#variant.Look.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>The state to transition to if the look-around assertion is
satisfied.</p>
</div></div></div><div class="docblock"><p>A conditional epsilon transition satisfied via some sort of
look-around. Look-around is limited to anchor and word boundary
assertions.</p>
<p>Look-around states are meant to be evaluated while performing epsilon
closure (computing the set of states reachable from a particular state
via only epsilon transitions). If the current position in the haystack
satisfies the look-around assertion, then you’re permitted to follow
that epsilon transition.</p>
</div><section id="variant.Union" class="variant"><a href="#variant.Union" class="anchor">§</a><h3 class="code-header">Union</h3></section><div class="sub-variant" id="variant.Union.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Union.field.alternates" class="section-header"><a href="#variant.Union.field.alternates" class="anchor field">§</a><code>alternates: <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>]&gt;</code></span><div class="docblock"><p>An ordered sequence of unconditional epsilon transitions to other
states. Transitions earlier in the sequence are preferred over
transitions later in the sequence.</p>
</div></div></div><div class="docblock"><p>An alternation such that there exists an epsilon transition to all
states in <code>alternates</code>, where matches found via earlier transitions
are preferred over later transitions.</p>
</div><section id="variant.BinaryUnion" class="variant"><a href="#variant.BinaryUnion" class="anchor">§</a><h3 class="code-header">BinaryUnion</h3></section><div class="sub-variant" id="variant.BinaryUnion.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.BinaryUnion.field.alt1" class="section-header"><a href="#variant.BinaryUnion.field.alt1" class="anchor field">§</a><code>alt1: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>An unconditional epsilon transition to another NFA state. This
is preferred over <code>alt2</code>.</p>
</div></div><div class="sub-variant-field"><span id="variant.BinaryUnion.field.alt2" class="section-header"><a href="#variant.BinaryUnion.field.alt2" class="anchor field">§</a><code>alt2: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>An unconditional epsilon transition to another NFA state. Matches
reported via this transition should only be reported if no matches
were found by following <code>alt1</code>.</p>
</div></div></div><div class="docblock"><p>An alternation such that there exists precisely two unconditional
epsilon transitions, where matches found via <code>alt1</code> are preferred over
matches found via <code>alt2</code>.</p>
<p>This state exists as a common special case of Union where there are
only two alternates. In this case, we don’t need any allocations to
represent the state. This saves a bit of memory and also saves an
additional memory access when traversing the NFA.</p>
</div><section id="variant.Capture" class="variant"><a href="#variant.Capture" class="anchor">§</a><h3 class="code-header">Capture</h3></section><div class="sub-variant" id="variant.Capture.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Capture.field.next" class="section-header"><a href="#variant.Capture.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>The state to transition to, unconditionally.</p>
</div></div><div class="sub-variant-field"><span id="variant.Capture.field.pattern_id" class="section-header"><a href="#variant.Capture.field.pattern_id" class="anchor field">§</a><code>pattern_id: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></code></span><div class="docblock"><p>The pattern ID that this capture belongs to.</p>
</div></div><div class="sub-variant-field"><span id="variant.Capture.field.group_index" class="section-header"><a href="#variant.Capture.field.group_index" class="anchor field">§</a><code>group_index: <a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a></code></span><div class="docblock"><p>The capture group index that this capture belongs to. Capture group
indices are local to each pattern. For example, when capturing
groups are enabled, every pattern has a capture group at index
<code>0</code>.</p>
</div></div><div class="sub-variant-field"><span id="variant.Capture.field.slot" class="section-header"><a href="#variant.Capture.field.slot" class="anchor field">§</a><code>slot: <a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a></code></span><div class="docblock"><p>The slot index for this capture. Every capturing group has two
slots: one for the start haystack offset and one for the end
haystack offset. Unlike capture group indices, slot indices are
global across all patterns in this NFA. That is, each slot belongs
to a single pattern, but there is only one slot at index <code>i</code>.</p>
</div></div></div><div class="docblock"><p>An empty state that records a capture location.</p>
<p>From the perspective of finite automata, this is precisely equivalent
to an unconditional epsilon transition, but serves the purpose of
instructing NFA simulations to record additional state when the finite
state machine passes through this epsilon transition.</p>
<p><code>slot</code> in this context refers to the specific capture group slot
offset that is being recorded. Each capturing group has two slots
corresponding to the start and end of the matching portion of that
group.</p>
<p>The pattern ID and capture group index are also included in this state
in case they are useful. But mostly, all you’ll need is <code>next</code> and
<code>slot</code>.</p>
</div><section id="variant.Fail" class="variant"><a href="#variant.Fail" class="anchor">§</a><h3 class="code-header">Fail</h3></section><div class="docblock"><p>A state that cannot be transitioned out of. This is useful for cases
where you want to prevent matching from occurring. For example, if your
regex parser permits empty character classes, then one could choose
a <code>Fail</code> state to represent them. (An empty character class can be
thought of as an empty set. Since nothing is in an empty set, they can
never match anything.)</p>
</div><section id="variant.Match" class="variant"><a href="#variant.Match" class="anchor">§</a><h3 class="code-header">Match</h3></section><div class="sub-variant" id="variant.Match.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Match.field.pattern_id" class="section-header"><a href="#variant.Match.field.pattern_id" class="anchor field">§</a><code>pattern_id: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></code></span><div class="docblock"><p>The matching pattern ID.</p>
</div></div></div><div class="docblock"><p>A match state. There is at least one such occurrence of this state for
each regex that can match that is in this NFA.</p>
</div></div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1621-1724">source</a><a href="#impl-State" class="anchor">§</a><h3 class="code-header">impl <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_epsilon" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1655-1667">source</a><h4 class="code-header">pub fn <a href="#method.is_epsilon" class="fn">is_epsilon</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this state contains one or more epsilon
transitions.</p>
<p>In practice, a state has no outgoing transitions (like <code>Match</code>), has
only non-epsilon transitions (like <code>ByteRange</code>) or has only epsilon
transitions (like <code>Union</code>).</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{State, Transition},
    util::primitives::{PatternID, StateID, SmallIndex},
};

<span class="comment">// Capture states are epsilon transitions.
</span><span class="kw">let </span>state = State::Capture {
    next: StateID::ZERO,
    pattern_id: PatternID::ZERO,
    group_index: SmallIndex::ZERO,
    slot: SmallIndex::ZERO,
};
<span class="macro">assert!</span>(state.is_epsilon());

<span class="comment">// ByteRange states are not.
</span><span class="kw">let </span>state = State::ByteRange {
    trans: Transition { start: <span class="string">b'a'</span>, end: <span class="string">b'z'</span>, next: StateID::ZERO },
};
<span class="macro">assert!</span>(!state.is_epsilon());
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#impl-Clone-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.76.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1726-1783">source</a><a href="#impl-Debug-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1727-1782">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.76.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#impl-PartialEq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.76.0/src/core/cmp.rs.html#242">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#impl-Eq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-StructuralEq-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#impl-StructuralEq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-StructuralPartialEq-for-State" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/nfa.rs.html#1511">source</a><a href="#impl-StructuralPartialEq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-State" class="impl"><a href="#impl-RefUnwindSafe-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-Send-for-State" class="impl"><a href="#impl-Send-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-Sync-for-State" class="impl"><a href="#impl-Sync-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-Unpin-for-State" class="impl"><a href="#impl-Unpin-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section><section id="impl-UnwindSafe-for-State" class="impl"><a href="#impl-UnwindSafe-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::State">State</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>