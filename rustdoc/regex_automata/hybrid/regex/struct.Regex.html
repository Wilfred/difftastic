<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A regular expression that uses hybrid NFA/DFAs (also called “lazy DFAs”) for searching."><meta name="keywords" content="rust, rustlang, rust-lang, Regex"><title>Regex in regex_automata::hybrid::regex - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Regex</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.builder">builder</a></li><li><a href="#method.create_cache">create_cache</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.forward">forward</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_many">new_many</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.reset_cache">reset_cache</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.try_search">try_search</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Debug-for-Regex">Debug</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-Regex">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Regex">Send</a></li><li><a href="#impl-Sync-for-Regex">Sync</a></li><li><a href="#impl-Unpin-for-Regex">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Regex">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-Regex">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Regex">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Regex">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Regex">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Regex">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Regex">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Regex">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_automata::hybrid::regex</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">hybrid</a>::<wbr><a href="index.html">regex</a>::<wbr><a class="struct" href="#">Regex</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/hybrid/regex.rs.html#82-96">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Regex { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A regular expression that uses hybrid NFA/DFAs (also called “lazy DFAs”)
for searching.</p>
<p>A regular expression is comprised of two lazy DFAs, a “forward” DFA and a
“reverse” DFA. The forward DFA is responsible for detecting the end of
a match while the reverse DFA is responsible for detecting the start
of a match. Thus, in order to find the bounds of any given match, a
forward search must first be run followed by a reverse search. A match
found by the forward DFA guarantees that the reverse DFA will also find
a match.</p>
<h2 id="fallibility"><a href="#fallibility">Fallibility</a></h2>
<p>Most of the search routines defined on this type will <em>panic</em> when the
underlying search fails. This might be because the DFA gave up because it
saw a quit byte, whether configured explicitly or via heuristic Unicode
word boundary support, although neither are enabled by default. It might
also fail if the underlying DFA determines it isn’t making effective use of
the cache (which also never happens by default). Or it might fail because
an invalid <code>Input</code> configuration is given, for example, with an unsupported
<a href="../../enum.Anchored.html" title="Anchored"><code>Anchored</code></a> mode.</p>
<p>If you need to handle these error cases instead of allowing them to trigger
a panic, then the lower level <a href="struct.Regex.html#method.try_search" title="Regex::try_search"><code>Regex::try_search</code></a> provides a fallible API
that never panics.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This example shows how to cause a search to terminate if it sees a
<code>\n</code> byte, and handle the error returned. This could be useful if, for
example, you wanted to prevent a user supplied pattern from matching
across a line boundary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{hybrid::{dfa, regex::Regex}, Input, MatchError};

<span class="kw">let </span>re = Regex::builder()
    .dfa(dfa::Config::new().quit(<span class="string">b&#39;\n&#39;</span>, <span class="bool-val">true</span>))
    .build(<span class="string">r&quot;foo\p{any}+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foo\nbar&quot;</span>);
<span class="comment">// Normally this would produce a match, since \p{any} contains &#39;\n&#39;.
// But since we instructed the automaton to enter a quit state if a
// &#39;\n&#39; is observed, this produces a match error instead.
</span><span class="kw">let </span>expected = MatchError::quit(<span class="string">b&#39;\n&#39;</span>, <span class="number">3</span>);
<span class="kw">let </span>got = re.try_search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input).unwrap_err();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#99-240">source</a><a href="#impl-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Convenience routines for regex and cache construction.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#120-122">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::hybrid::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expression using the default configuration and
return the corresponding regex.</p>
<p>If you want a non-default configuration, then use the <a href="struct.Builder.html" title="Builder"><code>Builder</code></a> to
set your own configuration.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{hybrid::regex::Regex, Match};

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">14</span>)),
    re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;zzzfoo12345barzzz&quot;</span>),
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_many" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#146-150">source</a><h4 class="code-header">pub fn <a href="#method.new_many" class="fnname">new_many</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;&gt;(patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.slice.html">[P]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::hybrid::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Like <code>new</code>, but parses multiple patterns into a single “multi regex.”
This similarly uses the default regex configuration.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{hybrid::regex::Regex, Match};

<span class="kw">let </span>re = Regex::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[0-9]+&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;abc 1 foo 4567 0 quux&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">4</span>..<span class="number">5</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">6</span>..<span class="number">9</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">10</span>..<span class="number">14</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">15</span>..<span class="number">16</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">17</span>..<span class="number">21</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.builder" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#181-183">source</a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::hybrid::regex::Builder">Builder</a></h4></section></summary><div class="docblock"><p>Return a builder for configuring the construction of a <code>Regex</code>.</p>
<p>This is a convenience routine to avoid needing to import the
<a href="struct.Builder.html" title="Builder"><code>Builder</code></a> type in common cases.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows how to use the builder to disable UTF-8 mode
everywhere.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    hybrid::regex::Regex, nfa::thompson, util::syntax, Match,
};

<span class="kw">let </span>re = Regex::builder()
    .syntax(syntax::Config::new().utf8(<span class="bool-val">false</span>))
    .thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r&quot;foo(?-u:[^b])ar.*&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>haystack = <span class="string">b&quot;\xFEfoo\xFFarzz\xE2\x98\xFF\n&quot;</span>;
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">9</span>));
<span class="kw">let </span>got = re.find(<span class="kw-2">&amp;mut </span>cache, haystack);
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_cache" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#191-193">source</a><h4 class="code-header">pub fn <a href="#method.create_cache" class="fnname">create_cache</a>(&amp;self) -&gt; <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a></h4></section></summary><div class="docblock"><p>Create a new cache for this <code>Regex</code>.</p>
<p>The cache returned should only be used for searches for this
<code>Regex</code>. If you want to reuse the cache for another <code>Regex</code>, then
you must call <a href="struct.Cache.html#method.reset" title="Cache::reset"><code>Cache::reset</code></a> with that <code>Regex</code> (or, equivalently,
<a href="struct.Regex.html#method.reset_cache" title="Regex::reset_cache"><code>Regex::reset_cache</code></a>).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reset_cache" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#236-239">source</a><h4 class="code-header">pub fn <a href="#method.reset_cache" class="fnname">reset_cache</a>(&amp;self, cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a>)</h4></section></summary><div class="docblock"><p>Reset the given cache such that it can be used for searching with the
this <code>Regex</code> (and only this <code>Regex</code>).</p>
<p>A cache reset permits reusing memory already allocated in this cache
with a different <code>Regex</code>.</p>
<p>Resetting a cache sets its “clear count” to 0. This is relevant if the
<code>Regex</code> has been configured to “give up” after it has cleared the cache
a certain number of times.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>This shows how to re-purpose a cache for use with a different <code>Regex</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{hybrid::regex::Regex, Match};

<span class="kw">let </span>re1 = Regex::new(<span class="string">r&quot;\w&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>re2 = Regex::new(<span class="string">r&quot;\W&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>cache = re1.create_cache();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">2</span>)),
    re1.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;Δ&quot;</span>),
);

<span class="comment">// Using &#39;cache&#39; with re2 is not allowed. It may result in panics or
// incorrect results. In order to re-purpose the cache, we must reset
// it with the Regex we&#39;d like to use it with.
//
// Similarly, after this reset, using the cache with &#39;re1&#39; is also not
// allowed.
</span>re2.reset_cache(<span class="kw-2">&amp;mut </span>cache);
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)),
    re2.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;☃&quot;</span>),
);
</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex-1" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#243-407">source</a><a href="#impl-Regex-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Standard infallible search routines for finding and iterating over matches.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#285-296">source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fnname">is_match</a>&lt;'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This routine panics if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the lazy DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the lazy DFA quitting.</li>
<li>The configuration of the lazy DFA may also permit it to “give up”
on a search if it makes ineffective use of its transition table
cache. The default configuration does not enable this by default,
although it is typically a good idea to.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search panics, callers cannot know whether a match exists or
not.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="Regex::try_search"><code>Regex::try_search</code></a> if you want to handle these error conditions.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::hybrid::regex::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="macro">assert!</span>(re.is_match(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;foo12345bar&quot;</span>));
<span class="macro">assert!</span>(!re.is_match(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#344-350">source</a><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>&lt;'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This routine panics if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the lazy DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the lazy DFA quitting.</li>
<li>The configuration of the lazy DFA may also permit it to “give up”
on a search if it makes ineffective use of its transition table
cache. The default configuration does not enable this by default,
although it is typically a good idea to.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search panics, callers cannot know whether a match exists or
not.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="Regex::try_search"><code>Regex::try_search</code></a> if you want to handle these error conditions.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, hybrid::regex::Regex};

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">11</span>)),
    re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;zzzfoo12345zzz&quot;</span>),
);

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the default leftmost-first match semantics demand that we find the
// earliest match that prefers earlier parts of the pattern over latter
// parts.
</span><span class="kw">let </span>re = Regex::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), re.find(<span class="kw-2">&amp;mut </span>cache, <span class="string">&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_iter" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#399-406">source</a><h4 class="code-header">pub fn <a href="#method.find_iter" class="fnname">find_iter</a>&lt;'r, 'c, 'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'r self,<br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::hybrid::regex::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::hybrid::regex::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 'c, 'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::hybrid::regex::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../../struct.Match.html" title="struct regex_automata::Match">Match</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>This routine panics if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the lazy DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the lazy DFA quitting.</li>
<li>The configuration of the lazy DFA may also permit it to “give up”
on a search if it makes ineffective use of its transition table
cache. The default configuration does not enable this by default,
although it is typically a good idea to.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search panics, callers cannot know whether a match exists or
not.</p>
<p>The above conditions also apply to the iterator returned as well. For
example, if the lazy DFA gives up or quits during a search using this
method, then a panic will occur during iteration.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="Regex::try_search"><code>Regex::try_search</code></a> with <a href="../../util/iter/struct.Searcher.html"><code>util::iter::Searcher</code></a>
if you want to handle these error conditions.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{hybrid::regex::Regex, Match};

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();

<span class="kw">let </span>text = <span class="string">&quot;foo1 foo12 foo123&quot;</span>;
<span class="kw">let </span>matches: Vec&lt;Match&gt; = re.find_iter(<span class="kw-2">&amp;mut </span>cache, text).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[
    Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">4</span>),
    Match::must(<span class="number">0</span>, <span class="number">5</span>..<span class="number">10</span>),
    Match::must(<span class="number">0</span>, <span class="number">11</span>..<span class="number">17</span>),
]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex-2" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#411-517">source</a><a href="#impl-Regex-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Lower level “search” primitives that accept a <code>&amp;Input</code> for cheap reuse
and return an error if one occurs instead of panicking.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_search" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#442-505">source</a><h4 class="code-header">pub fn <a href="#method.try_search" class="fnname">try_search</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::regex::Cache">Cache</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<p>This is like <a href="struct.Regex.html#method.find" title="Regex::find"><code>Regex::find</code></a> but with two differences:</p>
<ol>
<li>It is not generic over <code>Into&lt;Input&gt;</code> and instead accepts a
<code>&amp;Input</code>. This permits reusing the same <code>Input</code> for multiple searches
without needing to create a new one. This <em>may</em> help with latency.</li>
<li>It returns an error if the search could not complete where as
<a href="struct.Regex.html#method.find" title="Regex::find"><code>Regex::find</code></a> will panic.</li>
</ol>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This routine errors if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the lazy DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the lazy DFA quitting.</li>
<li>The configuration of the lazy DFA may also permit it to “give up”
on a search if it makes ineffective use of its transition table
cache. The default configuration does not enable this by default,
although it is typically a good idea to.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search returns an error, callers cannot know whether a match
exists or not.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex-3" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#521-554">source</a><a href="#impl-Regex-3" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Non-search APIs for querying information about the regex and setting a
prefilter.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.forward" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#526-528">source</a><h4 class="code-header">pub fn <a href="#method.forward" class="fnname">forward</a>(&amp;self) -&gt; &amp;<a class="struct" href="../dfa/struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a></h4></section></summary><div class="docblock"><p>Return the underlying lazy DFA responsible for forward matching.</p>
<p>This is useful for accessing the underlying lazy DFA and using it
directly if the situation calls for it.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reverse" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#534-536">source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;self) -&gt; &amp;<a class="struct" href="../dfa/struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a></h4></section></summary><div class="docblock"><p>Return the underlying lazy DFA responsible for reverse matching.</p>
<p>This is useful for accessing the underlying lazy DFA and using it
directly if the situation calls for it.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pattern_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#550-553">source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fnname">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns matched by this regex.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::hybrid::regex::Regex;

<span class="kw">let </span>re = Regex::new_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;[a-z]+&quot;</span>, <span class="string">r&quot;[0-9]+&quot;</span>, <span class="string">r&quot;\w+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">3</span>, re.pattern_len());</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#81">source</a><a href="#impl-Debug-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/hybrid/regex.rs.html#81">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Regex" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section><section id="impl-Send-for-Regex" class="impl has-srclink"><a href="#impl-Send-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section><section id="impl-Sync-for-Regex" class="impl has-srclink"><a href="#impl-Sync-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section><section id="impl-Unpin-for-Regex" class="impl has-srclink"><a href="#impl-Unpin-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section><section id="impl-UnwindSafe-for-Regex" class="impl has-srclink"><a href="#impl-UnwindSafe-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::hybrid::regex::Regex">Regex</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Regex" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>