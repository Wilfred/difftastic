<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Represents information about capturing groups in a compiled regex."><meta name="keywords" content="rust, rustlang, rust-lang, GroupInfo"><title>GroupInfo in regex_automata::util::captures - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">GroupInfo</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.all_group_len">all_group_len</a></li><li><a href="#method.all_names">all_names</a></li><li><a href="#method.empty">empty</a></li><li><a href="#method.explicit_slot_len">explicit_slot_len</a></li><li><a href="#method.group_len">group_len</a></li><li><a href="#method.implicit_slot_len">implicit_slot_len</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.pattern_names">pattern_names</a></li><li><a href="#method.slot">slot</a></li><li><a href="#method.slot_len">slot_len</a></li><li><a href="#method.slots">slots</a></li><li><a href="#method.to_index">to_index</a></li><li><a href="#method.to_name">to_name</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone-for-GroupInfo">Clone</a></li><li><a href="#impl-Debug-for-GroupInfo">Debug</a></li><li><a href="#impl-Default-for-GroupInfo">Default</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-GroupInfo">RefUnwindSafe</a></li><li><a href="#impl-Send-for-GroupInfo">Send</a></li><li><a href="#impl-Sync-for-GroupInfo">Sync</a></li><li><a href="#impl-Unpin-for-GroupInfo">Unpin</a></li><li><a href="#impl-UnwindSafe-for-GroupInfo">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-GroupInfo">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-GroupInfo">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-GroupInfo">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-GroupInfo">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-GroupInfo">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-GroupInfo">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-GroupInfo">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-GroupInfo">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_automata::util::captures</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">util</a>::<wbr><a href="index.html">captures</a>::<wbr><a class="struct" href="#">GroupInfo</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/util/captures.rs.html#1450">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct GroupInfo(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Represents information about capturing groups in a compiled regex.</p>
<p>The information encapsulated by this type consists of the following. For
each pattern:</p>
<ul>
<li>A map from every capture group name to its corresponding capture group
index.</li>
<li>A map from every capture group index to its corresponding capture group
name.</li>
<li>A map from capture group index to its corresponding slot index. A slot
refers to one half of a capturing group. That is, a capture slot is either
the start or end of a capturing group. A slot is usually the mechanism
by which a regex engine records offsets for each capturing group during a
search.</li>
</ul>
<p>A <code>GroupInfo</code> uses reference counting internally and is thus cheap to
clone.</p>
<h2 id="mapping-from-capture-groups-to-slots"><a href="#mapping-from-capture-groups-to-slots">Mapping from capture groups to slots</a></h2>
<p>One of the main responsibilities of a <code>GroupInfo</code> is to build a mapping
from <code>(PatternID, u32)</code> (where the <code>u32</code> is a capture index) to something
called a “slot.” As mentioned above, a slot refers to one half of a
capturing group. Both combined provide the start and end offsets of
a capturing group that participated in a match.</p>
<p><strong>The mapping between group indices and slots is an API guarantee.</strong> That
is, the mapping won’t change within a semver compatible release.</p>
<p>Slots exist primarily because this is a convenient mechanism by which
regex engines report group offsets at search time. For example, the
<a href="../../nfa/thompson/enum.State.html#variant.Capture"><code>nfa::thompson::State::Capture</code></a>
NFA state includes the slot index. When a regex engine transitions through
this state, it will likely use the slot index to write the current haystack
offset to some region of memory. When a match is found, those slots are
then reported to the caller, typically via a convenient abstraction like a
<a href="struct.Captures.html" title="Captures"><code>Captures</code></a> value.</p>
<p>Because this crate provides first class support for multi-pattern regexes,
and because of some performance related reasons, the mapping between
capturing groups and slots is a little complex. However, in the case of a
single pattern, the mapping can be described very simply: for all capture
group indices <code>i</code>, its corresponding slots are at <code>i * 2</code> and <code>i * 2 + 1</code>.
Notice that the pattern ID isn’t involved at all here, because it only
applies to a single-pattern regex, it is therefore always <code>0</code>.</p>
<p>In the multi-pattern case, the mapping is a bit more complicated. To talk
about it, we must define what we mean by “implicit” vs “explicit”
capturing groups:</p>
<ul>
<li>An <strong>implicit</strong> capturing group refers to the capturing group that is
present for every pattern automatically, and corresponds to the overall
match of a pattern. Every pattern has precisely one implicit capturing
group. It is always unnamed and it always corresponds to the capture group
index <code>0</code>.</li>
<li>An <strong>explicit</strong> capturing group refers to any capturing group that
appears in the concrete syntax of the pattern. (Or, if an NFA was hand
built without any concrete syntax, it refers to any capturing group with an
index greater than <code>0</code>.)</li>
</ul>
<p>Some examples:</p>
<ul>
<li><code>\w+</code> has one implicit capturing group and zero explicit capturing
groups.</li>
<li><code>(\w+)</code> has one implicit group and one explicit group.</li>
<li><code>foo(\d+)(?:\pL+)(\d+)</code> has one implicit group and two explicit groups.</li>
</ul>
<p>Turning back to the slot mapping, we can now state it as follows:</p>
<ul>
<li>Given a pattern ID <code>pid</code>, the slots for its implicit group are always
at <code>pid * 2</code> and <code>pid * 2 + 1</code>.</li>
<li>Given a pattern ID <code>0</code>, the slots for its explicit groups start
at <code>group_info.pattern_len() * 2</code>.</li>
<li>Given a pattern ID <code>pid &gt; 0</code>, the slots for its explicit groups start
immediately following where the slots for the explicit groups of <code>pid - 1</code>
end.</li>
</ul>
<p>In particular, while there is a concrete formula one can use to determine
where the slots for the implicit group of any pattern are, there is no
general formula for determining where the slots for explicit capturing
groups are. This is because each pattern can contain a different number
of groups.</p>
<p>The intended way of getting the slots for a particular capturing group
(whether implicit or explicit) is via the <a href="struct.GroupInfo.html#method.slot" title="GroupInfo::slot"><code>GroupInfo::slot</code></a> or
<a href="struct.GroupInfo.html#method.slots" title="GroupInfo::slots"><code>GroupInfo::slots</code></a> method.</p>
<p>See below for a concrete example of how capturing groups get mapped to
slots.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This example shows how to build a new <code>GroupInfo</code> and query it for
information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::{captures::GroupInfo, primitives::PatternID};

<span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
])<span class="question-mark">?</span>;
<span class="comment">// The number of patterns being tracked.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, info.pattern_len());
<span class="comment">// We can query the number of groups for any pattern.
</span><span class="macro">assert_eq!</span>(<span class="number">2</span>, info.group_len(PatternID::must(<span class="number">0</span>)));
<span class="macro">assert_eq!</span>(<span class="number">1</span>, info.group_len(PatternID::must(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(<span class="number">5</span>, info.group_len(PatternID::must(<span class="number">2</span>)));
<span class="macro">assert_eq!</span>(<span class="number">3</span>, info.group_len(PatternID::must(<span class="number">3</span>)));
<span class="comment">// An invalid pattern always has zero groups.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, info.group_len(PatternID::must(<span class="number">999</span>)));
<span class="comment">// 2 slots per group
</span><span class="macro">assert_eq!</span>(<span class="number">22</span>, info.slot_len());

<span class="comment">// We can map a group index for a particular pattern to its name, if
// one exists.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), info.to_name(PatternID::must(<span class="number">3</span>), <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, info.to_name(PatternID::must(<span class="number">2</span>), <span class="number">4</span>));
<span class="comment">// Or map a name to its group index.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), info.to_index(PatternID::must(<span class="number">0</span>), <span class="string">&quot;foo&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), info.to_index(PatternID::must(<span class="number">3</span>), <span class="string">&quot;foo&quot;</span>));
</code></pre></div>
<h2 id="example-mapping-from-capture-groups-to-slots"><a href="#example-mapping-from-capture-groups-to-slots">Example: mapping from capture groups to slots</a></h2>
<p>This example shows the specific mapping from capture group indices for
each pattern to their corresponding slots. The slot values shown in this
example are considered an API guarantee.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::{captures::GroupInfo, primitives::PatternID};

<span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
])<span class="question-mark">?</span>;

<span class="comment">// We first show the slots for each pattern&#39;s implicit group.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="number">1</span>)), info.slots(PatternID::must(<span class="number">0</span>), <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="number">3</span>)), info.slots(PatternID::must(<span class="number">1</span>), <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="number">5</span>)), info.slots(PatternID::must(<span class="number">2</span>), <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="number">7</span>)), info.slots(PatternID::must(<span class="number">3</span>), <span class="number">0</span>));

<span class="comment">// And now we show the slots for each pattern&#39;s explicit group.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">8</span>, <span class="number">9</span>)), info.slots(PatternID::must(<span class="number">0</span>), <span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">10</span>, <span class="number">11</span>)), info.slots(PatternID::must(<span class="number">2</span>), <span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">12</span>, <span class="number">13</span>)), info.slots(PatternID::must(<span class="number">2</span>), <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">14</span>, <span class="number">15</span>)), info.slots(PatternID::must(<span class="number">2</span>), <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">16</span>, <span class="number">17</span>)), info.slots(PatternID::must(<span class="number">2</span>), <span class="number">4</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">18</span>, <span class="number">19</span>)), info.slots(PatternID::must(<span class="number">3</span>), <span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">20</span>, <span class="number">21</span>)), info.slots(PatternID::must(<span class="number">3</span>), <span class="number">2</span>));

<span class="comment">// Asking for the slots for an invalid pattern ID or even for an invalid
// group index for a specific pattern will return None. So for example,
// you&#39;re guaranteed to not get the slots for a different pattern than the
// one requested.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, info.slots(PatternID::must(<span class="number">5</span>), <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, info.slots(PatternID::must(<span class="number">1</span>), <span class="number">1</span>));
</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1452-2152">source</a><a href="#impl-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1568-1609">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>&lt;P, G, N&gt;(pattern_groups: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a>, <a class="struct" href="struct.GroupInfoError.html" title="struct regex_automata::util::captures::GroupInfoError">GroupInfoError</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = G&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;N&gt;&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;N: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Creates a new group info from a sequence of patterns, where each
sequence of patterns yields a sequence of possible group names. The
index of each pattern in the sequence corresponds to its <code>PatternID</code>,
and the index of each group in each pattern’s sequence corresponds to
its corresponding group index.</p>
<p>While this constructor is very generic and therefore perhaps hard to
chew on, an example of a valid concrete type that can be passed to
this constructor is <code>Vec&lt;Vec&lt;Option&lt;String&gt;&gt;&gt;</code>. The outer <code>Vec</code>
corresponds to the patterns, i.e., one <code>Vec&lt;Option&lt;String&gt;&gt;</code> per
pattern. The inner <code>Vec</code> corresponds to the capturing groups for
each pattern. The <code>Option&lt;String&gt;</code> corresponds to the name of the
capturing group, if present.</p>
<p>It is legal to pass an empty iterator to this constructor. It will
return an empty group info with zero slots. An empty group info is
useful for cases where you have no patterns or for cases where slots
aren’t being used at all (e.g., for most DFAs in this crate).</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This constructor returns an error if the given capturing groups are
invalid in some way. Those reasons include, but are not necessarily
limited to:</p>
<ul>
<li>Too many patterns (i.e., <code>PatternID</code> would overflow).</li>
<li>Too many capturing groups (e.g., <code>u32</code> would overflow).</li>
<li>A pattern is given that has no capturing groups. (All patterns must
have at least an implicit capturing group at index <code>0</code>.)</li>
<li>The capturing group at index <code>0</code> has a name. It must be unnamed.</li>
<li>There are duplicate capturing group names within the same pattern.
(Multiple capturing groups with the same name may exist, but they
must be in different patterns.)</li>
</ul>
<p>An example below shows how to trigger some of the above error
conditions.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This example shows how to build a new <code>GroupInfo</code> and query it for
information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
])<span class="question-mark">?</span>;
<span class="comment">// The number of patterns being tracked.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, info.pattern_len());
<span class="comment">// 2 slots per group
</span><span class="macro">assert_eq!</span>(<span class="number">22</span>, info.slot_len());
</code></pre></div>
<h5 id="example-empty-groupinfo"><a href="#example-empty-groupinfo">Example: empty <code>GroupInfo</code></a></h5>
<p>This example shows how to build a new <code>GroupInfo</code> and query it for
information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="kw">let </span>info = GroupInfo::empty();
<span class="comment">// Everything is zero.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, info.pattern_len());
<span class="macro">assert_eq!</span>(<span class="number">0</span>, info.slot_len());
</code></pre></div>
<h5 id="example-error-conditions"><a href="#example-error-conditions">Example: error conditions</a></h5>
<p>This example shows how to provoke some of the ways in which building
a <code>GroupInfo</code> can fail.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="comment">// Either the group info is empty, or all patterns must have at least
// one capturing group.
</span><span class="macro">assert!</span>(GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>)], <span class="comment">// ok
    </span><span class="macro">vec!</span>[<span class="prelude-val">None</span>], <span class="comment">// ok
    </span><span class="macro">vec!</span>[], <span class="comment">// not ok
</span>]).is_err());
<span class="comment">// Note that building an empty group info is OK.
</span><span class="macro">assert!</span>(GroupInfo::new(Vec::&lt;Vec&lt;<span class="prelude-ty">Option</span>&lt;String&gt;&gt;&gt;::new()).is_ok());

<span class="comment">// The first group in each pattern must correspond to an implicit
// anonymous group. i.e., One that is not named. By convention, this
// group corresponds to the overall match of a regex. Every other group
// in a pattern is explicit and optional.
</span><span class="macro">assert!</span>(GroupInfo::new(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)]]).is_err());

<span class="comment">// There must not be duplicate group names within the same pattern.
</span><span class="macro">assert!</span>(GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
]).is_err());
<span class="comment">// But duplicate names across distinct patterns is OK.
</span><span class="macro">assert!</span>(GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
]).is_ok());
</code></pre></div>
<p>There are other ways for building a <code>GroupInfo</code> to fail but are
difficult to show. For example, if the number of patterns given would
overflow <code>PatternID</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.empty" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1632-1635">source</a><h4 class="code-header">pub fn <a href="#method.empty" class="fnname">empty</a>() -&gt; <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h4></section></summary><div class="docblock"><p>This creates an empty <code>GroupInfo</code>.</p>
<p>This is a convenience routine for calling <code>GroupInfo::new</code> with an
iterator that yields no elements.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This example shows how to build a new empty <code>GroupInfo</code> and query it
for information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="kw">let </span>info = GroupInfo::empty();
<span class="comment">// Everything is zero.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, info.pattern_len());
<span class="macro">assert_eq!</span>(<span class="number">0</span>, info.all_group_len());
<span class="macro">assert_eq!</span>(<span class="number">0</span>, info.slot_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_index" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1681-1684">source</a><h4 class="code-header">pub fn <a href="#method.to_index" class="fnname">to_index</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Return the capture group index corresponding to the given name in the
given pattern. If no such capture group name exists in the given
pattern, then this returns <code>None</code>.</p>
<p>If the given pattern ID is invalid, then this returns <code>None</code>.</p>
<p>This also returns <code>None</code> for all inputs if these captures are empty
(e.g., built from an empty <a href="struct.GroupInfo.html" title="GroupInfo"><code>GroupInfo</code></a>). To check whether captures
are are present for a specific pattern, use <a href="struct.GroupInfo.html#method.group_len" title="GroupInfo::group_len"><code>GroupInfo::group_len</code></a>.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows how to find the capture index for the given pattern
and group name.</p>
<p>Remember that capture indices are relative to the pattern, such that
the same capture index value may refer to different capturing groups
for distinct patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>(pid0, pid1) = (PatternID::must(<span class="number">0</span>), PatternID::must(<span class="number">1</span>));

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[
    <span class="string">r&quot;a(?P&lt;quux&gt;\w+)z(?P&lt;foo&gt;\s+)&quot;</span>,
    <span class="string">r&quot;a(?P&lt;foo&gt;\d+)z&quot;</span>,
])<span class="question-mark">?</span>;
<span class="kw">let </span>groups = nfa.group_info();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), groups.to_index(pid0, <span class="string">&quot;foo&quot;</span>));
<span class="comment">// Recall that capture index 0 is always unnamed and refers to the
// entire pattern. So the first capturing group present in the pattern
// itself always starts at index 1.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), groups.to_index(pid1, <span class="string">&quot;foo&quot;</span>));

<span class="comment">// And if a name does not exist for a particular pattern, None is
// returned.
</span><span class="macro">assert!</span>(groups.to_index(pid0, <span class="string">&quot;quux&quot;</span>).is_some());
<span class="macro">assert!</span>(groups.to_index(pid1, <span class="string">&quot;quux&quot;</span>).is_none());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_name" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1729-1732">source</a><h4 class="code-header">pub fn <a href="#method.to_name" class="fnname">to_name</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, group_index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Return the capture name for the given index and given pattern. If the
corresponding group does not have a name, then this returns <code>None</code>.</p>
<p>If the pattern ID is invalid, then this returns <code>None</code>.</p>
<p>If the group index is invalid for the given pattern, then this returns
<code>None</code>. A group <code>index</code> is valid for a pattern <code>pid</code> in an <code>nfa</code> if and
only if <code>index &lt; nfa.pattern_capture_len(pid)</code>.</p>
<p>This also returns <code>None</code> for all inputs if these captures are empty
(e.g., built from an empty <a href="struct.GroupInfo.html" title="GroupInfo"><code>GroupInfo</code></a>). To check whether captures
are are present for a specific pattern, use <a href="struct.GroupInfo.html#method.group_len" title="GroupInfo::group_len"><code>GroupInfo::group_len</code></a>.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>This example shows how to find the capture group name for the given
pattern and group index.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>(pid0, pid1) = (PatternID::must(<span class="number">0</span>), PatternID::must(<span class="number">1</span>));

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[
    <span class="string">r&quot;a(?P&lt;foo&gt;\w+)z(\s+)x(\d+)&quot;</span>,
    <span class="string">r&quot;a(\d+)z(?P&lt;foo&gt;\s+)&quot;</span>,
])<span class="question-mark">?</span>;
<span class="kw">let </span>groups = nfa.group_info();
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid0, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), groups.to_name(pid0, <span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid0, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid0, <span class="number">3</span>));

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid1, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid1, <span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), groups.to_name(pid1, <span class="number">2</span>));
<span class="comment">// &#39;3&#39; is not a valid capture index for the second pattern.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, groups.to_name(pid1, <span class="number">3</span>));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pattern_names" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1767-1776">source</a><h4 class="code-header">pub fn <a href="#method.pattern_names" class="fnname">pattern_names</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>) -&gt; <a class="struct" href="struct.GroupInfoPatternNames.html" title="struct regex_automata::util::captures::GroupInfoPatternNames">GroupInfoPatternNames</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.GroupInfoPatternNames.html" title="struct regex_automata::util::captures::GroupInfoPatternNames">GroupInfoPatternNames</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.GroupInfoPatternNames.html" title="struct regex_automata::util::captures::GroupInfoPatternNames">GroupInfoPatternNames</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return an iterator of all capture groups and their names (if present)
for a particular pattern.</p>
<p>If the given pattern ID is invalid or if this <code>GroupInfo</code> is empty,
then the iterator yields no elements.</p>
<p>The number of elements yielded by this iterator is always equal to
the result of calling <a href="struct.GroupInfo.html#method.group_len" title="GroupInfo::group_len"><code>GroupInfo::group_len</code></a> with the same
<code>PatternID</code>.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>This example shows how to get a list of all capture group names for
a particular pattern.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;(a)(?P&lt;foo&gt;b)(c)(d)(?P&lt;bar&gt;e)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// The first is the implicit group that is always unnammed. The next
// 5 groups are the explicit groups found in the concrete syntax above.
</span><span class="kw">let </span>expected = <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>)];
<span class="kw">let </span>got: Vec&lt;<span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>str&gt;&gt; =
    nfa.group_info().pattern_names(PatternID::ZERO).collect();
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// Using an invalid pattern ID will result in nothing yielded.
</span><span class="kw">let </span>got = nfa.group_info().pattern_names(PatternID::must(<span class="number">999</span>)).count();
<span class="macro">assert_eq!</span>(<span class="number">0</span>, got);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all_names" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1828-1835">source</a><h4 class="code-header">pub fn <a href="#method.all_names" class="fnname">all_names</a>(&amp;self) -&gt; <a class="struct" href="struct.GroupInfoAllNames.html" title="struct regex_automata::util::captures::GroupInfoAllNames">GroupInfoAllNames</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.GroupInfoAllNames.html" title="struct regex_automata::util::captures::GroupInfoAllNames">GroupInfoAllNames</a>&lt;'a&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.GroupInfoAllNames.html" title="struct regex_automata::util::captures::GroupInfoAllNames">GroupInfoAllNames</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.65.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = (<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.str.html">str</a>&gt;);</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return an iterator of all capture groups for all patterns supported by
this <code>GroupInfo</code>. Each item yielded is a triple of the group’s pattern
ID, index in the pattern and the group’s name, if present.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to get a list of all capture groups found in
one NFA, potentially spanning multiple patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[
    <span class="string">r&quot;(?P&lt;foo&gt;a)&quot;</span>,
    <span class="string">r&quot;a&quot;</span>,
    <span class="string">r&quot;(a)&quot;</span>,
])<span class="question-mark">?</span>;
<span class="kw">let </span>expected = <span class="macro">vec!</span>[
    (PatternID::must(<span class="number">0</span>), <span class="number">0</span>, <span class="prelude-val">None</span>),
    (PatternID::must(<span class="number">0</span>), <span class="number">1</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)),
    (PatternID::must(<span class="number">1</span>), <span class="number">0</span>, <span class="prelude-val">None</span>),
    (PatternID::must(<span class="number">2</span>), <span class="number">0</span>, <span class="prelude-val">None</span>),
    (PatternID::must(<span class="number">2</span>), <span class="number">1</span>, <span class="prelude-val">None</span>),
];
<span class="kw">let </span>got: Vec&lt;(PatternID, usize, <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>str&gt;)&gt; =
    nfa.group_info().all_names().collect();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
<p>Unlike other capturing group related routines, this routine doesn’t
panic even if captures aren’t enabled on this NFA:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::{NFA, WhichCaptures};

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build_many(<span class="kw-2">&amp;</span>[
        <span class="string">r&quot;(?P&lt;foo&gt;a)&quot;</span>,
        <span class="string">r&quot;a&quot;</span>,
        <span class="string">r&quot;(a)&quot;</span>,
    ])<span class="question-mark">?</span>;
<span class="comment">// When captures aren&#39;t enabled, there&#39;s nothing to return.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().all_names().count());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slots" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1868-1877">source</a><h4 class="code-header">pub fn <a href="#method.slots" class="fnname">slots</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, group_index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)&gt;</h4></section></summary><div class="docblock"><p>Returns the starting and ending slot corresponding to the given
capturing group for the given pattern. The ending slot is always one
more than the starting slot returned.</p>
<p>Note that this is like <a href="struct.GroupInfo.html#method.slot" title="GroupInfo::slot"><code>GroupInfo::slot</code></a>, except that it also returns
the ending slot value for convenience.</p>
<p>If either the pattern ID or the capture index is invalid, then this
returns None.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<p>This example shows that the starting slots for the first capturing
group of each pattern are distinct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_ne!</span>(
    nfa.group_info().slots(PatternID::must(<span class="number">0</span>), <span class="number">0</span>),
    nfa.group_info().slots(PatternID::must(<span class="number">1</span>), <span class="number">0</span>),
);

<span class="comment">// Also, the start and end slot values are never equivalent.
</span><span class="kw">let </span>(start, end) = nfa.group_info().slots(PatternID::ZERO, <span class="number">0</span>).unwrap();
<span class="macro">assert_ne!</span>(start, end);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slot" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1903-1920">source</a><h4 class="code-header">pub fn <a href="#method.slot" class="fnname">slot</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, group_index: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the starting slot corresponding to the given capturing group
for the given pattern. The ending slot is always one more than the
value returned.</p>
<p>If either the pattern ID or the capture index is invalid, then this
returns None.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<p>This example shows that the starting slots for the first capturing
group of each pattern are distinct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, PatternID};

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_ne!</span>(
    nfa.group_info().slot(PatternID::must(<span class="number">0</span>), <span class="number">0</span>),
    nfa.group_info().slot(PatternID::must(<span class="number">1</span>), <span class="number">0</span>),
);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pattern_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1947-1949">source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fnname">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns in this <code>GroupInfo</code>.</p>
<p>This may return zero if the <code>GroupInfo</code> was constructed with no
patterns.</p>
<p>This is guaranteed to be no bigger than <a href="../../struct.PatternID.html#associatedconstant.LIMIT" title="PatternID::LIMIT"><code>PatternID::LIMIT</code></a> because
<code>GroupInfo</code> construction will fail if too many patterns are added.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[A-Z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">3</span>, nfa.group_info().pattern_len());

<span class="kw">let </span>nfa = NFA::never_match();
<span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().pattern_len());

<span class="kw">let </span>nfa = NFA::always_match();
<span class="macro">assert_eq!</span>(<span class="number">1</span>, nfa.group_info().pattern_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.group_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1988-1990">source</a><h4 class="code-header">pub fn <a href="#method.group_len" class="fnname">group_len</a>(&amp;self, pid: <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the number of capture groups in a pattern.</p>
<p>If the pattern ID is invalid, then this returns <code>0</code>.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<p>This example shows how the values returned by this routine may vary
for different patterns and NFA configurations.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, WhichCaptures}, PatternID};

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;(a)(b)(c)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// There are 3 explicit groups in the pattern&#39;s concrete syntax and
// 1 unnamed and implicit group spanning the entire pattern.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, nfa.group_info().group_len(PatternID::ZERO));

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;abc&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// There is just the unnamed implicit group.
</span><span class="macro">assert_eq!</span>(<span class="number">1</span>, nfa.group_info().group_len(PatternID::ZERO));

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">r&quot;abc&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// We disabled capturing groups, so there are none.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().group_len(PatternID::ZERO));

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">r&quot;(a)(b)(c)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// We disabled capturing groups, so there are none, even if there are
// explicit groups in the concrete syntax.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().group_len(PatternID::ZERO));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all_group_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#2035-2037">source</a><h4 class="code-header">pub fn <a href="#method.all_group_len" class="fnname">all_group_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the total number of capture groups across all patterns.</p>
<p>This includes implicit groups that represent the entire match of a
pattern.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>This example shows how the values returned by this routine may vary
for different patterns and NFA configurations.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, WhichCaptures}, PatternID};

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;(a)(b)(c)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// There are 3 explicit groups in the pattern&#39;s concrete syntax and
// 1 unnamed and implicit group spanning the entire pattern.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, nfa.group_info().all_group_len());

<span class="kw">let </span>nfa = NFA::new(<span class="string">r&quot;abc&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// There is just the unnamed implicit group.
</span><span class="macro">assert_eq!</span>(<span class="number">1</span>, nfa.group_info().all_group_len());

<span class="kw">let </span>nfa = NFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;(a)&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;(c)&quot;</span>])<span class="question-mark">?</span>;
<span class="comment">// Each pattern has one implicit groups, and two
// patterns have one explicit group each.
</span><span class="macro">assert_eq!</span>(<span class="number">5</span>, nfa.group_info().all_group_len());

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">r&quot;abc&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// We disabled capturing groups, so there are none.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().all_group_len());

<span class="kw">let </span>nfa = NFA::compiler()
    .configure(NFA::config().which_captures(WhichCaptures::None))
    .build(<span class="string">r&quot;(a)(b)(c)&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// We disabled capturing groups, so there are none, even if there are
// explicit groups in the concrete syntax.
</span><span class="macro">assert_eq!</span>(<span class="number">0</span>, nfa.group_info().group_len(PatternID::ZERO));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slot_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#2066-2068">source</a><h4 class="code-header">pub fn <a href="#method.slot_len" class="fnname">slot_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of slots in this <code>GroupInfo</code> across all
patterns.</p>
<p>The total number of slots is always twice the total number of capturing
groups, including both implicit and explicit groups.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<p>This example shows the relationship between the number of capturing
groups and slots.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="comment">// There are 11 total groups here.
</span><span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>],
    <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>)],
])<span class="question-mark">?</span>;
<span class="comment">// 2 slots per group gives us 11*2=22 slots.
</span><span class="macro">assert_eq!</span>(<span class="number">22</span>, info.slot_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.implicit_slot_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#2098-2100">source</a><h4 class="code-header">pub fn <a href="#method.implicit_slot_len" class="fnname">implicit_slot_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of slots for implicit capturing groups.</p>
<p>This is like <a href="struct.GroupInfo.html#method.slot_len" title="GroupInfo::slot_len"><code>GroupInfo::slot_len</code></a>, except it doesn’t include the
explicit slots for each pattern. Since there are always exactly 2
implicit slots for each pattern, the number of implicit slots is always
equal to twice the number of patterns.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<p>This example shows the relationship between the number of capturing
groups, implicit slots and explicit slots.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="comment">// There are 11 total groups here.
</span><span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>)]])<span class="question-mark">?</span>;
<span class="comment">// 2 slots per group gives us 11*2=22 slots.
</span><span class="macro">assert_eq!</span>(<span class="number">6</span>, info.slot_len());
<span class="comment">// 2 implicit slots per pattern gives us 2 implicit slots since there
// is 1 pattern.
</span><span class="macro">assert_eq!</span>(<span class="number">2</span>, info.implicit_slot_len());
<span class="comment">// 2 explicit capturing groups gives us 2*2=4 explicit slots.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, info.explicit_slot_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.explicit_slot_len" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#2134-2136">source</a><h4 class="code-header">pub fn <a href="#method.explicit_slot_len" class="fnname">explicit_slot_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of slots for explicit capturing groups.</p>
<p>This is like <a href="struct.GroupInfo.html#method.slot_len" title="GroupInfo::slot_len"><code>GroupInfo::slot_len</code></a>, except it doesn’t include the
implicit slots for each pattern. (There are always 2 implicit slots for
each pattern.)</p>
<p>For a non-empty <code>GroupInfo</code>, it is always the case that <code>slot_len</code> is
strictly greater than <code>explicit_slot_len</code>. For an empty <code>GroupInfo</code>,
both the total number of slots and the number of explicit slots is
<code>0</code>.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<p>This example shows the relationship between the number of capturing
groups, implicit slots and explicit slots.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::util::captures::GroupInfo;

<span class="comment">// There are 11 total groups here.
</span><span class="kw">let </span>info = GroupInfo::new(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>)]])<span class="question-mark">?</span>;
<span class="comment">// 2 slots per group gives us 11*2=22 slots.
</span><span class="macro">assert_eq!</span>(<span class="number">6</span>, info.slot_len());
<span class="comment">// 2 implicit slots per pattern gives us 2 implicit slots since there
// is 1 pattern.
</span><span class="macro">assert_eq!</span>(<span class="number">2</span>, info.implicit_slot_len());
<span class="comment">// 2 explicit capturing groups gives us 2*2=4 explicit slots.
</span><span class="macro">assert_eq!</span>(<span class="number">4</span>, info.explicit_slot_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.memory_usage" class="method has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#2143-2151">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fnname">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the memory usage, in bytes, of this <code>GroupInfo</code>.</p>
<p>This does <strong>not</strong> include the stack size used up by this <code>GroupInfo</code>.
To compute that, use <code>std::mem::size_of::&lt;GroupInfo&gt;()</code>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#impl-Clone-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#impl-Debug-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#impl-Default-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/regex_automata/util/captures.rs.html#1449">source</a><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.65.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-GroupInfo" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section><section id="impl-Send-for-GroupInfo" class="impl has-srclink"><a href="#impl-Send-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section><section id="impl-Sync-for-GroupInfo" class="impl has-srclink"><a href="#impl-Sync-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section><section id="impl-Unpin-for-GroupInfo" class="impl has-srclink"><a href="#impl-Unpin-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section><section id="impl-UnwindSafe-for-GroupInfo" class="impl has-srclink"><a href="#impl-UnwindSafe-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.GroupInfo.html" title="struct regex_automata::util::captures::GroupInfo">GroupInfo</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#83">source</a><a href="#impl-ToOwned-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-GroupInfo" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-GroupInfo" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>