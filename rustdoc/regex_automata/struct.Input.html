<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The parameters for a regex search including the haystack to search."><meta name="keywords" content="rust, rustlang, rust-lang, Input"><title>Input in regex_automata - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Input</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.anchored">anchored</a></li><li><a href="#method.earliest">earliest</a></li><li><a href="#method.end">end</a></li><li><a href="#method.get_anchored">get_anchored</a></li><li><a href="#method.get_earliest">get_earliest</a></li><li><a href="#method.get_range">get_range</a></li><li><a href="#method.get_span">get_span</a></li><li><a href="#method.haystack">haystack</a></li><li><a href="#method.is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_done">is_done</a></li><li><a href="#method.new">new</a></li><li><a href="#method.range">range</a></li><li><a href="#method.set_anchored">set_anchored</a></li><li><a href="#method.set_earliest">set_earliest</a></li><li><a href="#method.set_end">set_end</a></li><li><a href="#method.set_range">set_range</a></li><li><a href="#method.set_span">set_span</a></li><li><a href="#method.set_start">set_start</a></li><li><a href="#method.span">span</a></li><li><a href="#method.start">start</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone-for-Input%3C%27h%3E">Clone</a></li><li><a href="#impl-Debug-for-Input%3C%27h%3E">Debug</a></li><li><a href="#impl-From%3C%26%27h%20H%3E-for-Input%3C%27h%3E">From&lt;&amp;&#39;h H&gt;</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-Input%3C%27h%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Input%3C%27h%3E">Send</a></li><li><a href="#impl-Sync-for-Input%3C%27h%3E">Sync</a></li><li><a href="#impl-Unpin-for-Input%3C%27h%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Input%3C%27h%3E">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-Input%3C%27h%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Input%3C%27h%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Input%3C%27h%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Input%3C%27h%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Input%3C%27h%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Input%3C%27h%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Input%3C%27h%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Input%3C%27h%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_automata</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../regex_automata/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="index.html">regex_automata</a>::<wbr><a class="struct" href="#">Input</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/regex_automata/util/search.rs.html#102-107">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Input&lt;'h&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The parameters for a regex search including the haystack to search.</p>
<p>It turns out that regex searches have a few parameters, and in most cases,
those parameters have defaults that work in the vast majority of cases.
This <code>Input</code> type exists to make that common case seamnless while also
providing an avenue for changing the parameters of a search. In particular,
this type enables doing so without a combinatorial explosion of different
methods and/or superfluous parameters in the common cases.</p>
<p>An <code>Input</code> permits configuring the following things:</p>
<ul>
<li>Search only a substring of a haystack, while taking the broader context
into account for resolving look-around assertions.</li>
<li>Indicating whether to search for all patterns in a regex, or to
only search for one pattern in particular.</li>
<li>Whether to perform an anchored on unanchored search.</li>
<li>Whether to report a match as early as possible.</li>
</ul>
<p>All of these parameters, except for the haystack, have sensible default
values. This means that the minimal search configuration is simply a call
to <a href="struct.Input.html#method.new" title="Input::new"><code>Input::new</code></a> with your haystack. Setting any other parameter is
optional.</p>
<p>Moreover, for any <code>H</code> that implements <code>AsRef&lt;[u8]&gt;</code>, there exists a
<code>From&lt;H&gt; for Input</code> implementation. This is useful because many of the
search APIs in this crate accept an <code>Into&lt;Input&gt;</code>. This means you can
provide string or byte strings to these routines directly, and they’ll
automatically get converted into an <code>Input</code> for you.</p>
<p>The lifetime parameter <code>'h</code> refers to the lifetime of the haystack.</p>
<h2 id="organization"><a href="#organization">Organization</a></h2>
<p>The API of <code>Input</code> is split into a few different parts:</p>
<ul>
<li>A builder-like API that transforms a <code>Input</code> by value. Examples:
<a href="struct.Input.html#method.span" title="Input::span"><code>Input::span</code></a> and <a href="struct.Input.html#method.anchored" title="Input::anchored"><code>Input::anchored</code></a>.</li>
<li>A setter API that permits mutating parameters in place. Examples:
<a href="struct.Input.html#method.set_span" title="Input::set_span"><code>Input::set_span</code></a> and <a href="struct.Input.html#method.set_anchored" title="Input::set_anchored"><code>Input::set_anchored</code></a>.</li>
<li>A getter API that permits retrieving any of the search parameters.
Examples: <a href="struct.Input.html#method.get_span" title="Input::get_span"><code>Input::get_span</code></a> and <a href="struct.Input.html#method.get_anchored" title="Input::get_anchored"><code>Input::get_anchored</code></a>.</li>
<li>A few convenience getter routines that don’t conform to the above naming
pattern due to how common they are. Examples: <a href="struct.Input.html#method.haystack" title="Input::haystack"><code>Input::haystack</code></a>,
<a href="struct.Input.html#method.start" title="Input::start"><code>Input::start</code></a> and <a href="struct.Input.html#method.end" title="Input::end"><code>Input::end</code></a>.</li>
<li>Miscellaneous predicates and other helper routines that are useful
in some contexts. Examples: <a href="struct.Input.html#method.is_char_boundary" title="Input::is_char_boundary"><code>Input::is_char_boundary</code></a>.</li>
</ul>
<p>A <code>Input</code> exposes so much because it is meant to be used by both callers of
regex engines <em>and</em> implementors of regex engines. A constraining factor is
that regex engines should accept a <code>&amp;Input</code> as its lowest level API, which
means that implementors should only use the “getter” APIs of a <code>Input</code>.</p>
<h2 id="valid-bounds-and-search-termination"><a href="#valid-bounds-and-search-termination">Valid bounds and search termination</a></h2>
<p>An <code>Input</code> permits setting the bounds of a search via either
<a href="struct.Input.html#method.span" title="Input::span"><code>Input::span</code></a> or <a href="struct.Input.html#method.range" title="Input::range"><code>Input::range</code></a>. The bounds set must be valid, or
else a panic will occur. Bounds are valid if and only if:</p>
<ul>
<li>The bounds represent a valid range into the input’s haystack.</li>
<li><strong>or</strong> the end bound is a valid ending bound for the haystack <em>and</em>
the start bound is exactly one greater than the start bound.</li>
</ul>
<p>In the latter case, <a href="struct.Input.html#method.is_done" title="Input::is_done"><code>Input::is_done</code></a> will return true and indicates any
search receiving such an input should immediately return with no match.</p>
<p>Note that while <code>Input</code> is used for reverse searches in this crate, the
<code>Input::is_done</code> predicate assumes a forward search. Because unsigned
offsets are used internally, there is no way to tell from only the offsets
whether a reverse search is done or not.</p>
<h2 id="regex-engine-support"><a href="#regex-engine-support">Regex engine support</a></h2>
<p>Any regex engine accepting an <code>Input</code> must support at least the following
things:</p>
<ul>
<li>Searching a <code>&amp;[u8]</code> for matches.</li>
<li>Searching a substring of <code>&amp;[u8]</code> for a match, such that any match
reported must appear entirely within that substring.</li>
<li>For a forwards search, a match should never be reported when
<a href="struct.Input.html#method.is_done" title="Input::is_done"><code>Input::is_done</code></a> returns true. (For reverse searches, termination should
be handled outside of <code>Input</code>.)</li>
</ul>
<p>Supporting other aspects of an <code>Input</code> are optional, but regex engines
should handle aspects they don’t support gracefully. How this is done is
generally up to the regex engine. This crate generally treats unsupported
anchored modes as an error to report for example, but for simplicity, in
the meta regex engine, trying to search with an invalid pattern ID just
results in no match being reported.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#109-765">source</a><a href="#impl-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#112-119">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>&lt;H:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]&gt;&gt;(haystack: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'h </a>H) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Create a new search configuration for the given haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.span" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#201-204">source</a><h4 class="code-header">pub fn <a href="#method.span" class="fnname">span</a>&lt;S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Span.html" title="struct regex_automata::Span">Span</a>&gt;&gt;(self, span: S) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Set the span for this search.</p>
<p>This routine does not panic if the span given is not a valid range for
this search’s haystack. If this search is run with an invalid range,
then the most likely outcome is that the actual search execution will
panic.</p>
<p>This routine is generic over how a span is provided. While
a <a href="struct.Span.html" title="Span"><code>Span</code></a> may be given directly, one may also provide a
<code>std::ops::Range&lt;usize&gt;</code>. To provide anything supported by range
syntax, use the <a href="struct.Input.html#method.range" title="Input::range"><code>Input::range</code></a> method.</p>
<p>The default span is the entire haystack.</p>
<p>Note that <a href="struct.Input.html#method.range" title="Input::range"><code>Input::range</code></a> overrides this method and vice versa.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This panics if the given span does not correspond to valid bounds in
the haystack or the termination of a search.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This example shows how the span of the search can impact whether a
match is reported or not. This is particularly relevant for look-around
operators, which might take things outside of the span into account
when determining whether they match.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    Match, Input,
};

<span class="comment">// Look for &#39;at&#39;, but as a distinct word.
</span><span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;\bat\b&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();

<span class="comment">// Our haystack contains &#39;at&#39;, but not as a distinct word.
</span><span class="kw">let </span>haystack = <span class="string">&quot;batter&quot;</span>;

<span class="comment">// A standard search finds nothing, as expected.
</span><span class="kw">let </span>input = Input::new(haystack);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.get_match());

<span class="comment">// But if we wanted to search starting at position &#39;1&#39;, we might
// slice the haystack. If we do this, it&#39;s impossible for the \b
// anchors to take the surrounding context into account! And thus,
// a match is produced.
</span><span class="kw">let </span>input = Input::new(<span class="kw-2">&amp;</span>haystack[<span class="number">1</span>..<span class="number">3</span>]);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">2</span>)), caps.get_match());

<span class="comment">// But if we specify the span of the search instead of slicing the
// haystack, then the regex engine can &quot;see&quot; outside of the span
// and resolve the anchors correctly.
</span><span class="kw">let </span>input = Input::new(haystack).span(<span class="number">1</span>..<span class="number">3</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.get_match());
</code></pre></div>
<p>This may seem a little ham-fisted, but this scenario tends to come up
if some other regex engine found the match span and now you need to
re-process that span to look for capturing groups. (e.g., Run a faster
DFA first, find a match, then run the PikeVM on just the match span to
resolve capturing groups.) In order to implement that sort of logic
correctly, you need to set the span on the search instead of slicing
the haystack directly.</p>
<p>The other advantage of using this routine to specify the bounds of the
search is that the match offsets are still reported in terms of the
original haystack. For example, the second search in the example above
reported a match at position <code>0</code>, even though <code>at</code> starts at offset
<code>1</code> because we sliced the haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.range" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#239-242">source</a><h4 class="code-header">pub fn <a href="#method.range" class="fnname">range</a>&lt;R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;&gt;(self, range: R) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Like <code>Input::span</code>, but accepts any range instead.</p>
<p>This routine does not panic if the range given is not a valid range for
this search’s haystack. If this search is run with an invalid range,
then the most likely outcome is that the actual search execution will
panic.</p>
<p>The default range is the entire haystack.</p>
<p>Note that <a href="struct.Input.html#method.span" title="Input::span"><code>Input::span</code></a> overrides this method and vice versa.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This routine will panic if the given range could not be converted
to a valid <a href="https://doc.rust-lang.org/1.65.0/core/ops/range/struct.Range.html" title="Range"><code>Range</code></a>. For example, this would panic when given
<code>0..=usize::MAX</code> since it cannot be represented using a half-open
interval in terms of <code>usize</code>.</p>
<p>This also panics if the given range does not correspond to valid bounds
in the haystack or the termination of a search.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>).range(<span class="number">2</span>..=<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="number">2</span>..<span class="number">5</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.anchored" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#337-340">source</a><h4 class="code-header">pub fn <a href="#method.anchored" class="fnname">anchored</a>(self, mode: <a class="enum" href="enum.Anchored.html" title="enum regex_automata::Anchored">Anchored</a>) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Sets the anchor mode of a search.</p>
<p>When a search is anchored (so that’s <a href="enum.Anchored.html#variant.Yes" title="Anchored::Yes"><code>Anchored::Yes</code></a> or
<a href="enum.Anchored.html#variant.Pattern" title="Anchored::Pattern"><code>Anchored::Pattern</code></a>), a match must begin at the start of a search.
When a search is not anchored (that’s <a href="enum.Anchored.html#variant.No" title="Anchored::No"><code>Anchored::No</code></a>), regex engines
will behave as if the pattern started with a <code>(?s-u:.)*?</code>. This prefix
permits a match to appear anywhere.</p>
<p>By default, the anchored mode is <a href="enum.Anchored.html#variant.No" title="Anchored::No"><code>Anchored::No</code></a>.</p>
<p><strong>WARNING:</strong> this is subtly different than using a <code>^</code> at the start of
your regex. A <code>^</code> forces a regex to match exclusively at the start of
a haystack, regardless of where you begin your search. In contrast,
anchoring a search will allow your regex to match anywhere in your
haystack, but the match must start at the beginning of a search.</p>
<p>For example, consider the haystack <code>aba</code> and the following searches:</p>
<ol>
<li>The regex <code>^a</code> is compiled with <code>Anchored::No</code> and searches <code>aba</code>
starting at position <code>2</code>. Since <code>^</code> requires the match to start at
the beginning of the haystack and <code>2 &gt; 0</code>, no match is found.</li>
<li>The regex <code>a</code> is compiled with <code>Anchored::Yes</code> and searches <code>aba</code>
starting at position <code>2</code>. This reports a match at <code>[2, 3]</code> since
the match starts where the search started. Since there is no <code>^</code>,
there is no requirement for the match to start at the beginning of
the haystack.</li>
<li>The regex <code>a</code> is compiled with <code>Anchored::Yes</code> and searches <code>aba</code>
starting at position <code>1</code>. Since <code>b</code> corresponds to position <code>1</code> and
since the search is anchored, it finds no match. While the regex
matches at other positions, configuring the search to be anchored
requires that it only report a match that begins at the same offset
as the beginning of the search.</li>
<li>The regex <code>a</code> is compiled with <code>Anchored::No</code> and searches <code>aba</code>
starting at position <code>1</code>. Since the search is not anchored and
the regex does not start with <code>^</code>, the search executes as if there
is a <code>(?s:.)*?</code> prefix that permits it to match anywhere. Thus, it
reports a match at <code>[2, 3]</code>.</li>
</ol>
<p>Note that the <a href="enum.Anchored.html#variant.Pattern" title="Anchored::Pattern"><code>Anchored::Pattern</code></a> mode is like <code>Anchored::Yes</code>,
except it only reports matches for a particular pattern.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This demonstrates the differences between an anchored search and
a pattern that begins with <code>^</code> (as described in the above warning
message).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::pikevm::PikeVM,
    Anchored, Match, Input,
};

<span class="kw">let </span>haystack = <span class="string">&quot;aba&quot;</span>;

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;^a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>input = Input::new(haystack).span(<span class="number">2</span>..<span class="number">3</span>).anchored(Anchored::No);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="comment">// No match is found because 2 is not the beginning of the haystack,
// which is what ^ requires.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.get_match());

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>input = Input::new(haystack).span(<span class="number">2</span>..<span class="number">3</span>).anchored(Anchored::Yes);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="comment">// An anchored search can still match anywhere in the haystack, it just
// must begin at the start of the search which is &#39;2&#39; in this case.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">2</span>..<span class="number">3</span>)), caps.get_match());

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>input = Input::new(haystack).span(<span class="number">1</span>..<span class="number">3</span>).anchored(Anchored::Yes);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="comment">// No match is found since we start searching at offset 1 which
// corresponds to &#39;b&#39;. Since there is no &#39;(?s:.)*?&#39; prefix, no match
// is found.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.get_match());

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>cache, <span class="kw-2">mut </span>caps) = (re.create_cache(), re.create_captures());
<span class="kw">let </span>input = Input::new(haystack).span(<span class="number">1</span>..<span class="number">3</span>).anchored(Anchored::No);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="comment">// Since anchored=no, an implicit &#39;(?s:.)*?&#39; prefix was added to the
// pattern. Even though the search starts at &#39;b&#39;, the &#39;match anything&#39;
// prefix allows the search to match &#39;a&#39;.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">2</span>..<span class="number">3</span>));
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.earliest" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#389-392">source</a><h4 class="code-header">pub fn <a href="#method.earliest" class="fnname">earliest</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Whether to execute an “earliest” search or not.</p>
<p>When running a non-overlapping search, an “earliest” search will return
the match location as early as possible. For example, given a pattern
of <code>foo[0-9]+</code> and a haystack of <code>foo12345</code>, a normal leftmost search
will return <code>foo12345</code> as a match. But an “earliest” search for regex
engines that support “earliest” semantics will return <code>foo1</code> as a
match, since as soon as the first digit following <code>foo</code> is seen, it is
known to have found a match.</p>
<p>Note that “earliest” semantics generally depend on the regex engine.
Different regex engines may determine there is a match at different
points. So there is no guarantee that “earliest” matches will always
return the same offsets for all regex engines. The “earliest” notion
is really about when the particular regex engine determines there is
a match rather than a consistent semantic unto itself. This is often
useful for implementing “did a match occur or not” predicates, but
sometimes the offset is useful as well.</p>
<p>This is disabled by default.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows the difference between “earliest” searching and
normal searching.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::pikevm::PikeVM, Match, Input};

<span class="kw">let </span>re = PikeVM::new(<span class="string">r&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();

<span class="comment">// A normal search implements greediness like you expect.
</span><span class="kw">let </span>input = Input::new(<span class="string">&quot;foo12345&quot;</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">8</span>)), caps.get_match());

<span class="comment">// When &#39;earliest&#39; is enabled and the regex engine supports
// it, the search will bail once it knows a match has been
// found.
</span><span class="kw">let </span>input = Input::new(<span class="string">&quot;foo12345&quot;</span>).earliest(<span class="bool-val">true</span>);
re.search(<span class="kw-2">&amp;mut </span>cache, <span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">4</span>)), caps.get_match());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_span" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#419-429">source</a><h4 class="code-header">pub fn <a href="#method.set_span" class="fnname">set_span</a>&lt;S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Span.html" title="struct regex_automata::Span">Span</a>&gt;&gt;(&amp;mut self, span: S)</h4></section></summary><div class="docblock"><p>Set the span for this search configuration.</p>
<p>This is like the <a href="struct.Input.html#method.span" title="Input::span"><code>Input::span</code></a> method, except this mutates the
span in place.</p>
<p>This routine is generic over how a span is provided. While
a <a href="struct.Span.html" title="Span"><code>Span</code></a> may be given directly, one may also provide a
<code>std::ops::Range&lt;usize&gt;</code>.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>This panics if the given span does not correspond to valid bounds in
the haystack or the termination of a search.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());
input.set_span(<span class="number">2</span>..<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="number">2</span>..<span class="number">4</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_range" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#462-481">source</a><h4 class="code-header">pub fn <a href="#method.set_range" class="fnname">set_range</a>&lt;R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;&gt;(&amp;mut self, range: R)</h4></section></summary><div class="docblock"><p>Set the span for this search configuration given any range.</p>
<p>This is like the <a href="struct.Input.html#method.range" title="Input::range"><code>Input::range</code></a> method, except this mutates the
span in place.</p>
<p>This routine does not panic if the range given is not a valid range for
this search’s haystack. If this search is run with an invalid range,
then the most likely outcome is that the actual search execution will
panic.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>This routine will panic if the given range could not be converted
to a valid <a href="https://doc.rust-lang.org/1.65.0/core/ops/range/struct.Range.html" title="Range"><code>Range</code></a>. For example, this would panic when given
<code>0..=usize::MAX</code> since it cannot be represented using a half-open
interval in terms of <code>usize</code>.</p>
<p>This also panics if the given span does not correspond to valid bounds
in the haystack or the termination of a search.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());
input.set_range(<span class="number">2</span>..=<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="number">2</span>..<span class="number">5</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_start" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#505-507">source</a><h4 class="code-header">pub fn <a href="#method.set_start" class="fnname">set_start</a>(&amp;mut self, start: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Set the starting offset for the span for this search configuration.</p>
<p>This is a convenience routine for only mutating the start of a span
without having to set the entire span.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>This panics if the span resulting from the new start position does not
correspond to valid bounds in the haystack or the termination of a
search.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());
input.set_start(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="number">5</span>..<span class="number">6</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_end" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#531-533">source</a><h4 class="code-header">pub fn <a href="#method.set_end" class="fnname">set_end</a>(&amp;mut self, end: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Set the ending offset for the span for this search configuration.</p>
<p>This is a convenience routine for only mutating the end of a span
without having to set the entire span.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>This panics if the span resulting from the new end position does not
correspond to valid bounds in the haystack or the termination of a
search.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());
input.set_end(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">5</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_anchored" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#553-555">source</a><h4 class="code-header">pub fn <a href="#method.set_anchored" class="fnname">set_anchored</a>(&amp;mut self, mode: <a class="enum" href="enum.Anchored.html" title="enum regex_automata::Anchored">Anchored</a>)</h4></section></summary><div class="docblock"><p>Set the anchor mode of a search.</p>
<p>This is like <a href="struct.Input.html#method.anchored" title="Input::anchored"><code>Input::anchored</code></a>, except it mutates the search
configuration in place.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Anchored, Input, PatternID};

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(Anchored::No, input.get_anchored());

<span class="kw">let </span>pid = PatternID::must(<span class="number">5</span>);
input.set_anchored(Anchored::Pattern(pid));
<span class="macro">assert_eq!</span>(Anchored::Pattern(pid), input.get_anchored());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_earliest" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#573-575">source</a><h4 class="code-header">pub fn <a href="#method.set_earliest" class="fnname">set_earliest</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Set whether the search should execute in “earliest” mode or not.</p>
<p>This is like <a href="struct.Input.html#method.earliest" title="Input::earliest"><code>Input::earliest</code></a>, except it mutates the search
configuration in place.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert!</span>(!input.get_earliest());
input.set_earliest(<span class="bool-val">true</span>);
<span class="macro">assert!</span>(input.get_earliest());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.haystack" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#588-590">source</a><h4 class="code-header">pub fn <a href="#method.haystack" class="fnname">haystack</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Return a borrow of the underlying haystack as a slice of bytes.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">b&quot;foobar&quot;</span>, input.haystack());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.start" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#612-614">source</a><h4 class="code-header">pub fn <a href="#method.start" class="fnname">start</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the start position of this search.</p>
<p>This is a convenience routine for <code>search.get_span().start()</code>.</p>
<p>When <a href="struct.Input.html#method.is_done" title="Input::is_done"><code>Input::is_done</code></a> is <code>false</code>, this is guaranteed to return
an offset that is less than or equal to <a href="struct.Input.html#method.end" title="Input::end"><code>Input::end</code></a>. Otherwise,
the offset is one greater than <a href="struct.Input.html#method.end" title="Input::end"><code>Input::end</code></a>.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>, input.start());

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>).span(<span class="number">2</span>..<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="number">2</span>, input.start());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.end" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#635-637">source</a><h4 class="code-header">pub fn <a href="#method.end" class="fnname">end</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the end position of this search.</p>
<p>This is a convenience routine for <code>search.get_span().end()</code>.</p>
<p>This is guaranteed to return an offset that is a valid exclusive end
bound for this input’s haystack.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">6</span>, input.end());

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>).span(<span class="number">2</span>..<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="number">4</span>, input.end());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_span" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#656-658">source</a><h4 class="code-header">pub fn <a href="#method.get_span" class="fnname">get_span</a>(&amp;self) -&gt; <a class="struct" href="struct.Span.html" title="struct regex_automata::Span">Span</a></h4></section></summary><div class="docblock"><p>Return the span for this search configuration.</p>
<p>If one was not explicitly set, then the span corresponds to the entire
range of the haystack.</p>
<p>When <a href="struct.Input.html#method.is_done" title="Input::is_done"><code>Input::is_done</code></a> is <code>false</code>, the span returned is guaranteed
to correspond to valid bounds for this input’s haystack.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Input, Span};

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(Span { start: <span class="number">0</span>, end: <span class="number">6 </span>}, input.get_span());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_range" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#677-679">source</a><h4 class="code-header">pub fn <a href="#method.get_range" class="fnname">get_range</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Return the span as a range for this search configuration.</p>
<p>If one was not explicitly set, then the span corresponds to the entire
range of the haystack.</p>
<p>When <a href="struct.Input.html#method.is_done" title="Input::is_done"><code>Input::is_done</code></a> is <code>false</code>, the range returned is guaranteed
to correspond to valid bounds for this input’s haystack.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="number">0</span>..<span class="number">6</span>, input.get_range());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_anchored" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#698-700">source</a><h4 class="code-header">pub fn <a href="#method.get_anchored" class="fnname">get_anchored</a>(&amp;self) -&gt; <a class="enum" href="enum.Anchored.html" title="enum regex_automata::Anchored">Anchored</a></h4></section></summary><div class="docblock"><p>Return the anchored mode for this search configuration.</p>
<p>If no anchored mode was set, then it defaults to <a href="enum.Anchored.html#variant.No" title="Anchored::No"><code>Anchored::No</code></a>.</p>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Anchored, Input, PatternID};

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq!</span>(Anchored::No, input.get_anchored());

<span class="kw">let </span>pid = PatternID::must(<span class="number">5</span>);
input.set_anchored(Anchored::Pattern(pid));
<span class="macro">assert_eq!</span>(Anchored::Pattern(pid), input.get_anchored());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_earliest" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#713-715">source</a><h4 class="code-header">pub fn <a href="#method.get_earliest" class="fnname">get_earliest</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether this search should execute in “earliest” mode.</p>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert!</span>(!input.get_earliest());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_done" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#736-738">source</a><h4 class="code-header">pub fn <a href="#method.is_done" class="fnname">is_done</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if this search can never return any other
matches.</p>
<p>This occurs when the start position of this search is greater than the
end position of the search.</p>
<h5 id="example-17"><a href="#example-17">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span><span class="kw-2">mut </span>input = Input::new(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert!</span>(!input.is_done());
input.set_start(<span class="number">6</span>);
<span class="macro">assert!</span>(!input.is_done());
input.set_start(<span class="number">7</span>);
<span class="macro">assert!</span>(input.is_done());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#762-764">source</a><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, offset: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given offset in this search’s haystack
falls on a valid UTF-8 encoded codepoint boundary.</p>
<p>If the haystack is not valid UTF-8, then the behavior of this routine
is unspecified.</p>
<h5 id="example-18"><a href="#example-18">Example</a></h5>
<p>This shows where codepoint boundaries do and don’t exist in valid
UTF-8.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::Input;

<span class="kw">let </span>input = Input::new(<span class="string">&quot;☃&quot;</span>);
<span class="macro">assert!</span>(input.is_char_boundary(<span class="number">0</span>));
<span class="macro">assert!</span>(!input.is_char_boundary(<span class="number">1</span>));
<span class="macro">assert!</span>(!input.is_char_boundary(<span class="number">2</span>));
<span class="macro">assert!</span>(input.is_char_boundary(<span class="number">3</span>));
<span class="macro">assert!</span>(!input.is_char_boundary(<span class="number">4</span>));</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#101">source</a><a href="#impl-Clone-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#101">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#767-778">source</a><a href="#impl-Debug-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#768-777">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27h%20H%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#780-784">source</a><a href="#impl-From%3C%26%27h%20H%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h, H:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'h </a>H&gt; for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/util/search.rs.html#781-783">source</a><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(haystack: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;'h </a>H) -&gt; <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Input%3C%27h%3E" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section><section id="impl-Send-for-Input%3C%27h%3E" class="impl has-srclink"><a href="#impl-Send-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section><section id="impl-Sync-for-Input%3C%27h%3E" class="impl has-srclink"><a href="#impl-Sync-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section><section id="impl-Unpin-for-Input%3C%27h%3E" class="impl has-srclink"><a href="#impl-Unpin-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section><section id="impl-UnwindSafe-for-Input%3C%27h%3E" class="impl has-srclink"><a href="#impl-UnwindSafe-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#83">source</a><a href="#impl-ToOwned-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Input%3C%27h%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-Input%3C%27h%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>