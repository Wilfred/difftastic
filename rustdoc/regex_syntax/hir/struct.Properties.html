<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A type that collects various properties of an HIR value."><meta name="keywords" content="rust, rustlang, rust-lang, Properties"><title>Properties in regex_syntax::hir - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../regex_syntax/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../regex_syntax/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Properties</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.explicit_captures_len">explicit_captures_len</a></li><li><a href="#method.is_alternation_literal">is_alternation_literal</a></li><li><a href="#method.is_literal">is_literal</a></li><li><a href="#method.is_utf8">is_utf8</a></li><li><a href="#method.look_set">look_set</a></li><li><a href="#method.look_set_prefix">look_set_prefix</a></li><li><a href="#method.look_set_prefix_any">look_set_prefix_any</a></li><li><a href="#method.look_set_suffix">look_set_suffix</a></li><li><a href="#method.look_set_suffix_any">look_set_suffix_any</a></li><li><a href="#method.maximum_len">maximum_len</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.minimum_len">minimum_len</a></li><li><a href="#method.static_explicit_captures_len">static_explicit_captures_len</a></li><li><a href="#method.union">union</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone-for-Properties">Clone</a></li><li><a href="#impl-Debug-for-Properties">Debug</a></li><li><a href="#impl-Eq-for-Properties">Eq</a></li><li><a href="#impl-PartialEq%3CProperties%3E-for-Properties">PartialEq&lt;Properties&gt;</a></li><li><a href="#impl-StructuralEq-for-Properties">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq-for-Properties">StructuralPartialEq</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-Properties">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Properties">Send</a></li><li><a href="#impl-Sync-for-Properties">Sync</a></li><li><a href="#impl-Unpin-for-Properties">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Properties">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-Properties">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Properties">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Properties">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Properties">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Properties">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Properties">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Properties">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Properties">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_syntax::hir</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../regex_syntax/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">regex_syntax</a>::<wbr><a href="index.html">hir</a>::<wbr><a class="struct" href="#">Properties</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/regex_syntax/hir/mod.rs.html#1886">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Properties(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A type that collects various properties of an HIR value.</p>
<p>Properties are always scalar values and represent meta data that is
computed inductively on an HIR value. Properties are defined for all
HIR values.</p>
<p>All methods on a <code>Properties</code> value take constant time and are meant to
be cheap to call.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1911-2315">source</a><a href="#impl-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.minimum_len" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1922-1924">source</a><h4 class="code-header">pub fn <a href="#method.minimum_len" class="fnname">minimum_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length (in bytes) of the smallest string matched by this
HIR.</p>
<p>A return value of <code>0</code> is possible and occurs when the HIR can match an
empty string.</p>
<p><code>None</code> is returned when there is no minimum length. This occurs in
precisely the cases where the HIR matches nothing. i.e., The language
the regex matches is empty. An example of such a regex is <code>\P{any}</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.maximum_len" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1937-1939">source</a><h4 class="code-header">pub fn <a href="#method.maximum_len" class="fnname">maximum_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length (in bytes) of the longest string matched by this
HIR.</p>
<p>A return value of <code>0</code> is possible and occurs when nothing longer than
the empty string is in the language described by this HIR.</p>
<p><code>None</code> is returned when there is no longest matching string. This
occurs when the HIR matches nothing or when there is no upper bound on
the length of matching strings. Example of such regexes are <code>\P{any}</code>
(matches nothing) and <code>a+</code> (has no upper bound).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1944-1946">source</a><h4 class="code-header">pub fn <a href="#method.look_set" class="fnname">look_set</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear at least once
in this HIR value.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_prefix" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1955-1957">source</a><h4 class="code-header">pub fn <a href="#method.look_set_prefix" class="fnname">look_set_prefix</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a prefix for
this HIR value. That is, the set returned corresponds to the set of
assertions that must be passed before matching any bytes in a haystack.</p>
<p>For example, <code>hir.look_set_prefix().contains(Look::Start)</code> returns true
if and only if the HIR is fully anchored at the start.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_prefix_any" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1968-1970">source</a><h4 class="code-header">pub fn <a href="#method.look_set_prefix_any" class="fnname">look_set_prefix_any</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a <em>possible</em>
prefix for this HIR value. That is, the set returned corresponds to the
set of assertions that <em>may</em> be passed before matching any bytes in a
haystack.</p>
<p>For example, <code>hir.look_set_prefix_any().contains(Look::Start)</code> returns
true if and only if it’s possible for the regex to match through a
anchored assertion before consuming any input.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_suffix" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1980-1982">source</a><h4 class="code-header">pub fn <a href="#method.look_set_suffix" class="fnname">look_set_suffix</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a suffix for
this HIR value. That is, the set returned corresponds to the set of
assertions that must be passed in order to be considered a match after
all other consuming HIR expressions.</p>
<p>For example, <code>hir.look_set_suffix().contains(Look::End)</code> returns true
if and only if the HIR is fully anchored at the end.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.look_set_suffix_any" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1993-1995">source</a><h4 class="code-header">pub fn <a href="#method.look_set_suffix_any" class="fnname">look_set_suffix_any</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a <em>possible</em>
suffix for this HIR value. That is, the set returned corresponds to the
set of assertions that <em>may</em> be passed before matching any bytes in a
haystack.</p>
<p>For example, <code>hir.look_set_suffix_any().contains(Look::End)</code> returns
true if and only if it’s possible for the regex to match through a
anchored assertion at the end of a match without consuming any input.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_utf8" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2062-2064">source</a><h4 class="code-header">pub fn <a href="#method.is_utf8" class="fnname">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if the corresponding HIR will always match
valid UTF-8.</p>
<p>When this returns false, then it is possible for this HIR expression to
match invalid UTF-8, including by matching between the code units of
a single UTF-8 encoded codepoint.</p>
<p>Note that this returns true even when the corresponding HIR can match
the empty string. Since an empty string can technically appear between
UTF-8 code units, it is possible for a match to be reported that splits
a codepoint which could in turn be considered matching invalid UTF-8.
However, it is generally assumed that such empty matches are handled
specially by the search routine if it is absolutely required that
matches not split a codepoint.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This code example shows the UTF-8 property of a variety of patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{ParserBuilder, parse};

<span class="comment">// Examples of &#39;is_utf8() == true&#39;.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;a&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;[^a]&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;.&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\W&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\b&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\B&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\b&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\B&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Unicode mode is enabled by default, and in
// that mode, all \x hex escapes are treated as
// codepoints. So this actually matches the UTF-8
// encoding of U+00FF.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());

<span class="comment">// Now we show examples of &#39;is_utf8() == false&#39;.
// The only way to do this is to force the parser
// to permit invalid UTF-8, otherwise all of these
// would fail to parse!
</span><span class="kw">let </span>parse = |pattern| {
    ParserBuilder::new().utf8(<span class="bool-val">false</span>).build().parse(pattern)
};
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)[^a]&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u).&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)\W&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Conversely to the equivalent example above,
// when Unicode mode is disabled, \x hex escapes
// are treated as their raw byte values.
</span><span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Note that just because we disabled UTF-8 in the
// parser doesn&#39;t mean we still can&#39;t use Unicode.
// It is enabled by default, so \xFF is still
// equivalent to matching the UTF-8 encoding of
// U+00FF by default.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Even though we use raw bytes that individually
// are not valid UTF-8, when combined together, the
// overall expression *does* match valid UTF-8!
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\xE2\x98\x83&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.explicit_captures_len" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2086-2088">source</a><h4 class="code-header">pub fn <a href="#method.explicit_captures_len" class="fnname">explicit_captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of explicit capturing groups in the
corresponding HIR.</p>
<p>Note that this does not include the implicit capturing group
corresponding to the entire match that is typically included by regex
engines.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This method will return <code>0</code> for <code>a</code> and <code>1</code> for <code>(a)</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::parse;

<span class="macro">assert_eq!</span>(<span class="number">0</span>, parse(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>.properties().explicit_captures_len());
<span class="macro">assert_eq!</span>(<span class="number">1</span>, parse(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>.properties().explicit_captures_len());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.static_explicit_captures_len" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2126-2128">source</a><h4 class="code-header">pub fn <a href="#method.static_explicit_captures_len" class="fnname">static_explicit_captures_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the total number of explicit capturing groups that appear in
every possible match.</p>
<p>If the number of capture groups can vary depending on the match, then
this returns <code>None</code>. That is, a value is only returned when the number
of matching groups is invariant or “static.”</p>
<p>Note that this does not include the implicit capturing group
corresponding to the entire match.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This shows a few cases where a static number of capture groups is
available and a few cases where it is not.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::parse;

<span class="kw">let </span>len = |pattern| {
    parse(pattern).map(|h| {
        h.properties().static_explicit_captures_len()
    })
};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), len(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(a)|(b)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), len(<span class="string">&quot;(a)(b)|(c)(d)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;(a)|b&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;a|(b)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;(b)*&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(b)+&quot;</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_literal" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2138-2140">source</a><h4 class="code-header">pub fn <a href="#method.is_literal" class="fnname">is_literal</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if this HIR is a simple literal. This is
only true when this HIR expression is either itself a <code>Literal</code> or a
concatenation of only <code>Literal</code>s.</p>
<p>For example, <code>f</code> and <code>foo</code> are literals, but <code>f+</code>, <code>(foo)</code>, <code>foo()</code> and
the empty string are not (even though they contain sub-expressions that
are literals).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_alternation_literal" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2151-2153">source</a><h4 class="code-header">pub fn <a href="#method.is_alternation_literal" class="fnname">is_alternation_literal</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if this HIR is either a simple literal or an
alternation of simple literals. This is only
true when this HIR expression is either itself a <code>Literal</code> or a
concatenation of only <code>Literal</code>s or an alternation of only <code>Literal</code>s.</p>
<p>For example, <code>f</code>, <code>foo</code>, <code>a|b|c</code>, and <code>foo|bar|baz</code> are alternation
literals, but <code>f+</code>, <code>(foo)</code>, <code>foo()</code>, and the empty pattern are not
(even though that contain sub-expressions that are literals).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.memory_usage" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2158-2160">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fnname">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total amount of heap memory usage, in bytes, used by this
<code>Properties</code> value.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.union" class="method has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#2232-2314">source</a><h4 class="code-header">pub fn <a href="#method.union" class="fnname">union</a>&lt;I, P&gt;(props: I) -&gt; <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a><span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = P&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a new set of properties that corresponds to the union of the
iterator of properties given.</p>
<p>This is useful when one has multiple <code>Hir</code> expressions and wants
to combine them into a single alternation without constructing the
corresponding <code>Hir</code>. This routine provides a way of combining the
properties of each <code>Hir</code> expression into one set of properties
representing the union of those expressions.</p>
<h5 id="example-union-with-hirs-that-never-match"><a href="#example-union-with-hirs-that-never-match">Example: union with HIRs that never match</a></h5>
<p>This example shows that unioning properties together with one that
represents a regex that never matches will “poison” certain attributes,
like the minimum and maximum lengths.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{hir::Properties, parse};

<span class="kw">let </span>hir1 = parse(<span class="string">&quot;ab?c?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir1.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), hir1.properties().maximum_len());

<span class="kw">let </span>hir2 = parse(<span class="string">r&quot;[a&amp;&amp;b]&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().maximum_len());

<span class="kw">let </span>hir3 = parse(<span class="string">r&quot;wxy?z?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), hir3.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), hir3.properties().maximum_len());

<span class="kw">let </span>unioned = Properties::union([
	hir1.properties(),
	hir2.properties(),
	hir3.properties(),
]);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.maximum_len());
</code></pre></div>
<p>The maximum length can also be “poisoned” by a pattern that has no
upper bound on the length of a match. The minimum length remains
unaffected:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{hir::Properties, parse};

<span class="kw">let </span>hir1 = parse(<span class="string">&quot;ab?c?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir1.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), hir1.properties().maximum_len());

<span class="kw">let </span>hir2 = parse(<span class="string">r&quot;a+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir2.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().maximum_len());

<span class="kw">let </span>hir3 = parse(<span class="string">r&quot;wxy?z?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), hir3.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), hir3.properties().maximum_len());

<span class="kw">let </span>unioned = Properties::union([
	hir1.properties(),
	hir2.properties(),
	hir3.properties(),
]);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), unioned.minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.maximum_len());
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-Clone-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-Debug-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.65.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.65.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CProperties%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-PartialEq%3CProperties%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>&gt; for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/cmp.rs.html#236">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.PartialEq.html#method.ne">Read more</a></div></details></div></details><section id="impl-Eq-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-Eq-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-StructuralEq-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-StructuralEq-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-StructuralPartialEq-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="../../src/regex_syntax/hir/mod.rs.html#1885">source</a><a href="#impl-StructuralPartialEq-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Properties" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Send-for-Properties" class="impl has-srclink"><a href="#impl-Send-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Sync-for-Properties" class="impl has-srclink"><a href="#impl-Sync-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Unpin-for-Properties" class="impl has-srclink"><a href="#impl-Unpin-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-UnwindSafe-for-Properties" class="impl has-srclink"><a href="#impl-UnwindSafe-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.65.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.65.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#218">source</a><a href="#impl-BorrowMut%3CT%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.65.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.65.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#559">source</a><a href="#impl-From%3CT%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#562">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#543">source</a><a href="#impl-Into%3CU%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#551">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#83">source</a><a href="#impl-ToOwned-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.65.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.65.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#601">source</a><a href="#impl-TryFrom%3CU%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#607">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Properties" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#586">source</a><a href="#impl-TryInto%3CU%3E-for-Properties" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.65.0/src/core/convert/mod.rs.html#592">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.65.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.65.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="regex_syntax" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>