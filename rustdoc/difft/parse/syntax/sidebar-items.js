window.SIDEBAR_ITEMS = {"enum":[["AtomKind",""],["MatchKind","A matched token (an atom, a delimiter, or a comment word)."],["StringKind","Different types of strings. We want to diff these the same way, but highlight them differently."],["Syntax",""],["TokenKind","Unlike atoms, tokens can be delimiters like `{`."]],"fn":[["change_positions","Walk `nodes` and return a vec of all the changed positions."],["change_positions_",""],["comment_positions",""],["dbg_pos",""],["filter_empty_ends","Skip line spans at the beginning or end that have zero width."],["find_nodes_with_unique_content","Assumes that `set_content_id` has already run."],["has_common_words","Are there sufficient common words that we should only highlight individual changed words?"],["init_all_info","Initialise all the fields in `SyntaxInfo`."],["init_info",""],["init_info_on_side","Set all the `SyntaxInfo` values for all the `roots` on a single side (LHS or RHS)."],["init_next_prev",""],["set_content_id",""],["set_content_is_unique",""],["set_content_is_unique_from_counts",""],["set_next_sibling",""],["set_num_after",""],["set_num_ancestors",""],["set_parent",""],["set_prev","For every syntax node in the tree, mark the previous node according to a preorder traversal."],["set_prev_sibling",""],["set_unique_id",""],["split_atom_words","Given the text `content` from a comment or strings, split it into MatchedPos values for the novel and unchanged words."],["zip_pad_shorter",""],["zip_repeat_shorter","Zip `lhs` with `rhs`, but repeat the last item from the shorter slice."]],"struct":[["MatchedPos",""],["SyntaxInfo","Fields that are common to both `Syntax::List` and `Syntax::Atom`."]],"type":[["ContentKey",""],["SyntaxId",""]]};