<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generate types for C-style flags with ergonomic APIs."><meta name="keywords" content="rust, rustlang, rust-lang, bitflags"><title>bitflags - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../bitflags/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../bitflags/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate bitflags</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 2.4.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../bitflags/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">bitflags</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/bitflags/lib.rs.html#11-922">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generate types for C-style flags with ergonomic APIs.</p>
<h2 id="getting-started"><a href="#getting-started">Getting started</a></h2>
<p>Add <code>bitflags</code> to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.bitflags]
version = &quot;2.4.2&quot;</code></pre></div><h3 id="generating-flags-types"><a href="#generating-flags-types">Generating flags types</a></h3>
<p>Use the <a href="macro.bitflags.html" title="bitflags"><code>bitflags</code></a> macro to generate flags types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitflags::bitflags;

<span class="macro">bitflags! </span>{
    <span class="kw">pub struct </span>Flags: u32 {
        <span class="kw">const </span>A = <span class="number">0b00000001</span>;
        <span class="kw">const </span>B = <span class="number">0b00000010</span>;
        <span class="kw">const </span>C = <span class="number">0b00000100</span>;
    }
}</code></pre></div>
<p>See the docs for the <code>bitflags</code> macro for the full syntax.</p>
<p>Also see the [<code>example_generated</code>] module for an example of what the <code>bitflags</code> macro generates for a flags type.</p>
<h4 id="externally-defined-flags"><a href="#externally-defined-flags">Externally defined flags</a></h4>
<p>If you’re generating flags types for an external source, such as a C API, you can define
an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (<code>!0</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">bitflags! </span>{
    <span class="kw">pub struct </span>Flags: u32 {
        <span class="kw">const </span>A = <span class="number">0b00000001</span>;
        <span class="kw">const </span>B = <span class="number">0b00000010</span>;
        <span class="kw">const </span>C = <span class="number">0b00000100</span>;

        <span class="comment">// The source may set any bits
        </span><span class="kw">const _ </span>= !<span class="number">0</span>;
    }
}</code></pre></div>
<p>Why should you do this? Generated methods like <code>all</code> and truncating operators like <code>!</code> only consider
bits in defined flags. Adding an unnamed flag makes those methods consider additional bits,
without generating additional constants for them. It helps compatibility when the external source
may start setting additional bits at any time. The <a href="#known-and-unknown-bits">known and unknown bits</a>
section has more details on this behavior.</p>
<h4 id="custom-derives"><a href="#custom-derives">Custom derives</a></h4>
<p>You can derive some traits on generated flags types if you enable Cargo features. The following
libraries are currently supported:</p>
<ul>
<li><code>serde</code>: Support <code>#[derive(Serialize, Deserialize)]</code>, using text for human-readable formats,
and a raw number for binary formats.</li>
<li><code>arbitrary</code>: Support <code>#[derive(Arbitrary)]</code>, only generating flags values with known bits.</li>
<li><code>bytemuck</code>: Support <code>#[derive(Pod, Zeroable)]</code>, for casting between flags values and their
underlying bits values.</li>
</ul>
<p>You can also define your own flags type outside of the <a href="macro.bitflags.html" title="bitflags"><code>bitflags</code></a> macro and then use it to generate methods.
This can be useful if you need a custom <code>#[derive]</code> attribute for a library that <code>bitflags</code> doesn’t
natively support:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[derive(SomeTrait)]
</span><span class="kw">pub struct </span>Flags(u32);

<span class="macro">bitflags! </span>{
    <span class="kw">impl </span>Flags: u32 {
        <span class="kw">const </span>A = <span class="number">0b00000001</span>;
        <span class="kw">const </span>B = <span class="number">0b00000010</span>;
        <span class="kw">const </span>C = <span class="number">0b00000100</span>;
    }
}</code></pre></div>
<h4 id="adding-custom-methods"><a href="#adding-custom-methods">Adding custom methods</a></h4>
<p>The <a href="macro.bitflags.html" title="bitflags"><code>bitflags</code></a> macro supports attributes on generated flags types within the macro itself, while
<code>impl</code> blocks can be added outside of it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">bitflags! </span>{
    <span class="comment">// Attributes can be applied to flags types
    </span><span class="attribute">#[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    </span><span class="kw">pub struct </span>Flags: u32 {
        <span class="kw">const </span>A = <span class="number">0b00000001</span>;
        <span class="kw">const </span>B = <span class="number">0b00000010</span>;
        <span class="kw">const </span>C = <span class="number">0b00000100</span>;
    }
}

<span class="comment">// Impl blocks can be added to flags types
</span><span class="kw">impl </span>Flags {
    <span class="kw">pub fn </span>as_u64(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; u64 {
        <span class="self">self</span>.bits() <span class="kw">as </span>u64
    }
}</code></pre></div>
<h3 id="working-with-flags-values"><a href="#working-with-flags-values">Working with flags values</a></h3>
<p>Use generated constants and standard bitwise operators to interact with flags values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// union
</span><span class="kw">let </span>ab = Flags::A | Flags::B;

<span class="comment">// intersection
</span><span class="kw">let </span>a = ab &amp; Flags::A;

<span class="comment">// difference
</span><span class="kw">let </span>b = ab - Flags::A;

<span class="comment">// complement
</span><span class="kw">let </span>c = !ab;</code></pre></div>
<p>See the docs for the <a href="trait.Flags.html" title="Flags"><code>Flags</code></a> trait for more details on operators and how they behave.</p>
<h2 id="formatting-and-parsing"><a href="#formatting-and-parsing">Formatting and parsing</a></h2>
<p><code>bitflags</code> defines a text format that can be used to convert any flags value to and from strings.</p>
<p>See the <a href="parser/index.html" title="parser"><code>parser</code></a> module for more details.</p>
<h2 id="specification"><a href="#specification">Specification</a></h2>
<p>The terminology and behavior of generated flags types is
<a href="https://github.com/bitflags/bitflags/blob/main/spec.md">specified in the source repository</a>.
Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some
things are worth calling out explicitly here.</p>
<h3 id="flags-types-flags-values-flags"><a href="#flags-types-flags-values-flags">Flags types, flags values, flags</a></h3>
<p>The spec and these docs use consistent terminology to refer to things in the bitflags domain:</p>
<ul>
<li><strong>Bits type</strong>: A type that defines a fixed number of bits at specific locations.</li>
<li><strong>Flag</strong>: A set of bits in a bits type that may have a unique name.</li>
<li><strong>Flags type</strong>: A set of defined flags over a specific bits type.</li>
<li><strong>Flags value</strong>: An instance of a flags type using its specific bits value for storage.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">bitflags! </span>{
    <span class="kw">struct </span>FlagsType: u8 {
<span class="comment">//                    -- Bits type
//         --------- Flags type
        </span><span class="kw">const </span>A = <span class="number">1</span>;
<span class="comment">//            ----- Flag
    </span>}
}

<span class="kw">let </span>flag = FlagsType::A;
<span class="comment">//  ---- Flags value</span></code></pre></div>
<h3 id="known-and-unknown-bits"><a href="#known-and-unknown-bits">Known and unknown bits</a></h3>
<p>Any bits in a flag you define are called <em>known bits</em>. Any other bits are <em>unknown bits</em>.
In the following flags type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">bitflags! </span>{
    <span class="kw">struct </span>Flags: u8 {
        <span class="kw">const </span>A = <span class="number">1</span>;
        <span class="kw">const </span>B = <span class="number">1 </span>&lt;&lt; <span class="number">1</span>;
        <span class="kw">const </span>C = <span class="number">1 </span>&lt;&lt; <span class="number">2</span>;
    }
}</code></pre></div>
<p>The known bits are <code>0b0000_0111</code> and the unknown bits are <code>0b1111_1000</code>.</p>
<p><code>bitflags</code> doesn’t guarantee that a flags value will only ever have known bits set, but some operators
will unset any unknown bits they encounter. In a future version of <code>bitflags</code>, all operators will
unset unknown bits.</p>
<p>If you’re using <code>bitflags</code> for flags types defined externally, such as from C, you probably want all
bits to be considered known, in case that external source changes. You can do this using an unnamed
flag, as described in <a href="#externally-defined-flags">externally defined flags</a>.</p>
<h3 id="zero-bit-flags"><a href="#zero-bit-flags">Zero-bit flags</a></h3>
<p>Flags with no bits set should be avoided because they interact strangely with <a href="trait.Flags.html#method.contains" title="Flags::contains"><code>Flags::contains</code></a>
and <a href="trait.Flags.html#method.intersects" title="Flags::intersects"><code>Flags::intersects</code></a>. A zero-bit flag is always contained, but is never intersected. The
names of zero-bit flags can be parsed, but are never formatted.</p>
<h3 id="multi-bit-flags"><a href="#multi-bit-flags">Multi-bit flags</a></h3>
<p>Flags that set multiple bits should be avoided unless each bit is also in a single-bit flag.
Take the following flags type as an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">bitflags! </span>{
    <span class="kw">struct </span>Flags: u8 {
        <span class="kw">const </span>A = <span class="number">1</span>;
        <span class="kw">const </span>B = <span class="number">1 </span>| <span class="number">1 </span>&lt;&lt; <span class="number">1</span>;
    }
}</code></pre></div>
<p>The result of <code>Flags::A ^ Flags::B</code> is <code>0b0000_0010</code>, which doesn’t correspond to either
<code>Flags::A</code> or <code>Flags::B</code> even though it’s still a known bit.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="iter/index.html" title="bitflags::iter mod">iter</a></div><div class="item-right docblock-short">Yield the bits of a source flags value in a set of contained flags values.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="parser/index.html" title="bitflags::parser mod">parser</a></div><div class="item-right docblock-short">Parsing flags from text.</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bitflags.html" title="bitflags::bitflags macro">bitflags</a></div><div class="item-right docblock-short">Generate a flags type.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Flag.html" title="bitflags::Flag struct">Flag</a></div><div class="item-right docblock-short">A defined flags value that may be named or unnamed.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Bits.html" title="bitflags::Bits trait">Bits</a></div><div class="item-right docblock-short">A bits type that can be used as storage for a flags type.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Flags.html" title="bitflags::Flags trait">Flags</a></div><div class="item-right docblock-short">A set of defined flags using a bits type as storage.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="bitflags" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>