<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Represents the capture groups for a single match."><title>Captures in regex::bytes - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="regex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../regex/index.html">regex</a><span class="version">1.12.2</span></h2></div><h2 class="location"><a href="#">Captures</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.expand">expand</a></li><li><a href="#method.extract">extract</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_match">get_match</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.len">len</a></li><li><a href="#method.name">name</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Captures%3C'h%3E">Debug</a></li><li><a href="#impl-Index%3C%26str%3E-for-Captures%3C'h%3E">Index&lt;&amp;&#x27;n str&gt;</a></li><li><a href="#impl-Index%3Cusize%3E-for-Captures%3C'h%3E">Index&lt;usize&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Captures%3C'h%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Captures%3C'h%3E">Send</a></li><li><a href="#impl-Sync-for-Captures%3C'h%3E">Sync</a></li><li><a href="#impl-Unpin-for-Captures%3C'h%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Captures%3C'h%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex::bytes</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../regex/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">regex</a>::<wbr><a href="index.html">bytes</a>::<wbr><a class="struct" href="#">Captures</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/regex/regex/bytes.rs.html#1632-1636">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Captures&lt;'h&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Represents the capture groups for a single match.</p>
<p>Capture groups refer to parts of a regex enclosed in parentheses. They
can be optionally named. The purpose of capture groups is to be able to
reference different parts of a match based on the original pattern. In
essence, a <code>Captures</code> is a container of <a href="struct.Match.html" title="struct regex::bytes::Match"><code>Match</code></a> values for each group
that participated in a regex match. Each <code>Match</code> can be looked up by either
its capture group index or name (if it has one).</p>
<p>For example, say you want to match the individual letters in a 5-letter
word:</p>
<div class="example-wrap"><pre class="language-text"><code>(?&lt;first&gt;\w)(\w)(?:\w)\w(?&lt;last&gt;\w)
</code></pre></div>
<p>This regex has 4 capture groups:</p>
<ul>
<li>The group at index <code>0</code> corresponds to the overall match. It is always
present in every match and never has a name.</li>
<li>The group at index <code>1</code> with name <code>first</code> corresponding to the first
letter.</li>
<li>The group at index <code>2</code> with no name corresponding to the second letter.</li>
<li>The group at index <code>3</code> with name <code>last</code> corresponding to the fifth and
last letter.</li>
</ul>
<p>Notice that <code>(?:\w)</code> was not listed above as a capture group despite it
being enclosed in parentheses. That’s because <code>(?:pattern)</code> is a special
syntax that permits grouping but <em>without</em> capturing. The reason for not
treating it as a capture is that tracking and reporting capture groups
requires additional state that may lead to slower searches. So using as few
capture groups as possible can help performance. (Although the difference
in performance of a couple of capture groups is likely immaterial.)</p>
<p>Values with this type are created by <a href="struct.Regex.html#method.captures" title="method regex::bytes::Regex::captures"><code>Regex::captures</code></a> or
<a href="struct.Regex.html#method.captures_iter" title="method regex::bytes::Regex::captures_iter"><code>Regex::captures_iter</code></a>.</p>
<p><code>'h</code> is the lifetime of the haystack that these captures were matched from.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"(?&lt;first&gt;\w)(\w)(?:\w)\w(?&lt;last&gt;\w)"</span>).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"toady"</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">b"toady"</span>, <span class="kw-2">&amp;</span>caps[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="string">b"t"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"first"</span>]);
<span class="macro">assert_eq!</span>(<span class="string">b"o"</span>, <span class="kw-2">&amp;</span>caps[<span class="number">2</span>]);
<span class="macro">assert_eq!</span>(<span class="string">b"y"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"last"</span>]);</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Captures%3C'h%3E" class="impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1638-1928">source</a><a href="#impl-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1662-1666">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'h&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>Match</code> associated with the capture group at index <code>i</code>. If
<code>i</code> does not correspond to a capture group, or if the capture group did
not participate in the match, then <code>None</code> is returned.</p>
<p>When <code>i == 0</code>, this is guaranteed to return a non-<code>None</code> value.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Get the substring that matched with a default of an empty string if the
group didn’t participate in the match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"[a-z]+(?:([0-9]+)|([A-Z]+))"</span>).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"abc123"</span>).unwrap();

<span class="kw">let </span>substr1 = caps.get(<span class="number">1</span>).map_or(<span class="kw-2">&amp;</span><span class="string">b""</span>[..], |m| m.as_bytes());
<span class="kw">let </span>substr2 = caps.get(<span class="number">2</span>).map_or(<span class="kw-2">&amp;</span><span class="string">b""</span>[..], |m| m.as_bytes());
<span class="macro">assert_eq!</span>(substr1, <span class="string">b"123"</span>);
<span class="macro">assert_eq!</span>(substr2, <span class="string">b""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_match" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1684-1686">source</a><h4 class="code-header">pub fn <a href="#method.get_match" class="fn">get_match</a>(&amp;self) -&gt; <a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'h&gt;</h4></section></summary><div class="docblock"><p>Return the overall match for the capture.</p>
<p>This returns the match for index <code>0</code>. That is it is equivalent to
<code>m.get(0).unwrap()</code></p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"[a-z]+([0-9]+)"</span>).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"   abc123-def"</span>).unwrap();

<span class="macro">assert_eq!</span>(caps.get_match().as_bytes(), <span class="string">b"abc123"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.name" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1718-1722">source</a><h4 class="code-header">pub fn <a href="#method.name" class="fn">name</a>(&amp;self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'h&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>Match</code> associated with the capture group named <code>name</code>. If
<code>name</code> isn’t a valid capture group or it refers to a group that didn’t
match, then <code>None</code> is returned.</p>
<p>Note that unlike <code>caps[&quot;name&quot;]</code>, this returns a <code>Match</code> whose lifetime
matches the lifetime of the haystack in this <code>Captures</code> value.
Conversely, the substring returned by <code>caps[&quot;name&quot;]</code> has a lifetime
of the <code>Captures</code> value, which is likely shorter than the lifetime of
the haystack. In some cases, it may be necessary to use this method to
access the matching substring instead of the <code>caps[&quot;name&quot;]</code> notation.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<p>Get the substring that matched with a default of an empty string if the
group didn’t participate in the match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(
    <span class="string">r"[a-z]+(?:(?&lt;numbers&gt;[0-9]+)|(?&lt;letters&gt;[A-Z]+))"</span>,
).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"abc123"</span>).unwrap();

<span class="kw">let </span>numbers = caps.name(<span class="string">"numbers"</span>).map_or(<span class="kw-2">&amp;</span><span class="string">b""</span>[..], |m| m.as_bytes());
<span class="kw">let </span>letters = caps.name(<span class="string">"letters"</span>).map_or(<span class="kw-2">&amp;</span><span class="string">b""</span>[..], |m| m.as_bytes());
<span class="macro">assert_eq!</span>(numbers, <span class="string">b"123"</span>);
<span class="macro">assert_eq!</span>(letters, <span class="string">b""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extract" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1804-1818">source</a><h4 class="code-header">pub fn <a href="#method.extract" class="fn">extract</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>&gt;(&amp;self) -&gt; (&amp;'h [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>], [&amp;'h [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>]; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.array.html">N</a>])</h4></section></summary><div class="docblock"><p>This is a convenience routine for extracting the substrings
corresponding to matching capture groups.</p>
<p>This returns a tuple where the first element corresponds to the full
substring of the haystack that matched the regex. The second element is
an array of substrings, with each corresponding to the substring that
matched for a particular capture group.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the number of possible matching groups in this
<code>Captures</code> value is not fixed to <code>N</code> in all circumstances.
More precisely, this routine only works when <code>N</code> is equivalent to
<a href="struct.Regex.html#method.static_captures_len" title="method regex::bytes::Regex::static_captures_len"><code>Regex::static_captures_len</code></a>.</p>
<p>Stated more plainly, if the number of matching capture groups in a
regex can vary from match to match, then this function always panics.</p>
<p>For example, <code>(a)(b)|(c)</code> could produce two matching capture groups
or one matching capture group for any given match. Therefore, one
cannot use <code>extract</code> with such a pattern.</p>
<p>But a pattern like <code>(a)(b)|(c)(d)</code> can be used with <code>extract</code> because
the number of capture groups in every match is always equivalent,
even if the capture <em>indices</em> in each match are not.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"([0-9]{4})-([0-9]{2})-([0-9]{2})"</span>).unwrap();
<span class="kw">let </span>hay = <span class="string">b"On 2010-03-14, I became a Tennessee lamb."</span>;
<span class="kw">let </span><span class="prelude-val">Some</span>((full, [year, month, day])) =
    re.captures(hay).map(|caps| caps.extract()) <span class="kw">else </span>{ <span class="kw">return </span>};
<span class="macro">assert_eq!</span>(<span class="string">b"2010-03-14"</span>, full);
<span class="macro">assert_eq!</span>(<span class="string">b"2010"</span>, year);
<span class="macro">assert_eq!</span>(<span class="string">b"03"</span>, month);
<span class="macro">assert_eq!</span>(<span class="string">b"14"</span>, day);</code></pre></div>
<h5 id="example-iteration"><a class="doc-anchor" href="#example-iteration">§</a>Example: iteration</h5>
<p>This example shows how to use this method when iterating over all
<code>Captures</code> matches in a haystack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"([0-9]{4})-([0-9]{2})-([0-9]{2})"</span>).unwrap();
<span class="kw">let </span>hay = <span class="string">b"1973-01-05, 1975-08-25 and 1980-10-18"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>dates: Vec&lt;(<span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>[u8])&gt; = <span class="macro">vec!</span>[];
<span class="kw">for </span>(<span class="kw">_</span>, [y, m, d]) <span class="kw">in </span>re.captures_iter(hay).map(|c| c.extract()) {
    dates.push((y, m, d));
}
<span class="macro">assert_eq!</span>(dates, <span class="macro">vec!</span>[
    (<span class="kw-2">&amp;</span><span class="string">b"1973"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"01"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"05"</span>[..]),
    (<span class="kw-2">&amp;</span><span class="string">b"1975"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"08"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"25"</span>[..]),
    (<span class="kw-2">&amp;</span><span class="string">b"1980"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"10"</span>[..], <span class="kw-2">&amp;</span><span class="string">b"18"</span>[..]),
]);</code></pre></div>
<h5 id="example-parsing-different-formats"><a class="doc-anchor" href="#example-parsing-different-formats">§</a>Example: parsing different formats</h5>
<p>This API is particularly useful when you need to extract a particular
value that might occur in a different format. Consider, for example,
an identifier that might be in double quotes or single quotes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r#"id:(?:"([^"]+)"|'([^']+)')"#</span>).unwrap();
<span class="kw">let </span>hay = <span class="string">br#"The first is id:"foo" and the second is id:'bar'."#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>ids = <span class="macro">vec!</span>[];
<span class="kw">for </span>(<span class="kw">_</span>, [id]) <span class="kw">in </span>re.captures_iter(hay).map(|c| c.extract()) {
    ids.push(id);
}
<span class="macro">assert_eq!</span>(ids, <span class="macro">vec!</span>[<span class="string">b"foo"</span>, <span class="string">b"bar"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expand" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1873-1875">source</a><h4 class="code-header">pub fn <a href="#method.expand" class="fn">expand</a>(&amp;self, replacement: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>], dst: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.77.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>&gt;)</h4></section></summary><div class="docblock"><p>Expands all instances of <code>$ref</code> in <code>replacement</code> to the corresponding
capture group, and writes them to the <code>dst</code> buffer given. A <code>ref</code> can
be a capture group index or a name. If <code>ref</code> doesn’t refer to a capture
group that participated in the match, then it is replaced with the
empty string.</p>
<h5 id="format"><a class="doc-anchor" href="#format">§</a>Format</h5>
<p>The format of the replacement string supports two different kinds of
capture references: unbraced and braced.</p>
<p>For the unbraced format, the format supported is <code>$ref</code> where <code>name</code>
can be any character in the class <code>[0-9A-Za-z_]</code>. <code>ref</code> is always
the longest possible parse. So for example, <code>$1a</code> corresponds to the
capture group named <code>1a</code> and not the capture group at index <code>1</code>. If
<code>ref</code> matches <code>^[0-9]+$</code>, then it is treated as a capture group index
itself and not a name.</p>
<p>For the braced format, the format supported is <code>${ref}</code> where <code>ref</code> can
be any sequence of bytes except for <code>}</code>. If no closing brace occurs,
then it is not considered a capture reference. As with the unbraced
format, if <code>ref</code> matches <code>^[0-9]+$</code>, then it is treated as a capture
group index and not a name.</p>
<p>The braced format is useful for exerting precise control over the name
of the capture reference. For example, <code>${1}a</code> corresponds to the
capture group reference <code>1</code> followed by the letter <code>a</code>, where as <code>$1a</code>
(as mentioned above) corresponds to the capture group reference <code>1a</code>.
The braced format is also useful for expressing capture group names
that use characters not supported by the unbraced format. For example,
<code>${foo[bar].baz}</code> refers to the capture group named <code>foo[bar].baz</code>.</p>
<p>If a capture group reference is found and it does not refer to a valid
capture group, then it will be replaced with the empty string.</p>
<p>To write a literal <code>$</code>, use <code>$$</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(
    <span class="string">r"(?&lt;day&gt;[0-9]{2})-(?&lt;month&gt;[0-9]{2})-(?&lt;year&gt;[0-9]{4})"</span>,
).unwrap();
<span class="kw">let </span>hay = <span class="string">b"On 14-03-2010, I became a Tennessee lamb."</span>;
<span class="kw">let </span>caps = re.captures(hay).unwrap();

<span class="kw">let </span><span class="kw-2">mut </span>dst = <span class="macro">vec!</span>[];
caps.expand(<span class="string">b"year=$year, month=$month, day=$day"</span>, <span class="kw-2">&amp;mut </span>dst);
<span class="macro">assert_eq!</span>(dst, <span class="string">b"year=2010, month=03, day=14"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1903-1905">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>&lt;'c&gt;(&amp;'c self) -&gt; <a class="struct" href="struct.SubCaptureMatches.html" title="struct regex::bytes::SubCaptureMatches">SubCaptureMatches</a>&lt;'c, 'h&gt; <a href="#" class="tooltip" data-notable-ty="SubCaptureMatches&lt;&#39;c, &#39;h&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all capture groups. This includes both
matching and non-matching groups.</p>
<p>The iterator always yields at least one matching group: the first group
(at index <code>0</code>) with no name. Subsequent groups are returned in the order
of their opening parenthesis in the regex.</p>
<p>The elements yielded have type <code>Option&lt;Match&lt;'h&gt;&gt;</code>, where a non-<code>None</code>
value is present if the capture group matches.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"(\w)(\d)?(\w)"</span>).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"AZ"</span>).unwrap();

<span class="kw">let </span><span class="kw-2">mut </span>it = caps.iter();
<span class="macro">assert_eq!</span>(it.next().unwrap().map(|m| m.as_bytes()), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b"AZ"</span>[..]));
<span class="macro">assert_eq!</span>(it.next().unwrap().map(|m| m.as_bytes()), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b"A"</span>[..]));
<span class="macro">assert_eq!</span>(it.next().unwrap().map(|m| m.as_bytes()), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(it.next().unwrap().map(|m| m.as_bytes()), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b"Z"</span>[..]));
<span class="macro">assert_eq!</span>(it.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1925-1927">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of capture groups. This includes both
matching and non-matching groups.</p>
<p>The length returned is always equivalent to the number of elements
yielded by <a href="struct.Captures.html#method.iter" title="method regex::bytes::Captures::iter"><code>Captures::iter</code></a>. Consequently, the length is always
greater than zero since every <code>Captures</code> value always includes the
match for the entire regex.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">r"(\w)(\d)?(\w)"</span>).unwrap();
<span class="kw">let </span>caps = re.captures(<span class="string">b"AZ"</span>).unwrap();
<span class="macro">assert_eq!</span>(caps.len(), <span class="number">4</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Captures%3C'h%3E" class="impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1930-1991">source</a><a href="#impl-Debug-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#1931-1990">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.77.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.77.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3C%26str%3E-for-Captures%3C'h%3E" class="impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#2035-2043">source</a><a href="#impl-Index%3C%26str%3E-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h, 'n&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;&amp;'n <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section></summary><div class="docblock"><p>Get a matching capture group’s haystack substring by name.</p>
<p>The haystack substring returned can’t outlive the <code>Captures</code> object if this
method is used, because of how <code>Index</code> is defined (normally <code>a[i]</code> is part
of <code>a</code> and can’t outlive it). To work around this limitation, do that, use
<a href="struct.Captures.html#method.name" title="method regex::bytes::Captures::name"><code>Captures::name</code></a> instead.</p>
<p><code>'h</code> is the lifetime of the matched haystack, but the lifetime of the
<code>&amp;str</code> returned by this implementation is the lifetime of the <code>Captures</code>
value itself.</p>
<p><code>'n</code> is the lifetime of the group name used to index the <code>Captures</code> value.</p>
<h4 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h4>
<p>If there is no matching group at the given name.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>]</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#2038-2042">source</a><a href="#method.index" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#tymethod.index" class="fn">index</a>&lt;'a&gt;(&amp;'a self, name: &amp;'n <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.str.html">str</a>) -&gt; &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;&#39;a [u8]">ⓘ</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3Cusize%3E-for-Captures%3C'h%3E" class="impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#2007-2017">source</a><a href="#impl-Index%3Cusize%3E-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section></summary><div class="docblock"><p>Get a matching capture group’s haystack substring by index.</p>
<p>The haystack substring returned can’t outlive the <code>Captures</code> object if this
method is used, because of how <code>Index</code> is defined (normally <code>a[i]</code> is part
of <code>a</code> and can’t outlive it). To work around this limitation, do that, use
<a href="struct.Captures.html#method.get" title="method regex::bytes::Captures::get"><code>Captures::get</code></a> instead.</p>
<p><code>'h</code> is the lifetime of the matched haystack, but the lifetime of the
<code>&amp;str</code> returned by this implementation is the lifetime of the <code>Captures</code>
value itself.</p>
<h4 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h4>
<p>If there is no matching group at the given index.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>]</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl"><a class="src rightside" href="../../src/regex/regex/bytes.rs.html#2012-2016">source</a><a href="#method.index-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#tymethod.index" class="fn">index</a>&lt;'a&gt;(&amp;'a self, i: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.usize.html">usize</a>) -&gt; &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;&#39;a [u8]">ⓘ</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.77.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Captures%3C'h%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section><section id="impl-Send-for-Captures%3C'h%3E" class="impl"><a href="#impl-Send-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section><section id="impl-Sync-for-Captures%3C'h%3E" class="impl"><a href="#impl-Sync-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section><section id="impl-Unpin-for-Captures%3C'h%3E" class="impl"><a href="#impl-Unpin-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section><section id="impl-UnwindSafe-for-Captures%3C'h%3E" class="impl"><a href="#impl-UnwindSafe-for-Captures%3C'h%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'h&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.77.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.77.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.77.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.77.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#764">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#767">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#757">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#804-806">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#811">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#789-791">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.77.0/src/core/convert/mod.rs.html#796">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.77.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.77.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&'a [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.0/std/primitive.u8.html\">u8</a>]</div>","SubCaptureMatches<'c, 'h>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SubCaptureMatches.html\" title=\"struct regex::bytes::SubCaptureMatches\">SubCaptureMatches</a>&lt;'c, 'h&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'c, 'h&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SubCaptureMatches.html\" title=\"struct regex::bytes::SubCaptureMatches\">SubCaptureMatches</a>&lt;'c, 'h&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.77.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"struct.Match.html\" title=\"struct regex::bytes::Match\">Match</a>&lt;'h&gt;&gt;;</div>"}</script></section></div></main></body></html>