<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A configurable builder for a `Regex`."><title>RegexBuilder in regex - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="regex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../regex/index.html">regex</a><span class="version">1.11.1</span></h2></div><h2 class="location"><a href="#">RegexBuilder</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.build">build</a></li><li><a href="#method.case_insensitive">case_insensitive</a></li><li><a href="#method.crlf">crlf</a></li><li><a href="#method.dfa_size_limit">dfa_size_limit</a></li><li><a href="#method.dot_matches_new_line">dot_matches_new_line</a></li><li><a href="#method.ignore_whitespace">ignore_whitespace</a></li><li><a href="#method.line_terminator">line_terminator</a></li><li><a href="#method.multi_line">multi_line</a></li><li><a href="#method.nest_limit">nest_limit</a></li><li><a href="#method.new">new</a></li><li><a href="#method.octal">octal</a></li><li><a href="#method.size_limit">size_limit</a></li><li><a href="#method.swap_greed">swap_greed</a></li><li><a href="#method.unicode">unicode</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-RegexBuilder">Clone</a></li><li><a href="#impl-Debug-for-RegexBuilder">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-RegexBuilder">RefUnwindSafe</a></li><li><a href="#impl-Send-for-RegexBuilder">Send</a></li><li><a href="#impl-Sync-for-RegexBuilder">Sync</a></li><li><a href="#impl-Unpin-for-RegexBuilder">Unpin</a></li><li><a href="#impl-UnwindSafe-for-RegexBuilder">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate regex</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../regex/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">regex</a>::<wbr><a class="struct" href="#">RegexBuilder</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/regex/builders.rs.html#212-214">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct RegexBuilder { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A configurable builder for a <a href="struct.Regex.html" title="struct regex::Regex"><code>Regex</code></a>.</p>
<p>This builder can be used to programmatically set flags such as <code>i</code>
(case insensitive) and <code>x</code> (for verbose mode). This builder can also be
used to configure things like the line terminator and a size limit on
the compiled regular expression.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RegexBuilder" class="impl"><a class="src rightside" href="../src/regex/builders.rs.html#216-778">source</a><a href="#impl-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#223-225">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>Create a new builder with a default configuration for the given
pattern.</p>
<p>If the pattern is invalid or exceeds the configured size limits,
then an error will be returned when <a href="struct.RegexBuilder.html#method.build" title="method regex::RegexBuilder::build"><code>RegexBuilder::build</code></a> is
called.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#232-234">source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex::Regex">Regex</a>, <a class="enum" href="enum.Error.html" title="enum regex::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Compiles the pattern given to <code>RegexBuilder::new</code> with the
configuration set on this builder.</p>
<p>If the pattern isn’t a valid regex or if a configured size limit
was exceeded, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unicode" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#293-296">source</a><h4 class="code-header">pub fn <a href="#method.unicode" class="fn">unicode</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures Unicode mode for the entire pattern.</p>
<p>Enabling Unicode mode does a number of things:</p>
<ul>
<li>Most fundamentally, it causes the fundamental atom of matching
to be a single codepoint. When Unicode mode is disabled, it’s a
single byte. For example, when Unicode mode is enabled, <code>.</code> will
match <code>💩</code> once, where as it will match 4 times when Unicode mode
is disabled. (Since the UTF-8 encoding of <code>💩</code> is 4 bytes long.)</li>
<li>Case insensitive matching uses Unicode simple case folding rules.</li>
<li>Unicode character classes like <code>\p{Letter}</code> and <code>\p{Greek}</code> are
available.</li>
<li>Perl character classes are Unicode aware. That is, <code>\w</code>, <code>\s</code> and
<code>\d</code>.</li>
<li>The word boundary assertions, <code>\b</code> and <code>\B</code>, use the Unicode
definition of a word character.</li>
</ul>
<p>Note that if Unicode mode is disabled, then the regex will fail to
compile if it could match invalid UTF-8. For example, when Unicode
mode is disabled, then since <code>.</code> matches any byte (except for
<code>\n</code>), then it can match invalid UTF-8 and thus building a regex
from it will fail. Another example is <code>\w</code> and <code>\W</code>. Since <code>\w</code> can
only match ASCII bytes when Unicode mode is disabled, it’s allowed.
But <code>\W</code> can match more than ASCII bytes, including invalid UTF-8,
and so it is not allowed. This restriction can be lifted only by
using a <a href="bytes/struct.Regex.html" title="struct regex::bytes::Regex"><code>bytes::Regex</code></a>.</p>
<p>For more details on the Unicode support in this crate, see the
<a href="index.html#unicode" title="mod regex">Unicode section</a> in this crate’s top-level
documentation.</p>
<p>The default for this is <code>true</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"\w"</span>)
    .unicode(<span class="bool-val">false</span>)
    .build()
    .unwrap();
<span class="comment">// Normally greek letters would be included in \w, but since
// Unicode mode is disabled, it only matches ASCII letters.
</span><span class="macro">assert!</span>(!re.is_match(<span class="string">"δ"</span>));

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"s"</span>)
    .case_insensitive(<span class="bool-val">true</span>)
    .unicode(<span class="bool-val">false</span>)
    .build()
    .unwrap();
<span class="comment">// Normally 'ſ' is included when searching for 's' case
// insensitively due to Unicode's simple case folding rules. But
// when Unicode mode is disabled, only ASCII case insensitive rules
// are used.
</span><span class="macro">assert!</span>(!re.is_match(<span class="string">"ſ"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.case_insensitive" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#322-325">source</a><h4 class="code-header">pub fn <a href="#method.case_insensitive" class="fn">case_insensitive</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures whether to enable case insensitive matching for the
entire pattern.</p>
<p>This setting can also be configured using the inline flag <code>i</code>
in the pattern. For example, <code>(?i:foo)</code> matches <code>foo</code> case
insensitively while <code>(?-i:foo)</code> matches <code>foo</code> case sensitively.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"foo(?-i:bar)quux"</span>)
    .case_insensitive(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="macro">assert!</span>(re.is_match(<span class="string">"FoObarQuUx"</span>));
<span class="comment">// Even though case insensitive matching is enabled in the builder,
// it can be locally disabled within the pattern. In this case,
// `bar` is matched case sensitively.
</span><span class="macro">assert!</span>(!re.is_match(<span class="string">"fooBARquux"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.multi_line" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#361-364">source</a><h4 class="code-header">pub fn <a href="#method.multi_line" class="fn">multi_line</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures multi-line mode for the entire pattern.</p>
<p>Enabling multi-line mode changes the behavior of the <code>^</code> and <code>$</code>
anchor assertions. Instead of only matching at the beginning and
end of a haystack, respectively, multi-line mode causes them to
match at the beginning and end of a line <em>in addition</em> to the
beginning and end of a haystack. More precisely, <code>^</code> will match at
the position immediately following a <code>\n</code> and <code>$</code> will match at the
position immediately preceding a <code>\n</code>.</p>
<p>The behavior of this option can be impacted by other settings too:</p>
<ul>
<li>The <a href="struct.RegexBuilder.html#method.line_terminator" title="method regex::RegexBuilder::line_terminator"><code>RegexBuilder::line_terminator</code></a> option changes <code>\n</code> above
to any ASCII byte.</li>
<li>The <a href="struct.RegexBuilder.html#method.crlf" title="method regex::RegexBuilder::crlf"><code>RegexBuilder::crlf</code></a> option changes the line terminator to
be either <code>\r</code> or <code>\n</code>, but never at the position between a <code>\r</code>
and <code>\n</code>.</li>
</ul>
<p>This setting can also be configured using the inline flag <code>m</code> in
the pattern.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"^foo$"</span>)
    .multi_line(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>..<span class="number">4</span>), re.find(<span class="string">"\nfoo\n"</span>).map(|m| m.range()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dot_matches_new_line" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#392-398">source</a><h4 class="code-header">pub fn <a href="#method.dot_matches_new_line" class="fn">dot_matches_new_line</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures dot-matches-new-line mode for the entire pattern.</p>
<p>Perhaps surprisingly, the default behavior for <code>.</code> is not to match
any character, but rather, to match any character except for the
line terminator (which is <code>\n</code> by default). When this mode is
enabled, the behavior changes such that <code>.</code> truly matches any
character.</p>
<p>This setting can also be configured using the inline flag <code>s</code> in
the pattern. For example, <code>(?s:.)</code> and <code>\p{any}</code> are equivalent
regexes.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"foo.bar"</span>)
    .dot_matches_new_line(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="kw">let </span>hay = <span class="string">"foo\nbar"</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo\nbar"</span>), re.find(hay).map(|m| m.as_str()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.crlf" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#450-453">source</a><h4 class="code-header">pub fn <a href="#method.crlf" class="fn">crlf</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures CRLF mode for the entire pattern.</p>
<p>When CRLF mode is enabled, both <code>\r</code> (“carriage return” or CR for
short) and <code>\n</code> (“line feed” or LF for short) are treated as line
terminators. This results in the following:</p>
<ul>
<li>Unless dot-matches-new-line mode is enabled, <code>.</code> will now match
any character except for <code>\n</code> and <code>\r</code>.</li>
<li>When multi-line mode is enabled, <code>^</code> will match immediately
following a <code>\n</code> or a <code>\r</code>. Similarly, <code>$</code> will match immediately
preceding a <code>\n</code> or a <code>\r</code>. Neither <code>^</code> nor <code>$</code> will ever match
between <code>\r</code> and <code>\n</code>.</li>
</ul>
<p>This setting can also be configured using the inline flag <code>R</code> in
the pattern.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"^foo$"</span>)
    .multi_line(<span class="bool-val">true</span>)
    .crlf(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="kw">let </span>hay = <span class="string">"\r\nfoo\r\n"</span>;
<span class="comment">// If CRLF mode weren't enabled here, then '$' wouldn't match
// immediately after 'foo', and thus no match would be found.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), re.find(hay).map(|m| m.as_str()));</code></pre></div>
<p>This example demonstrates that <code>^</code> will never match at a position
between <code>\r</code> and <code>\n</code>. (<code>$</code> will similarly not match between a <code>\r</code>
and a <code>\n</code>.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"^"</span>)
    .multi_line(<span class="bool-val">true</span>)
    .crlf(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="kw">let </span>hay = <span class="string">"\r\n\r\n"</span>;
<span class="kw">let </span>ranges: Vec&lt;<span class="kw">_</span>&gt; = re.find_iter(hay).map(|m| m.range()).collect();
<span class="macro">assert_eq!</span>(ranges, <span class="macro">vec!</span>[<span class="number">0</span>..<span class="number">0</span>, <span class="number">2</span>..<span class="number">2</span>, <span class="number">4</span>..<span class="number">4</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.line_terminator" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#521-524">source</a><h4 class="code-header">pub fn <a href="#method.line_terminator" class="fn">line_terminator</a>(&amp;mut self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u8.html">u8</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>Configures the line terminator to be used by the regex.</p>
<p>The line terminator is relevant in two ways for a particular regex:</p>
<ul>
<li>When dot-matches-new-line mode is <em>not</em> enabled (the default),
then <code>.</code> will match any character except for the configured line
terminator.</li>
<li>When multi-line mode is enabled (not the default), then <code>^</code> and
<code>$</code> will match immediately after and before, respectively, a line
terminator.</li>
</ul>
<p>In both cases, if CRLF mode is enabled in a particular context,
then it takes precedence over any configured line terminator.</p>
<p>This option cannot be configured from within the pattern.</p>
<p>The default line terminator is <code>\n</code>.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>This shows how to treat the NUL byte as a line terminator. This can
be a useful heuristic when searching binary data.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"^foo$"</span>)
    .multi_line(<span class="bool-val">true</span>)
    .line_terminator(<span class="string">b'\x00'</span>)
    .build()
    .unwrap();
<span class="kw">let </span>hay = <span class="string">"\x00foo\x00"</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>..<span class="number">4</span>), re.find(hay).map(|m| m.range()));</code></pre></div>
<p>This example shows that the behavior of <code>.</code> is impacted by this
setting as well:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"."</span>)
    .line_terminator(<span class="string">b'\x00'</span>)
    .build()
    .unwrap();
<span class="macro">assert!</span>(re.is_match(<span class="string">"\n"</span>));
<span class="macro">assert!</span>(!re.is_match(<span class="string">"\x00"</span>));</code></pre></div>
<p>This shows that building a regex will fail if the byte given
is not ASCII and the pattern could result in matching invalid
UTF-8. This is because any singular non-ASCII byte is not valid
UTF-8, and it is not permitted for a <a href="struct.Regex.html" title="struct regex::Regex"><code>Regex</code></a> to match invalid
UTF-8. (It is permissible to use a non-ASCII byte when building a
<a href="bytes/struct.Regex.html" title="struct regex::bytes::Regex"><code>bytes::Regex</code></a>.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="macro">assert!</span>(RegexBuilder::new(<span class="string">r"."</span>).line_terminator(<span class="number">0x80</span>).build().is_err());
<span class="comment">// Note that using a non-ASCII byte isn't enough on its own to
// cause regex compilation to fail. You actually have to make use
// of it in the regex in a way that leads to matching invalid
// UTF-8. If you don't, then regex compilation will succeed!
</span><span class="macro">assert!</span>(RegexBuilder::new(<span class="string">r"a"</span>).line_terminator(<span class="number">0x80</span>).build().is_ok());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_greed" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#548-551">source</a><h4 class="code-header">pub fn <a href="#method.swap_greed" class="fn">swap_greed</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures swap-greed mode for the entire pattern.</p>
<p>When swap-greed mode is enabled, patterns like <code>a+</code> will become
non-greedy and patterns like <code>a+?</code> will become greedy. In other
words, the meanings of <code>a+</code> and <code>a+?</code> are switched.</p>
<p>This setting can also be configured using the inline flag <code>U</code> in
the pattern.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"a+"</span>)
    .swap_greed(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), re.find(<span class="string">"aaa"</span>).map(|m| m.as_str()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ignore_whitespace" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#616-619">source</a><h4 class="code-header">pub fn <a href="#method.ignore_whitespace" class="fn">ignore_whitespace</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures verbose mode for the entire pattern.</p>
<p>When enabled, whitespace will treated as insignifcant in the
pattern and <code>#</code> can be used to start a comment until the next new
line.</p>
<p>Normally, in most places in a pattern, whitespace is treated
literally. For example <code> +</code> will match one or more ASCII whitespace
characters.</p>
<p>When verbose mode is enabled, <code>\#</code> can be used to match a literal
<code>#</code> and <code>\ </code> can be used to match a literal ASCII whitespace
character.</p>
<p>Verbose mode is useful for permitting regexes to be formatted and
broken up more nicely. This may make them more easily readable.</p>
<p>This setting can also be configured using the inline flag <code>x</code> in
the pattern.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="kw">let </span>pat = <span class="string">r"
    \b
    (?&lt;first&gt;\p{Uppercase}\w*)  # always start with uppercase letter
    [\s--\n]+                   # whitespace should separate names
    (?: # middle name can be an initial!
        (?:(?&lt;initial&gt;\p{Uppercase})\.|(?&lt;middle&gt;\p{Uppercase}\w*))
        [\s--\n]+
    )?
    (?&lt;last&gt;\p{Uppercase}\w*)
    \b
"</span>;
<span class="kw">let </span>re = RegexBuilder::new(pat)
    .ignore_whitespace(<span class="bool-val">true</span>)
    .build()
    .unwrap();

<span class="kw">let </span>caps = re.captures(<span class="string">"Harry Potter"</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Harry"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"first"</span>]);
<span class="macro">assert_eq!</span>(<span class="string">"Potter"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"last"</span>]);

<span class="kw">let </span>caps = re.captures(<span class="string">"Harry J. Potter"</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Harry"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"first"</span>]);
<span class="comment">// Since a middle name/initial isn't required for an overall match,
// we can't assume that 'initial' or 'middle' will be populated!
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"J"</span>), caps.name(<span class="string">"initial"</span>).map(|m| m.as_str()));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.name(<span class="string">"middle"</span>).map(|m| m.as_str()));
<span class="macro">assert_eq!</span>(<span class="string">"Potter"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"last"</span>]);

<span class="kw">let </span>caps = re.captures(<span class="string">"Harry James Potter"</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Harry"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"first"</span>]);
<span class="comment">// Since a middle name/initial isn't required for an overall match,
// we can't assume that 'initial' or 'middle' will be populated!
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, caps.name(<span class="string">"initial"</span>).map(|m| m.as_str()));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"James"</span>), caps.name(<span class="string">"middle"</span>).map(|m| m.as_str()));
<span class="macro">assert_eq!</span>(<span class="string">"Potter"</span>, <span class="kw-2">&amp;</span>caps[<span class="string">"last"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.octal" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#651-654">source</a><h4 class="code-header">pub fn <a href="#method.octal" class="fn">octal</a>(&amp;mut self, yes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.bool.html">bool</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>This configures octal mode for the entire pattern.</p>
<p>Octal syntax is a little-known way of uttering Unicode codepoints
in a pattern. For example, <code>a</code>, <code>\x61</code>, <code>\u0061</code> and <code>\141</code> are all
equivalent patterns, where the last example shows octal syntax.</p>
<p>While supporting octal syntax isn’t in and of itself a problem,
it does make good error messages harder. That is, in PCRE based
regex engines, syntax like <code>\1</code> invokes a backreference, which is
explicitly unsupported this library. However, many users expect
backreferences to be supported. Therefore, when octal support
is disabled, the error message will explicitly mention that
backreferences aren’t supported.</p>
<p>The default for this is <code>false</code>.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="comment">// Normally this pattern would not compile, with an error message
// about backreferences not being supported. But with octal mode
// enabled, octal escape sequences work.
</span><span class="kw">let </span>re = RegexBuilder::new(<span class="string">r"\141"</span>)
    .octal(<span class="bool-val">true</span>)
    .build()
    .unwrap();
<span class="macro">assert!</span>(re.is_match(<span class="string">"a"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size_limit" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#690-693">source</a><h4 class="code-header">pub fn <a href="#method.size_limit" class="fn">size_limit</a>(&amp;mut self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.usize.html">usize</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>Sets the approximate size limit, in bytes, of the compiled regex.</p>
<p>This roughly corresponds to the number of heap memory, in
bytes, occupied by a single regex. If the regex would otherwise
approximately exceed this limit, then compiling that regex will
fail.</p>
<p>The main utility of a method like this is to avoid compiling
regexes that use an unexpected amount of resources, such as
time and memory. Even if the memory usage of a large regex is
acceptable, its search time may not be. Namely, worst case time
complexity for search is <code>O(m * n)</code>, where <code>m ~ len(pattern)</code> and
<code>n ~ len(haystack)</code>. That is, search time depends, in part, on the
size of the compiled regex. This means that putting a limit on the
size of the regex limits how much a regex can impact search time.</p>
<p>For more information about regex size limits, see the section on
<a href="index.html#untrusted-input" title="mod regex">untrusted inputs</a> in the top-level crate
documentation.</p>
<p>The default for this is some reasonable number that permits most
patterns to compile successfully.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="comment">// It may surprise you how big some seemingly small patterns can
// be! Since \w is Unicode aware, this generates a regex that can
// match approximately 140,000 distinct codepoints.
</span><span class="macro">assert!</span>(RegexBuilder::new(<span class="string">r"\w"</span>).size_limit(<span class="number">45_000</span>).build().is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dfa_size_limit" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#733-736">source</a><h4 class="code-header">pub fn <a href="#method.dfa_size_limit" class="fn">dfa_size_limit</a>(&amp;mut self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.usize.html">usize</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>Set the approximate capacity, in bytes, of the cache of transitions
used by the lazy DFA.</p>
<p>While the lazy DFA isn’t always used, in tends to be the most
commonly use regex engine in default configurations. It tends to
adopt the performance profile of a fully build DFA, but without the
downside of taking worst case exponential time to build.</p>
<p>The downside is that it needs to keep a cache of transitions and
states that are built while running a search, and this cache
can fill up. When it fills up, the cache will reset itself. Any
previously generated states and transitions will then need to be
re-generated. If this happens too many times, then this library
will bail out of using the lazy DFA and switch to a different regex
engine.</p>
<p>If your regex provokes this particular downside of the lazy DFA,
then it may be beneficial to increase its cache capacity. This will
potentially reduce the frequency of cache resetting (ideally to
<code>0</code>). While it won’t fix all potential performance problems with
the lazy DFA, increasing the cache capacity does fix some.</p>
<p>There is no easy way to determine, a priori, whether increasing
this cache capacity will help. In general, the larger your regex,
the more cache it’s likely to use. But that isn’t an ironclad rule.
For example, a regex like <code>[01]*1[01]{N}</code> would normally produce a
fully build DFA that is exponential in size with respect to <code>N</code>.
The lazy DFA will prevent exponential space blow-up, but it cache
is likely to fill up, even when it’s large and even for smallish
values of <code>N</code>.</p>
<p>If you aren’t sure whether this helps or not, it is sensible to
set this to some arbitrarily large number in testing, such as
<code>usize::MAX</code>. Namely, this represents the amount of capacity that
<em>may</em> be used. It’s probably not a good idea to use <code>usize::MAX</code> in
production though, since it implies there are no controls on heap
memory used by this library during a search. In effect, set it to
whatever you’re willing to allocate for a single regex search.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nest_limit" class="method"><a class="src rightside" href="../src/regex/builders.rs.html#774-777">source</a><h4 class="code-header">pub fn <a href="#method.nest_limit" class="fn">nest_limit</a>(&amp;mut self, limit: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u32.html">u32</a>) -&gt; &amp;mut <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class="docblock"><p>Set the nesting limit for this parser.</p>
<p>The nesting limit controls how deep the abstract syntax tree is
allowed to be. If the AST exceeds the given limit (e.g., with too
many nested groups), then an error is returned by the parser.</p>
<p>The purpose of this limit is to act as a heuristic to prevent stack
overflow for consumers that do structural induction on an AST using
explicit recursion. While this crate never does this (instead using
constant stack space and moving the call stack to the heap), other
crates may.</p>
<p>This limit is not checked until the entire AST is parsed.
Therefore, if callers want to put a limit on the amount of heap
space used, then they should impose a limit on the length, in
bytes, of the concrete pattern string. In particular, this is
viable since this parser implementation will limit itself to heap
space proportional to the length of the pattern string. See also
the <a href="index.html#untrusted-input" title="mod regex">untrusted inputs</a> section in the
top-level crate documentation for more information about this.</p>
<p>Note that a nest limit of <code>0</code> will return a nest limit error for
most patterns but not all. For example, a nest limit of <code>0</code> permits
<code>a</code> but not <code>ab</code>, since <code>ab</code> requires an explicit concatenation,
which results in a nest depth of <code>1</code>. In general, a nest limit is
not something that manifests in an obvious way in the concrete
syntax, therefore, it should not be used in a granular way.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexBuilder;

<span class="macro">assert!</span>(RegexBuilder::new(<span class="string">r"a"</span>).nest_limit(<span class="number">0</span>).build().is_ok());
<span class="macro">assert!</span>(RegexBuilder::new(<span class="string">r"ab"</span>).nest_limit(<span class="number">0</span>).build().is_err());</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-RegexBuilder" class="impl"><a class="src rightside" href="../src/regex/builders.rs.html#211">source</a><a href="#impl-Clone-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/regex/builders.rs.html#211">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.76.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RegexBuilder" class="impl"><a class="src rightside" href="../src/regex/builders.rs.html#211">source</a><a href="#impl-Debug-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/regex/builders.rs.html#211">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.76.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.76.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-RegexBuilder" class="impl"><a href="#impl-RefUnwindSafe-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section><section id="impl-Send-for-RegexBuilder" class="impl"><a href="#impl-Send-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section><section id="impl-Sync-for-RegexBuilder" class="impl"><a href="#impl-Sync-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section><section id="impl-Unpin-for-RegexBuilder" class="impl"><a href="#impl-Unpin-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section><section id="impl-UnwindSafe-for-RegexBuilder" class="impl"><a href="#impl-UnwindSafe-for-RegexBuilder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.RegexBuilder.html" title="struct regex::RegexBuilder">RegexBuilder</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.76.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.76.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.76.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.76.0/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.76.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.76.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>