<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `PARSER_HEADER` constant in crate `tree_sitter`."><title>PARSER_HEADER in tree_sitter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tree_sitter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tree_sitter/index.html">tree_sitter</a><span class="version">0.26.3</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../tree_sitter/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="index.html">tree_sitter</a>::<wbr><a class="constant" href="#">PARSER_HEADER</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/tree_sitter/lib.rs.html#55">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub const PARSER_HEADER: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.str.html">str</a> = &quot;#ifndef TREE_SITTER_PARSER_H_\n#define TREE_SITTER_PARSER_H_\n\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define ts_builtin_sym_error ((TSSymbol)-1)\n#define ts_builtin_sym_end 0\n#define TREE_SITTER_SERIALIZATION_BUFFER_SIZE 1024\n\n#ifndef TREE_SITTER_API_H_\ntypedef uint16_t TSStateId;\ntypedef uint16_t TSSymbol;\ntypedef uint16_t TSFieldId;\ntypedef struct TSLanguage TSLanguage;\ntypedef struct TSLanguageMetadata {\n  uint8_t major_version;\n  uint8_t minor_version;\n  uint8_t patch_version;\n} TSLanguageMetadata;\n#endif\n\ntypedef struct {\n  TSFieldId field_id;\n  uint8_t child_index;\n  bool inherited;\n} TSFieldMapEntry;\n\n// Used to index the field and supertype maps.\ntypedef struct {\n  uint16_t index;\n  uint16_t length;\n} TSMapSlice;\n\ntypedef struct {\n  bool visible;\n  bool named;\n  bool supertype;\n} TSSymbolMetadata;\n\ntypedef struct TSLexer TSLexer;\n\nstruct TSLexer {\n  int32_t lookahead;\n  TSSymbol result_symbol;\n  void (*advance)(TSLexer *, bool);\n  void (*mark_end)(TSLexer *);\n  uint32_t (*get_column)(TSLexer *);\n  bool (*is_at_included_range_start)(const TSLexer *);\n  bool (*eof)(const TSLexer *);\n  void (*log)(const TSLexer *, const char *, ...);\n};\n\ntypedef enum {\n  TSParseActionTypeShift,\n  TSParseActionTypeReduce,\n  TSParseActionTypeAccept,\n  TSParseActionTypeRecover,\n} TSParseActionType;\n\ntypedef union {\n  struct {\n    uint8_t type;\n    TSStateId state;\n    bool extra;\n    bool repetition;\n  } shift;\n  struct {\n    uint8_t type;\n    uint8_t child_count;\n    TSSymbol symbol;\n    int16_t dynamic_precedence;\n    uint16_t production_id;\n  } reduce;\n  uint8_t type;\n} TSParseAction;\n\ntypedef struct {\n  uint16_t lex_state;\n  uint16_t external_lex_state;\n} TSLexMode;\n\ntypedef struct {\n  uint16_t lex_state;\n  uint16_t external_lex_state;\n  uint16_t reserved_word_set_id;\n} TSLexerMode;\n\ntypedef union {\n  TSParseAction action;\n  struct {\n    uint8_t count;\n    bool reusable;\n  } entry;\n} TSParseActionEntry;\n\ntypedef struct {\n  int32_t start;\n  int32_t end;\n} TSCharacterRange;\n\nstruct TSLanguage {\n  uint32_t abi_version;\n  uint32_t symbol_count;\n  uint32_t alias_count;\n  uint32_t token_count;\n  uint32_t external_token_count;\n  uint32_t state_count;\n  uint32_t large_state_count;\n  uint32_t production_id_count;\n  uint32_t field_count;\n  uint16_t max_alias_sequence_length;\n  const uint16_t *parse_table;\n  const uint16_t *small_parse_table;\n  const uint32_t *small_parse_table_map;\n  const TSParseActionEntry *parse_actions;\n  const char * const *symbol_names;\n  const char * const *field_names;\n  const TSMapSlice *field_map_slices;\n  const TSFieldMapEntry *field_map_entries;\n  const TSSymbolMetadata *symbol_metadata;\n  const TSSymbol *public_symbol_map;\n  const uint16_t *alias_map;\n  const TSSymbol *alias_sequences;\n  const TSLexerMode *lex_modes;\n  bool (*lex_fn)(TSLexer *, TSStateId);\n  bool (*keyword_lex_fn)(TSLexer *, TSStateId);\n  TSSymbol keyword_capture_token;\n  struct {\n    const bool *states;\n    const TSSymbol *symbol_map;\n    void *(*create)(void);\n    void (*destroy)(void *);\n    bool (*scan)(void *, TSLexer *, const bool *symbol_whitelist);\n    unsigned (*serialize)(void *, char *);\n    void (*deserialize)(void *, const char *, unsigned);\n  } external_scanner;\n  const TSStateId *primary_state_ids;\n  const char *name;\n  const TSSymbol *reserved_words;\n  uint16_t max_reserved_word_set_size;\n  uint32_t supertype_count;\n  const TSSymbol *supertype_symbols;\n  const TSMapSlice *supertype_map_slices;\n  const TSSymbol *supertype_map_entries;\n  TSLanguageMetadata metadata;\n};\n\nstatic inline bool set_contains(const TSCharacterRange *ranges, uint32_t len, int32_t lookahead) {\n  uint32_t index = 0;\n  uint32_t size = len - index;\n  while (size &gt; 1) {\n    uint32_t half_size = size / 2;\n    uint32_t mid_index = index + half_size;\n    const TSCharacterRange *range = &amp;ranges[mid_index];\n    if (lookahead &gt;= range-&gt;start &amp;&amp; lookahead &lt;= range-&gt;end) {\n      return true;\n    } else if (lookahead &gt; range-&gt;end) {\n      index = mid_index;\n    }\n    size -= half_size;\n  }\n  const TSCharacterRange *range = &amp;ranges[index];\n  return (lookahead &gt;= range-&gt;start &amp;&amp; lookahead &lt;= range-&gt;end);\n}\n\n/*\n *  Lexer Macros\n */\n\n#ifdef _MSC_VER\n#define UNUSED __pragma(warning(suppress : 4101))\n#else\n#define UNUSED __attribute__((unused))\n#endif\n\n#define START_LEXER()           \\\n  bool result = false;          \\\n  bool skip = false;            \\\n  UNUSED                        \\\n  bool eof = false;             \\\n  int32_t lookahead;            \\\n  goto start;                   \\\n  next_state:                   \\\n  lexer-&gt;advance(lexer, skip);  \\\n  start:                        \\\n  skip = false;                 \\\n  lookahead = lexer-&gt;lookahead;\n\n#define ADVANCE(state_value) \\\n  {                          \\\n    state = state_value;     \\\n    goto next_state;         \\\n  }\n\n#define ADVANCE_MAP(...)                                              \\\n  {                                                                   \\\n    static const uint16_t map[] = { __VA_ARGS__ };                    \\\n    for (uint32_t i = 0; i &lt; sizeof(map) / sizeof(map[0]); i += 2) {  \\\n      if (map[i] == lookahead) {                                      \\\n        state = map[i + 1];                                           \\\n        goto next_state;                                              \\\n      }                                                               \\\n    }                                                                 \\\n  }\n\n#define SKIP(state_value) \\\n  {                       \\\n    skip = true;          \\\n    state = state_value;  \\\n    goto next_state;      \\\n  }\n\n#define ACCEPT_TOKEN(symbol_value)     \\\n  result = true;                       \\\n  lexer-&gt;result_symbol = symbol_value; \\\n  lexer-&gt;mark_end(lexer);\n\n#define END_STATE() return result;\n\n/*\n *  Parse Table Macros\n */\n\n#define SMALL_STATE(id) ((id) - LARGE_STATE_COUNT)\n\n#define STATE(id) id\n\n#define ACTIONS(id) id\n\n#define SHIFT(state_value)            \\\n  {{                                  \\\n    .shift = {                        \\\n      .type = TSParseActionTypeShift, \\\n      .state = (state_value)          \\\n    }                                 \\\n  }}\n\n#define SHIFT_REPEAT(state_value)     \\\n  {{                                  \\\n    .shift = {                        \\\n      .type = TSParseActionTypeShift, \\\n      .state = (state_value),         \\\n      .repetition = true              \\\n    }                                 \\\n  }}\n\n#define SHIFT_EXTRA()                 \\\n  {{                                  \\\n    .shift = {                        \\\n      .type = TSParseActionTypeShift, \\\n      .extra = true                   \\\n    }                                 \\\n  }}\n\n#define REDUCE(symbol_name, children, precedence, prod_id) \\\n  {{                                                       \\\n    .reduce = {                                            \\\n      .type = TSParseActionTypeReduce,                     \\\n      .symbol = symbol_name,                               \\\n      .child_count = children,                             \\\n      .dynamic_precedence = precedence,                    \\\n      .production_id = prod_id                             \\\n    },                                                     \\\n  }}\n\n#define RECOVER()                    \\\n  {{                                 \\\n    .type = TSParseActionTypeRecover \\\n  }}\n\n#define ACCEPT_INPUT()              \\\n  {{                                \\\n    .type = TSParseActionTypeAccept \\\n  }}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_PARSER_H_\n&quot;;</code></pre></section></div></main></body></html>