<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/memchr-2.7.1/src/memmem/mod.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mod.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../memchr/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../memchr/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../memchr/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
This module provides forward and reverse substring search routines.

Unlike the standard library&#39;s substring search routines, these work on
arbitrary bytes. For all non-empty needles, these routines will report exactly
the same values as the corresponding routines in the standard library. For
the empty needle, the standard library reports matches only at valid UTF-8
boundaries, where as these routines will report matches at every position.

Other than being able to work on arbitrary bytes, the primary reason to prefer
these routines over the standard library routines is that these will generally
be faster. In some cases, significantly so.

# Example: iterating over substring matches

This example shows how to use [`find_iter`] to find occurrences of a substring
in a haystack.

```
use memchr::memmem;

let haystack = b&quot;foo bar foo baz foo&quot;;

let mut it = memmem::find_iter(haystack, &quot;foo&quot;);
assert_eq!(Some(0), it.next());
assert_eq!(Some(8), it.next());
assert_eq!(Some(16), it.next());
assert_eq!(None, it.next());
```

# Example: iterating over substring matches in reverse

This example shows how to use [`rfind_iter`] to find occurrences of a substring
in a haystack starting from the end of the haystack.

**NOTE:** This module does not implement double ended iterators, so reverse
searches aren&#39;t done by calling `rev` on a forward iterator.

```
use memchr::memmem;

let haystack = b&quot;foo bar foo baz foo&quot;;

let mut it = memmem::rfind_iter(haystack, &quot;foo&quot;);
assert_eq!(Some(16), it.next());
assert_eq!(Some(8), it.next());
assert_eq!(Some(0), it.next());
assert_eq!(None, it.next());
```

# Example: repeating a search for the same needle

It may be possible for the overhead of constructing a substring searcher to be
measurable in some workloads. In cases where the same needle is used to search
many haystacks, it is possible to do construction once and thus to avoid it for
subsequent searches. This can be done with a [`Finder`] (or a [`FinderRev`] for
reverse searches).

```
use memchr::memmem;

let finder = memmem::Finder::new(&quot;foo&quot;);

assert_eq!(Some(4), finder.find(b&quot;baz foo quux&quot;));
assert_eq!(None, finder.find(b&quot;quux baz bar&quot;));
```
*/

</span><span class="kw">pub use </span><span class="kw">crate</span>::memmem::searcher::PrefilterConfig <span class="kw">as </span>Prefilter;

<span class="comment">// This is exported here for use in the crate::arch::all::twoway
// implementation. This is essentially an abstraction breaker. Namely, the
// public API of twoway doesn&#39;t support providing a prefilter, but its crate
// internal API does. The main reason for this is that I didn&#39;t want to do the
// API design required to support it without a concrete use case.
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use </span><span class="kw">crate</span>::memmem::searcher::Pre;

<span class="kw">use crate</span>::{
    arch::all::{
        packedpair::{DefaultFrequencyRank, HeuristicFrequencyRank},
        rabinkarp,
    },
    cow::CowBytes,
    memmem::searcher::{PrefilterState, Searcher, SearcherRev},
};

<span class="kw">mod </span>searcher;

<span class="doccomment">/// Returns an iterator over all non-overlapping occurrences of a substring in
/// a haystack.
///
/// # Complexity
///
/// This routine is guaranteed to have worst case linear time complexity
/// with respect to both the needle and the haystack. That is, this runs
/// in `O(needle.len() + haystack.len())` time.
///
/// This routine is also guaranteed to have worst case constant space
/// complexity.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// use memchr::memmem;
///
/// let haystack = b&quot;foo bar foo baz foo&quot;;
/// let mut it = memmem::find_iter(haystack, b&quot;foo&quot;);
/// assert_eq!(Some(0), it.next());
/// assert_eq!(Some(8), it.next());
/// assert_eq!(Some(16), it.next());
/// assert_eq!(None, it.next());
/// ```
</span><span class="attribute">#[inline]
</span><span class="kw">pub fn </span>find_iter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>, N: <span class="lifetime">&#39;n </span>+ <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(
    haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>N,
) -&gt; FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    FindIter::new(haystack, Finder::new(needle))
}

<span class="doccomment">/// Returns a reverse iterator over all non-overlapping occurrences of a
/// substring in a haystack.
///
/// # Complexity
///
/// This routine is guaranteed to have worst case linear time complexity
/// with respect to both the needle and the haystack. That is, this runs
/// in `O(needle.len() + haystack.len())` time.
///
/// This routine is also guaranteed to have worst case constant space
/// complexity.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// use memchr::memmem;
///
/// let haystack = b&quot;foo bar foo baz foo&quot;;
/// let mut it = memmem::rfind_iter(haystack, b&quot;foo&quot;);
/// assert_eq!(Some(16), it.next());
/// assert_eq!(Some(8), it.next());
/// assert_eq!(Some(0), it.next());
/// assert_eq!(None, it.next());
/// ```
</span><span class="attribute">#[inline]
</span><span class="kw">pub fn </span>rfind_iter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>, N: <span class="lifetime">&#39;n </span>+ <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(
    haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>N,
) -&gt; FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    FindRevIter::new(haystack, FinderRev::new(needle))
}

<span class="doccomment">/// Returns the index of the first occurrence of the given needle.
///
/// Note that if you&#39;re are searching for the same needle in many different
/// small haystacks, it may be faster to initialize a [`Finder`] once,
/// and reuse it for each search.
///
/// # Complexity
///
/// This routine is guaranteed to have worst case linear time complexity
/// with respect to both the needle and the haystack. That is, this runs
/// in `O(needle.len() + haystack.len())` time.
///
/// This routine is also guaranteed to have worst case constant space
/// complexity.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// use memchr::memmem;
///
/// let haystack = b&quot;foo bar baz&quot;;
/// assert_eq!(Some(0), memmem::find(haystack, b&quot;foo&quot;));
/// assert_eq!(Some(4), memmem::find(haystack, b&quot;bar&quot;));
/// assert_eq!(None, memmem::find(haystack, b&quot;quux&quot;));
/// ```
</span><span class="attribute">#[inline]
</span><span class="kw">pub fn </span>find(haystack: <span class="kw-2">&amp;</span>[u8], needle: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
    <span class="kw">if </span>haystack.len() &lt; <span class="number">64 </span>{
        rabinkarp::Finder::new(needle).find(haystack, needle)
    } <span class="kw">else </span>{
        Finder::new(needle).find(haystack)
    }
}

<span class="doccomment">/// Returns the index of the last occurrence of the given needle.
///
/// Note that if you&#39;re are searching for the same needle in many different
/// small haystacks, it may be faster to initialize a [`FinderRev`] once,
/// and reuse it for each search.
///
/// # Complexity
///
/// This routine is guaranteed to have worst case linear time complexity
/// with respect to both the needle and the haystack. That is, this runs
/// in `O(needle.len() + haystack.len())` time.
///
/// This routine is also guaranteed to have worst case constant space
/// complexity.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// use memchr::memmem;
///
/// let haystack = b&quot;foo bar baz&quot;;
/// assert_eq!(Some(0), memmem::rfind(haystack, b&quot;foo&quot;));
/// assert_eq!(Some(4), memmem::rfind(haystack, b&quot;bar&quot;));
/// assert_eq!(Some(8), memmem::rfind(haystack, b&quot;ba&quot;));
/// assert_eq!(None, memmem::rfind(haystack, b&quot;quux&quot;));
/// ```
</span><span class="attribute">#[inline]
</span><span class="kw">pub fn </span>rfind(haystack: <span class="kw-2">&amp;</span>[u8], needle: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
    <span class="kw">if </span>haystack.len() &lt; <span class="number">64 </span>{
        rabinkarp::FinderRev::new(needle).rfind(haystack, needle)
    } <span class="kw">else </span>{
        FinderRev::new(needle).rfind(haystack)
    }
}

<span class="doccomment">/// An iterator over non-overlapping substring matches.
///
/// Matches are reported by the byte offset at which they begin.
///
/// `&#39;h` is the lifetime of the haystack while `&#39;n` is the lifetime of the
/// needle.
</span><span class="attribute">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    prestate: PrefilterState,
    finder: Finder&lt;<span class="lifetime">&#39;n</span>&gt;,
    pos: usize,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    <span class="attribute">#[inline(always)]
    </span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>new(
        haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
        finder: Finder&lt;<span class="lifetime">&#39;n</span>&gt;,
    ) -&gt; FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
        <span class="kw">let </span>prestate = PrefilterState::new();
        FindIter { haystack, prestate, finder, pos: <span class="number">0 </span>}
    }

    <span class="doccomment">/// Convert this iterator into its owned variant, such that it no longer
    /// borrows the finder and needle.
    ///
    /// If this is already an owned iterator, then this is a no-op. Otherwise,
    /// this copies the needle.
    ///
    /// This is only available when the `alloc` feature is enabled.
    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    #[inline]
    </span><span class="kw">pub fn </span>into_owned(<span class="self">self</span>) -&gt; FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;static</span>&gt; {
        FindIter {
            haystack: <span class="self">self</span>.haystack,
            prestate: <span class="self">self</span>.prestate,
            finder: <span class="self">self</span>.finder.into_owned(),
            pos: <span class="self">self</span>.pos,
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; Iterator <span class="kw">for </span>FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    <span class="kw">type </span>Item = usize;

    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
        <span class="kw">let </span>needle = <span class="self">self</span>.finder.needle();
        <span class="kw">let </span>haystack = <span class="self">self</span>.haystack.get(<span class="self">self</span>.pos..)<span class="question-mark">?</span>;
        <span class="kw">let </span>idx =
            <span class="self">self</span>.finder.searcher.find(<span class="kw-2">&amp;mut </span><span class="self">self</span>.prestate, haystack, needle)<span class="question-mark">?</span>;

        <span class="kw">let </span>pos = <span class="self">self</span>.pos + idx;
        <span class="self">self</span>.pos = pos + needle.len().max(<span class="number">1</span>);

        <span class="prelude-val">Some</span>(pos)
    }

    <span class="kw">fn </span>size_hint(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (usize, <span class="prelude-ty">Option</span>&lt;usize&gt;) {
        <span class="comment">// The largest possible number of non-overlapping matches is the
        // quotient of the haystack and the needle (or the length of the
        // haystack, if the needle is empty)
        </span><span class="kw">match </span><span class="self">self</span>.haystack.len().checked_sub(<span class="self">self</span>.pos) {
            <span class="prelude-val">None </span>=&gt; (<span class="number">0</span>, <span class="prelude-val">Some</span>(<span class="number">0</span>)),
            <span class="prelude-val">Some</span>(haystack_len) =&gt; <span class="kw">match </span><span class="self">self</span>.finder.needle().len() {
                <span class="comment">// Empty needles always succeed and match at every point
                // (including the very end)
                </span><span class="number">0 </span>=&gt; (
                    haystack_len.saturating_add(<span class="number">1</span>),
                    haystack_len.checked_add(<span class="number">1</span>),
                ),
                needle_len =&gt; (<span class="number">0</span>, <span class="prelude-val">Some</span>(haystack_len / needle_len)),
            },
        }
    }
}

<span class="doccomment">/// An iterator over non-overlapping substring matches in reverse.
///
/// Matches are reported by the byte offset at which they begin.
///
/// `&#39;h` is the lifetime of the haystack while `&#39;n` is the lifetime of the
/// needle.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    finder: FinderRev&lt;<span class="lifetime">&#39;n</span>&gt;,
    <span class="doccomment">/// When searching with an empty needle, this gets set to `None` after
    /// we&#39;ve yielded the last element at `0`.
    </span>pos: <span class="prelude-ty">Option</span>&lt;usize&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    <span class="attribute">#[inline(always)]
    </span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>new(
        haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
        finder: FinderRev&lt;<span class="lifetime">&#39;n</span>&gt;,
    ) -&gt; FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
        <span class="kw">let </span>pos = <span class="prelude-val">Some</span>(haystack.len());
        FindRevIter { haystack, finder, pos }
    }

    <span class="doccomment">/// Convert this iterator into its owned variant, such that it no longer
    /// borrows the finder and needle.
    ///
    /// If this is already an owned iterator, then this is a no-op. Otherwise,
    /// this copies the needle.
    ///
    /// This is only available when the `std` feature is enabled.
    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    #[inline]
    </span><span class="kw">pub fn </span>into_owned(<span class="self">self</span>) -&gt; FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;static</span>&gt; {
        FindRevIter {
            haystack: <span class="self">self</span>.haystack,
            finder: <span class="self">self</span>.finder.into_owned(),
            pos: <span class="self">self</span>.pos,
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; Iterator <span class="kw">for </span>FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;n</span>&gt; {
    <span class="kw">type </span>Item = usize;

    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
        <span class="kw">let </span>pos = <span class="kw">match </span><span class="self">self</span>.pos {
            <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="prelude-val">None</span>,
            <span class="prelude-val">Some</span>(pos) =&gt; pos,
        };
        <span class="kw">let </span>result = <span class="self">self</span>.finder.rfind(<span class="kw-2">&amp;</span><span class="self">self</span>.haystack[..pos]);
        <span class="kw">match </span>result {
            <span class="prelude-val">None </span>=&gt; <span class="prelude-val">None</span>,
            <span class="prelude-val">Some</span>(i) =&gt; {
                <span class="kw">if </span>pos == i {
                    <span class="self">self</span>.pos = pos.checked_sub(<span class="number">1</span>);
                } <span class="kw">else </span>{
                    <span class="self">self</span>.pos = <span class="prelude-val">Some</span>(i);
                }
                <span class="prelude-val">Some</span>(i)
            }
        }
    }
}

<span class="doccomment">/// A single substring searcher fixed to a particular needle.
///
/// The purpose of this type is to permit callers to construct a substring
/// searcher that can be used to search haystacks without the overhead of
/// constructing the searcher in the first place. This is a somewhat niche
/// concern when it&#39;s necessary to re-use the same needle to search multiple
/// different haystacks with as little overhead as possible. In general, using
/// [`find`] is good enough, but `Finder` is useful when you can meaningfully
/// observe searcher construction time in a profile.
///
/// When the `std` feature is enabled, then this type has an `into_owned`
/// version which permits building a `Finder` that is not connected to
/// the lifetime of its needle.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>Finder&lt;<span class="lifetime">&#39;n</span>&gt; {
    needle: CowBytes&lt;<span class="lifetime">&#39;n</span>&gt;,
    searcher: Searcher,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;n</span>&gt; Finder&lt;<span class="lifetime">&#39;n</span>&gt; {
    <span class="doccomment">/// Create a new finder for the given needle.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>new&lt;B: <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>B) -&gt; Finder&lt;<span class="lifetime">&#39;n</span>&gt; {
        FinderBuilder::new().build_forward(needle)
    }

    <span class="doccomment">/// Returns the index of the first occurrence of this needle in the given
    /// haystack.
    ///
    /// # Complexity
    ///
    /// This routine is guaranteed to have worst case linear time complexity
    /// with respect to both the needle and the haystack. That is, this runs
    /// in `O(needle.len() + haystack.len())` time.
    ///
    /// This routine is also guaranteed to have worst case constant space
    /// complexity.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use memchr::memmem::Finder;
    ///
    /// let haystack = b&quot;foo bar baz&quot;;
    /// assert_eq!(Some(0), Finder::new(&quot;foo&quot;).find(haystack));
    /// assert_eq!(Some(4), Finder::new(&quot;bar&quot;).find(haystack));
    /// assert_eq!(None, Finder::new(&quot;quux&quot;).find(haystack));
    /// ```
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>find(<span class="kw-2">&amp;</span><span class="self">self</span>, haystack: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>prestate = PrefilterState::new();
        <span class="kw">let </span>needle = <span class="self">self</span>.needle.as_slice();
        <span class="self">self</span>.searcher.find(<span class="kw-2">&amp;mut </span>prestate, haystack, needle)
    }

    <span class="doccomment">/// Returns an iterator over all occurrences of a substring in a haystack.
    ///
    /// # Complexity
    ///
    /// This routine is guaranteed to have worst case linear time complexity
    /// with respect to both the needle and the haystack. That is, this runs
    /// in `O(needle.len() + haystack.len())` time.
    ///
    /// This routine is also guaranteed to have worst case constant space
    /// complexity.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use memchr::memmem::Finder;
    ///
    /// let haystack = b&quot;foo bar foo baz foo&quot;;
    /// let finder = Finder::new(b&quot;foo&quot;);
    /// let mut it = finder.find_iter(haystack);
    /// assert_eq!(Some(0), it.next());
    /// assert_eq!(Some(8), it.next());
    /// assert_eq!(Some(16), it.next());
    /// assert_eq!(None, it.next());
    /// ```
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>find_iter&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;h</span>&gt;(
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>,
        haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    ) -&gt; FindIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;a</span>&gt; {
        FindIter::new(haystack, <span class="self">self</span>.as_ref())
    }

    <span class="doccomment">/// Convert this finder into its owned variant, such that it no longer
    /// borrows the needle.
    ///
    /// If this is already an owned finder, then this is a no-op. Otherwise,
    /// this copies the needle.
    ///
    /// This is only available when the `alloc` feature is enabled.
    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    #[inline]
    </span><span class="kw">pub fn </span>into_owned(<span class="self">self</span>) -&gt; Finder&lt;<span class="lifetime">&#39;static</span>&gt; {
        Finder {
            needle: <span class="self">self</span>.needle.into_owned(),
            searcher: <span class="self">self</span>.searcher.clone(),
        }
    }

    <span class="doccomment">/// Convert this finder into its borrowed variant.
    ///
    /// This is primarily useful if your finder is owned and you&#39;d like to
    /// store its borrowed variant in some intermediate data structure.
    ///
    /// Note that the lifetime parameter of the returned finder is tied to the
    /// lifetime of `self`, and may be shorter than the `&#39;n` lifetime of the
    /// needle itself. Namely, a finder&#39;s needle can be either borrowed or
    /// owned, so the lifetime of the needle returned must necessarily be the
    /// shorter of the two.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>as_ref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Finder&lt;<span class="lifetime">&#39;_</span>&gt; {
        Finder {
            needle: CowBytes::new(<span class="self">self</span>.needle()),
            searcher: <span class="self">self</span>.searcher.clone(),
        }
    }

    <span class="doccomment">/// Returns the needle that this finder searches for.
    ///
    /// Note that the lifetime of the needle returned is tied to the lifetime
    /// of the finder, and may be shorter than the `&#39;n` lifetime. Namely, a
    /// finder&#39;s needle can be either borrowed or owned, so the lifetime of the
    /// needle returned must necessarily be the shorter of the two.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>needle(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[u8] {
        <span class="self">self</span>.needle.as_slice()
    }
}

<span class="doccomment">/// A single substring reverse searcher fixed to a particular needle.
///
/// The purpose of this type is to permit callers to construct a substring
/// searcher that can be used to search haystacks without the overhead of
/// constructing the searcher in the first place. This is a somewhat niche
/// concern when it&#39;s necessary to re-use the same needle to search multiple
/// different haystacks with as little overhead as possible. In general,
/// using [`rfind`] is good enough, but `FinderRev` is useful when you can
/// meaningfully observe searcher construction time in a profile.
///
/// When the `std` feature is enabled, then this type has an `into_owned`
/// version which permits building a `FinderRev` that is not connected to
/// the lifetime of its needle.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>FinderRev&lt;<span class="lifetime">&#39;n</span>&gt; {
    needle: CowBytes&lt;<span class="lifetime">&#39;n</span>&gt;,
    searcher: SearcherRev,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;n</span>&gt; FinderRev&lt;<span class="lifetime">&#39;n</span>&gt; {
    <span class="doccomment">/// Create a new reverse finder for the given needle.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>new&lt;B: <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>B) -&gt; FinderRev&lt;<span class="lifetime">&#39;n</span>&gt; {
        FinderBuilder::new().build_reverse(needle)
    }

    <span class="doccomment">/// Returns the index of the last occurrence of this needle in the given
    /// haystack.
    ///
    /// The haystack may be any type that can be cheaply converted into a
    /// `&amp;[u8]`. This includes, but is not limited to, `&amp;str` and `&amp;[u8]`.
    ///
    /// # Complexity
    ///
    /// This routine is guaranteed to have worst case linear time complexity
    /// with respect to both the needle and the haystack. That is, this runs
    /// in `O(needle.len() + haystack.len())` time.
    ///
    /// This routine is also guaranteed to have worst case constant space
    /// complexity.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use memchr::memmem::FinderRev;
    ///
    /// let haystack = b&quot;foo bar baz&quot;;
    /// assert_eq!(Some(0), FinderRev::new(&quot;foo&quot;).rfind(haystack));
    /// assert_eq!(Some(4), FinderRev::new(&quot;bar&quot;).rfind(haystack));
    /// assert_eq!(None, FinderRev::new(&quot;quux&quot;).rfind(haystack));
    /// ```
    </span><span class="kw">pub fn </span>rfind&lt;B: AsRef&lt;[u8]&gt;&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, haystack: B) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
        <span class="self">self</span>.searcher.rfind(haystack.as_ref(), <span class="self">self</span>.needle.as_slice())
    }

    <span class="doccomment">/// Returns a reverse iterator over all occurrences of a substring in a
    /// haystack.
    ///
    /// # Complexity
    ///
    /// This routine is guaranteed to have worst case linear time complexity
    /// with respect to both the needle and the haystack. That is, this runs
    /// in `O(needle.len() + haystack.len())` time.
    ///
    /// This routine is also guaranteed to have worst case constant space
    /// complexity.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use memchr::memmem::FinderRev;
    ///
    /// let haystack = b&quot;foo bar foo baz foo&quot;;
    /// let finder = FinderRev::new(b&quot;foo&quot;);
    /// let mut it = finder.rfind_iter(haystack);
    /// assert_eq!(Some(16), it.next());
    /// assert_eq!(Some(8), it.next());
    /// assert_eq!(Some(0), it.next());
    /// assert_eq!(None, it.next());
    /// ```
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>rfind_iter&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;h</span>&gt;(
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>,
        haystack: <span class="kw-2">&amp;</span><span class="lifetime">&#39;h </span>[u8],
    ) -&gt; FindRevIter&lt;<span class="lifetime">&#39;h</span>, <span class="lifetime">&#39;a</span>&gt; {
        FindRevIter::new(haystack, <span class="self">self</span>.as_ref())
    }

    <span class="doccomment">/// Convert this finder into its owned variant, such that it no longer
    /// borrows the needle.
    ///
    /// If this is already an owned finder, then this is a no-op. Otherwise,
    /// this copies the needle.
    ///
    /// This is only available when the `std` feature is enabled.
    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    #[inline]
    </span><span class="kw">pub fn </span>into_owned(<span class="self">self</span>) -&gt; FinderRev&lt;<span class="lifetime">&#39;static</span>&gt; {
        FinderRev {
            needle: <span class="self">self</span>.needle.into_owned(),
            searcher: <span class="self">self</span>.searcher.clone(),
        }
    }

    <span class="doccomment">/// Convert this finder into its borrowed variant.
    ///
    /// This is primarily useful if your finder is owned and you&#39;d like to
    /// store its borrowed variant in some intermediate data structure.
    ///
    /// Note that the lifetime parameter of the returned finder is tied to the
    /// lifetime of `self`, and may be shorter than the `&#39;n` lifetime of the
    /// needle itself. Namely, a finder&#39;s needle can be either borrowed or
    /// owned, so the lifetime of the needle returned must necessarily be the
    /// shorter of the two.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>as_ref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; FinderRev&lt;<span class="lifetime">&#39;_</span>&gt; {
        FinderRev {
            needle: CowBytes::new(<span class="self">self</span>.needle()),
            searcher: <span class="self">self</span>.searcher.clone(),
        }
    }

    <span class="doccomment">/// Returns the needle that this finder searches for.
    ///
    /// Note that the lifetime of the needle returned is tied to the lifetime
    /// of the finder, and may be shorter than the `&#39;n` lifetime. Namely, a
    /// finder&#39;s needle can be either borrowed or owned, so the lifetime of the
    /// needle returned must necessarily be the shorter of the two.
    </span><span class="attribute">#[inline]
    </span><span class="kw">pub fn </span>needle(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[u8] {
        <span class="self">self</span>.needle.as_slice()
    }
}

<span class="doccomment">/// A builder for constructing non-default forward or reverse memmem finders.
///
/// A builder is primarily useful for configuring a substring searcher.
/// Currently, the only configuration exposed is the ability to disable
/// heuristic prefilters used to speed up certain searches.
</span><span class="attribute">#[derive(Clone, Debug, Default)]
</span><span class="kw">pub struct </span>FinderBuilder {
    prefilter: Prefilter,
}

<span class="kw">impl </span>FinderBuilder {
    <span class="doccomment">/// Create a new finder builder with default settings.
    </span><span class="kw">pub fn </span>new() -&gt; FinderBuilder {
        FinderBuilder::default()
    }

    <span class="doccomment">/// Build a forward finder using the given needle from the current
    /// settings.
    </span><span class="kw">pub fn </span>build_forward&lt;<span class="lifetime">&#39;n</span>, B: <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>B,
    ) -&gt; Finder&lt;<span class="lifetime">&#39;n</span>&gt; {
        <span class="self">self</span>.build_forward_with_ranker(DefaultFrequencyRank, needle)
    }

    <span class="doccomment">/// Build a forward finder using the given needle and a custom heuristic for
    /// determining the frequency of a given byte in the dataset.
    /// See [`HeuristicFrequencyRank`] for more details.
    </span><span class="kw">pub fn </span>build_forward_with_ranker&lt;
        <span class="lifetime">&#39;n</span>,
        R: HeuristicFrequencyRank,
        B: <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;,
    &gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        ranker: R,
        needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>B,
    ) -&gt; Finder&lt;<span class="lifetime">&#39;n</span>&gt; {
        <span class="kw">let </span>needle = needle.as_ref();
        Finder {
            needle: CowBytes::new(needle),
            searcher: Searcher::new(<span class="self">self</span>.prefilter, ranker, needle),
        }
    }

    <span class="doccomment">/// Build a reverse finder using the given needle from the current
    /// settings.
    </span><span class="kw">pub fn </span>build_reverse&lt;<span class="lifetime">&#39;n</span>, B: <span class="question-mark">?</span>Sized + AsRef&lt;[u8]&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        needle: <span class="kw-2">&amp;</span><span class="lifetime">&#39;n </span>B,
    ) -&gt; FinderRev&lt;<span class="lifetime">&#39;n</span>&gt; {
        <span class="kw">let </span>needle = needle.as_ref();
        FinderRev {
            needle: CowBytes::new(needle),
            searcher: SearcherRev::new(needle),
        }
    }

    <span class="doccomment">/// Configure the prefilter setting for the finder.
    ///
    /// See the documentation for [`Prefilter`] for more discussion on why
    /// you might want to configure this.
    </span><span class="kw">pub fn </span>prefilter(<span class="kw-2">&amp;mut </span><span class="self">self</span>, prefilter: Prefilter) -&gt; <span class="kw-2">&amp;mut </span>FinderBuilder {
        <span class="self">self</span>.prefilter = prefilter;
        <span class="self">self
    </span>}
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>tests {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="macro">define_substring_forward_quickcheck!</span>(|h, n| <span class="prelude-val">Some</span>(Finder::new(n).find(h)));
    <span class="macro">define_substring_reverse_quickcheck!</span>(|h, n| <span class="prelude-val">Some</span>(
        FinderRev::new(n).rfind(h)
    ));

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>forward() {
        <span class="kw">crate</span>::tests::substring::Runner::new()
            .fwd(|h, n| <span class="prelude-val">Some</span>(Finder::new(n).find(h)))
            .run();
    }

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>reverse() {
        <span class="kw">crate</span>::tests::substring::Runner::new()
            .rev(|h, n| <span class="prelude-val">Some</span>(FinderRev::new(n).rfind(h)))
            .run();
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="memchr" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>