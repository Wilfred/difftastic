<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/tree-sitter-0.25.10/binding_rust/./bindings.rs`."><title>bindings.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tree_sitter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../../static.files/src-script-39ed315d46fb705f.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><div class="sidebar-resizer"></div>
    <main><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
<a href="#555" id="555">555</a>
<a href="#556" id="556">556</a>
<a href="#557" id="557">557</a>
<a href="#558" id="558">558</a>
<a href="#559" id="559">559</a>
<a href="#560" id="560">560</a>
<a href="#561" id="561">561</a>
<a href="#562" id="562">562</a>
<a href="#563" id="563">563</a>
<a href="#564" id="564">564</a>
<a href="#565" id="565">565</a>
<a href="#566" id="566">566</a>
<a href="#567" id="567">567</a>
<a href="#568" id="568">568</a>
<a href="#569" id="569">569</a>
<a href="#570" id="570">570</a>
<a href="#571" id="571">571</a>
<a href="#572" id="572">572</a>
<a href="#573" id="573">573</a>
<a href="#574" id="574">574</a>
<a href="#575" id="575">575</a>
<a href="#576" id="576">576</a>
<a href="#577" id="577">577</a>
<a href="#578" id="578">578</a>
<a href="#579" id="579">579</a>
<a href="#580" id="580">580</a>
<a href="#581" id="581">581</a>
<a href="#582" id="582">582</a>
<a href="#583" id="583">583</a>
<a href="#584" id="584">584</a>
<a href="#585" id="585">585</a>
<a href="#586" id="586">586</a>
<a href="#587" id="587">587</a>
<a href="#588" id="588">588</a>
<a href="#589" id="589">589</a>
<a href="#590" id="590">590</a>
<a href="#591" id="591">591</a>
<a href="#592" id="592">592</a>
<a href="#593" id="593">593</a>
<a href="#594" id="594">594</a>
<a href="#595" id="595">595</a>
<a href="#596" id="596">596</a>
<a href="#597" id="597">597</a>
<a href="#598" id="598">598</a>
<a href="#599" id="599">599</a>
<a href="#600" id="600">600</a>
<a href="#601" id="601">601</a>
<a href="#602" id="602">602</a>
<a href="#603" id="603">603</a>
<a href="#604" id="604">604</a>
<a href="#605" id="605">605</a>
<a href="#606" id="606">606</a>
<a href="#607" id="607">607</a>
<a href="#608" id="608">608</a>
<a href="#609" id="609">609</a>
<a href="#610" id="610">610</a>
<a href="#611" id="611">611</a>
<a href="#612" id="612">612</a>
<a href="#613" id="613">613</a>
<a href="#614" id="614">614</a>
<a href="#615" id="615">615</a>
<a href="#616" id="616">616</a>
<a href="#617" id="617">617</a>
<a href="#618" id="618">618</a>
<a href="#619" id="619">619</a>
<a href="#620" id="620">620</a>
<a href="#621" id="621">621</a>
<a href="#622" id="622">622</a>
<a href="#623" id="623">623</a>
<a href="#624" id="624">624</a>
<a href="#625" id="625">625</a>
<a href="#626" id="626">626</a>
<a href="#627" id="627">627</a>
<a href="#628" id="628">628</a>
<a href="#629" id="629">629</a>
<a href="#630" id="630">630</a>
<a href="#631" id="631">631</a>
<a href="#632" id="632">632</a>
<a href="#633" id="633">633</a>
<a href="#634" id="634">634</a>
<a href="#635" id="635">635</a>
<a href="#636" id="636">636</a>
<a href="#637" id="637">637</a>
<a href="#638" id="638">638</a>
<a href="#639" id="639">639</a>
<a href="#640" id="640">640</a>
<a href="#641" id="641">641</a>
<a href="#642" id="642">642</a>
<a href="#643" id="643">643</a>
<a href="#644" id="644">644</a>
<a href="#645" id="645">645</a>
<a href="#646" id="646">646</a>
<a href="#647" id="647">647</a>
<a href="#648" id="648">648</a>
<a href="#649" id="649">649</a>
<a href="#650" id="650">650</a>
<a href="#651" id="651">651</a>
<a href="#652" id="652">652</a>
<a href="#653" id="653">653</a>
<a href="#654" id="654">654</a>
<a href="#655" id="655">655</a>
<a href="#656" id="656">656</a>
<a href="#657" id="657">657</a>
<a href="#658" id="658">658</a>
<a href="#659" id="659">659</a>
<a href="#660" id="660">660</a>
<a href="#661" id="661">661</a>
<a href="#662" id="662">662</a>
<a href="#663" id="663">663</a>
<a href="#664" id="664">664</a>
<a href="#665" id="665">665</a>
<a href="#666" id="666">666</a>
<a href="#667" id="667">667</a>
<a href="#668" id="668">668</a>
<a href="#669" id="669">669</a>
<a href="#670" id="670">670</a>
<a href="#671" id="671">671</a>
<a href="#672" id="672">672</a>
<a href="#673" id="673">673</a>
<a href="#674" id="674">674</a>
<a href="#675" id="675">675</a>
<a href="#676" id="676">676</a>
<a href="#677" id="677">677</a>
<a href="#678" id="678">678</a>
<a href="#679" id="679">679</a>
<a href="#680" id="680">680</a>
<a href="#681" id="681">681</a>
<a href="#682" id="682">682</a>
<a href="#683" id="683">683</a>
<a href="#684" id="684">684</a>
<a href="#685" id="685">685</a>
<a href="#686" id="686">686</a>
<a href="#687" id="687">687</a>
<a href="#688" id="688">688</a>
<a href="#689" id="689">689</a>
<a href="#690" id="690">690</a>
<a href="#691" id="691">691</a>
<a href="#692" id="692">692</a>
<a href="#693" id="693">693</a>
<a href="#694" id="694">694</a>
<a href="#695" id="695">695</a>
<a href="#696" id="696">696</a>
<a href="#697" id="697">697</a>
<a href="#698" id="698">698</a>
<a href="#699" id="699">699</a>
<a href="#700" id="700">700</a>
<a href="#701" id="701">701</a>
<a href="#702" id="702">702</a>
<a href="#703" id="703">703</a>
<a href="#704" id="704">704</a>
<a href="#705" id="705">705</a>
<a href="#706" id="706">706</a>
<a href="#707" id="707">707</a>
<a href="#708" id="708">708</a>
<a href="#709" id="709">709</a>
<a href="#710" id="710">710</a>
<a href="#711" id="711">711</a>
<a href="#712" id="712">712</a>
<a href="#713" id="713">713</a>
<a href="#714" id="714">714</a>
<a href="#715" id="715">715</a>
<a href="#716" id="716">716</a>
<a href="#717" id="717">717</a>
<a href="#718" id="718">718</a>
<a href="#719" id="719">719</a>
<a href="#720" id="720">720</a>
<a href="#721" id="721">721</a>
<a href="#722" id="722">722</a>
<a href="#723" id="723">723</a>
<a href="#724" id="724">724</a>
<a href="#725" id="725">725</a>
<a href="#726" id="726">726</a>
<a href="#727" id="727">727</a>
<a href="#728" id="728">728</a>
<a href="#729" id="729">729</a>
<a href="#730" id="730">730</a>
<a href="#731" id="731">731</a>
<a href="#732" id="732">732</a>
<a href="#733" id="733">733</a>
<a href="#734" id="734">734</a>
<a href="#735" id="735">735</a>
<a href="#736" id="736">736</a>
<a href="#737" id="737">737</a>
<a href="#738" id="738">738</a>
<a href="#739" id="739">739</a>
<a href="#740" id="740">740</a>
<a href="#741" id="741">741</a>
<a href="#742" id="742">742</a>
<a href="#743" id="743">743</a>
<a href="#744" id="744">744</a>
<a href="#745" id="745">745</a>
<a href="#746" id="746">746</a>
<a href="#747" id="747">747</a>
<a href="#748" id="748">748</a>
<a href="#749" id="749">749</a>
<a href="#750" id="750">750</a>
<a href="#751" id="751">751</a>
<a href="#752" id="752">752</a>
<a href="#753" id="753">753</a>
<a href="#754" id="754">754</a>
<a href="#755" id="755">755</a>
<a href="#756" id="756">756</a>
<a href="#757" id="757">757</a>
<a href="#758" id="758">758</a>
<a href="#759" id="759">759</a>
<a href="#760" id="760">760</a>
<a href="#761" id="761">761</a>
<a href="#762" id="762">762</a>
<a href="#763" id="763">763</a>
<a href="#764" id="764">764</a>
<a href="#765" id="765">765</a>
<a href="#766" id="766">766</a>
<a href="#767" id="767">767</a>
<a href="#768" id="768">768</a>
<a href="#769" id="769">769</a>
<a href="#770" id="770">770</a>
<a href="#771" id="771">771</a>
<a href="#772" id="772">772</a>
<a href="#773" id="773">773</a>
<a href="#774" id="774">774</a>
<a href="#775" id="775">775</a>
<a href="#776" id="776">776</a>
<a href="#777" id="777">777</a>
<a href="#778" id="778">778</a>
<a href="#779" id="779">779</a>
<a href="#780" id="780">780</a>
<a href="#781" id="781">781</a>
<a href="#782" id="782">782</a>
<a href="#783" id="783">783</a>
<a href="#784" id="784">784</a>
<a href="#785" id="785">785</a>
<a href="#786" id="786">786</a>
<a href="#787" id="787">787</a>
<a href="#788" id="788">788</a>
<a href="#789" id="789">789</a>
<a href="#790" id="790">790</a>
<a href="#791" id="791">791</a>
<a href="#792" id="792">792</a>
<a href="#793" id="793">793</a>
<a href="#794" id="794">794</a>
<a href="#795" id="795">795</a>
<a href="#796" id="796">796</a>
<a href="#797" id="797">797</a>
<a href="#798" id="798">798</a>
<a href="#799" id="799">799</a>
<a href="#800" id="800">800</a>
<a href="#801" id="801">801</a>
<a href="#802" id="802">802</a>
<a href="#803" id="803">803</a>
<a href="#804" id="804">804</a>
<a href="#805" id="805">805</a>
<a href="#806" id="806">806</a>
<a href="#807" id="807">807</a>
<a href="#808" id="808">808</a>
<a href="#809" id="809">809</a>
<a href="#810" id="810">810</a>
<a href="#811" id="811">811</a>
<a href="#812" id="812">812</a>
<a href="#813" id="813">813</a>
<a href="#814" id="814">814</a>
<a href="#815" id="815">815</a>
<a href="#816" id="816">816</a>
<a href="#817" id="817">817</a>
<a href="#818" id="818">818</a>
<a href="#819" id="819">819</a>
<a href="#820" id="820">820</a>
<a href="#821" id="821">821</a>
<a href="#822" id="822">822</a>
<a href="#823" id="823">823</a>
<a href="#824" id="824">824</a>
<a href="#825" id="825">825</a>
<a href="#826" id="826">826</a>
<a href="#827" id="827">827</a>
<a href="#828" id="828">828</a>
<a href="#829" id="829">829</a>
<a href="#830" id="830">830</a>
<a href="#831" id="831">831</a>
<a href="#832" id="832">832</a>
<a href="#833" id="833">833</a>
<a href="#834" id="834">834</a>
<a href="#835" id="835">835</a>
<a href="#836" id="836">836</a>
<a href="#837" id="837">837</a>
<a href="#838" id="838">838</a>
<a href="#839" id="839">839</a>
<a href="#840" id="840">840</a>
<a href="#841" id="841">841</a>
<a href="#842" id="842">842</a>
<a href="#843" id="843">843</a>
<a href="#844" id="844">844</a>
<a href="#845" id="845">845</a>
<a href="#846" id="846">846</a>
<a href="#847" id="847">847</a>
<a href="#848" id="848">848</a>
<a href="#849" id="849">849</a>
<a href="#850" id="850">850</a>
<a href="#851" id="851">851</a>
<a href="#852" id="852">852</a>
<a href="#853" id="853">853</a>
<a href="#854" id="854">854</a>
<a href="#855" id="855">855</a>
<a href="#856" id="856">856</a>
<a href="#857" id="857">857</a>
<a href="#858" id="858">858</a>
<a href="#859" id="859">859</a>
<a href="#860" id="860">860</a>
<a href="#861" id="861">861</a>
<a href="#862" id="862">862</a>
<a href="#863" id="863">863</a>
<a href="#864" id="864">864</a>
<a href="#865" id="865">865</a>
<a href="#866" id="866">866</a>
<a href="#867" id="867">867</a>
<a href="#868" id="868">868</a>
<a href="#869" id="869">869</a>
<a href="#870" id="870">870</a>
<a href="#871" id="871">871</a>
<a href="#872" id="872">872</a>
<a href="#873" id="873">873</a>
<a href="#874" id="874">874</a>
<a href="#875" id="875">875</a>
<a href="#876" id="876">876</a>
<a href="#877" id="877">877</a>
<a href="#878" id="878">878</a>
<a href="#879" id="879">879</a>
<a href="#880" id="880">880</a>
<a href="#881" id="881">881</a>
<a href="#882" id="882">882</a>
<a href="#883" id="883">883</a>
<a href="#884" id="884">884</a>
<a href="#885" id="885">885</a>
<a href="#886" id="886">886</a>
<a href="#887" id="887">887</a>
<a href="#888" id="888">888</a>
<a href="#889" id="889">889</a>
<a href="#890" id="890">890</a>
<a href="#891" id="891">891</a>
<a href="#892" id="892">892</a>
<a href="#893" id="893">893</a>
<a href="#894" id="894">894</a>
<a href="#895" id="895">895</a>
<a href="#896" id="896">896</a>
<a href="#897" id="897">897</a>
<a href="#898" id="898">898</a>
<a href="#899" id="899">899</a>
<a href="#900" id="900">900</a>
<a href="#901" id="901">901</a>
<a href="#902" id="902">902</a>
<a href="#903" id="903">903</a>
<a href="#904" id="904">904</a>
<a href="#905" id="905">905</a>
<a href="#906" id="906">906</a>
<a href="#907" id="907">907</a>
<a href="#908" id="908">908</a>
<a href="#909" id="909">909</a>
<a href="#910" id="910">910</a>
<a href="#911" id="911">911</a>
<a href="#912" id="912">912</a>
<a href="#913" id="913">913</a>
<a href="#914" id="914">914</a>
<a href="#915" id="915">915</a>
<a href="#916" id="916">916</a>
<a href="#917" id="917">917</a>
<a href="#918" id="918">918</a>
<a href="#919" id="919">919</a>
<a href="#920" id="920">920</a>
<a href="#921" id="921">921</a>
<a href="#922" id="922">922</a>
<a href="#923" id="923">923</a>
<a href="#924" id="924">924</a>
<a href="#925" id="925">925</a>
<a href="#926" id="926">926</a>
<a href="#927" id="927">927</a>
<a href="#928" id="928">928</a>
<a href="#929" id="929">929</a>
<a href="#930" id="930">930</a>
<a href="#931" id="931">931</a>
<a href="#932" id="932">932</a>
<a href="#933" id="933">933</a>
<a href="#934" id="934">934</a>
<a href="#935" id="935">935</a>
<a href="#936" id="936">936</a>
<a href="#937" id="937">937</a>
<a href="#938" id="938">938</a>
<a href="#939" id="939">939</a>
<a href="#940" id="940">940</a>
<a href="#941" id="941">941</a>
<a href="#942" id="942">942</a>
<a href="#943" id="943">943</a>
<a href="#944" id="944">944</a>
<a href="#945" id="945">945</a>
<a href="#946" id="946">946</a>
<a href="#947" id="947">947</a>
<a href="#948" id="948">948</a>
<a href="#949" id="949">949</a>
<a href="#950" id="950">950</a>
<a href="#951" id="951">951</a>
<a href="#952" id="952">952</a>
<a href="#953" id="953">953</a>
<a href="#954" id="954">954</a>
<a href="#955" id="955">955</a>
<a href="#956" id="956">956</a>
<a href="#957" id="957">957</a>
<a href="#958" id="958">958</a>
<a href="#959" id="959">959</a>
<a href="#960" id="960">960</a>
<a href="#961" id="961">961</a>
<a href="#962" id="962">962</a>
<a href="#963" id="963">963</a>
</pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.71.1 */

</span><span class="kw">pub const </span>TREE_SITTER_LANGUAGE_VERSION: u32 = <span class="number">15</span>;
<span class="kw">pub const </span>TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION: u32 = <span class="number">13</span>;
<span class="kw">pub type </span>TSStateId = u16;
<span class="kw">pub type </span>TSSymbol = u16;
<span class="kw">pub type </span>TSFieldId = u16;
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSLanguage {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSParser {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSTree {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSQuery {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSQueryCursor {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSLookaheadIterator {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub type </span>DecodeFunction = ::core::option::Option&lt;
    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(string: <span class="kw-2">*const </span>u8, length: u32, code_point: <span class="kw-2">*mut </span>i32) -&gt; u32,
&gt;;
<span class="kw">pub const </span>TSInputEncodingUTF8: TSInputEncoding = <span class="number">0</span>;
<span class="kw">pub const </span>TSInputEncodingUTF16LE: TSInputEncoding = <span class="number">1</span>;
<span class="kw">pub const </span>TSInputEncodingUTF16BE: TSInputEncoding = <span class="number">2</span>;
<span class="kw">pub const </span>TSInputEncodingCustom: TSInputEncoding = <span class="number">3</span>;
<span class="kw">pub type </span>TSInputEncoding = ::core::ffi::c_uint;
<span class="kw">pub const </span>TSSymbolTypeRegular: TSSymbolType = <span class="number">0</span>;
<span class="kw">pub const </span>TSSymbolTypeAnonymous: TSSymbolType = <span class="number">1</span>;
<span class="kw">pub const </span>TSSymbolTypeSupertype: TSSymbolType = <span class="number">2</span>;
<span class="kw">pub const </span>TSSymbolTypeAuxiliary: TSSymbolType = <span class="number">3</span>;
<span class="kw">pub type </span>TSSymbolType = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSPoint {
    <span class="kw">pub </span>row: u32,
    <span class="kw">pub </span>column: u32,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSRange {
    <span class="kw">pub </span>start_point: TSPoint,
    <span class="kw">pub </span>end_point: TSPoint,
    <span class="kw">pub </span>start_byte: u32,
    <span class="kw">pub </span>end_byte: u32,
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSInput {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>read: ::core::option::Option&lt;
        <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
            payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
            byte_index: u32,
            position: TSPoint,
            bytes_read: <span class="kw-2">*mut </span>u32,
        ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char,
    &gt;,
    <span class="kw">pub </span>encoding: TSInputEncoding,
    <span class="kw">pub </span>decode: DecodeFunction,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSParseState {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>current_byte_offset: u32,
    <span class="kw">pub </span>has_error: bool,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSParseOptions {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>progress_callback:
        ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(state: <span class="kw-2">*mut </span>TSParseState) -&gt; bool&gt;,
}
<span class="kw">pub const </span>TSLogTypeParse: TSLogType = <span class="number">0</span>;
<span class="kw">pub const </span>TSLogTypeLex: TSLogType = <span class="number">1</span>;
<span class="kw">pub type </span>TSLogType = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSLogger {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>log: ::core::option::Option&lt;
        <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
            payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
            log_type: TSLogType,
            buffer: <span class="kw-2">*const </span>::core::ffi::c_char,
        ),
    &gt;,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSInputEdit {
    <span class="kw">pub </span>start_byte: u32,
    <span class="kw">pub </span>old_end_byte: u32,
    <span class="kw">pub </span>new_end_byte: u32,
    <span class="kw">pub </span>start_point: TSPoint,
    <span class="kw">pub </span>old_end_point: TSPoint,
    <span class="kw">pub </span>new_end_point: TSPoint,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSNode {
    <span class="kw">pub </span>context: [u32; <span class="number">4usize</span>],
    <span class="kw">pub </span>id: <span class="kw-2">*const </span>::core::ffi::c_void,
    <span class="kw">pub </span>tree: <span class="kw-2">*const </span>TSTree,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSTreeCursor {
    <span class="kw">pub </span>tree: <span class="kw-2">*const </span>::core::ffi::c_void,
    <span class="kw">pub </span>id: <span class="kw-2">*const </span>::core::ffi::c_void,
    <span class="kw">pub </span>context: [u32; <span class="number">3usize</span>],
}
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSQueryCapture {
    <span class="kw">pub </span>node: TSNode,
    <span class="kw">pub </span>index: u32,
}
<span class="kw">pub const </span>TSQuantifierZero: TSQuantifier = <span class="number">0</span>;
<span class="kw">pub const </span>TSQuantifierZeroOrOne: TSQuantifier = <span class="number">1</span>;
<span class="kw">pub const </span>TSQuantifierZeroOrMore: TSQuantifier = <span class="number">2</span>;
<span class="kw">pub const </span>TSQuantifierOne: TSQuantifier = <span class="number">3</span>;
<span class="kw">pub const </span>TSQuantifierOneOrMore: TSQuantifier = <span class="number">4</span>;
<span class="kw">pub type </span>TSQuantifier = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSQueryMatch {
    <span class="kw">pub </span>id: u32,
    <span class="kw">pub </span>pattern_index: u16,
    <span class="kw">pub </span>capture_count: u16,
    <span class="kw">pub </span>captures: <span class="kw-2">*const </span>TSQueryCapture,
}
<span class="kw">pub const </span>TSQueryPredicateStepTypeDone: TSQueryPredicateStepType = <span class="number">0</span>;
<span class="kw">pub const </span>TSQueryPredicateStepTypeCapture: TSQueryPredicateStepType = <span class="number">1</span>;
<span class="kw">pub const </span>TSQueryPredicateStepTypeString: TSQueryPredicateStepType = <span class="number">2</span>;
<span class="kw">pub type </span>TSQueryPredicateStepType = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug)]
</span><span class="kw">pub struct </span>TSQueryPredicateStep {
    <span class="kw">pub </span>type_: TSQueryPredicateStepType,
    <span class="kw">pub </span>value_id: u32,
}
<span class="kw">pub const </span>TSQueryErrorNone: TSQueryError = <span class="number">0</span>;
<span class="kw">pub const </span>TSQueryErrorSyntax: TSQueryError = <span class="number">1</span>;
<span class="kw">pub const </span>TSQueryErrorNodeType: TSQueryError = <span class="number">2</span>;
<span class="kw">pub const </span>TSQueryErrorField: TSQueryError = <span class="number">3</span>;
<span class="kw">pub const </span>TSQueryErrorCapture: TSQueryError = <span class="number">4</span>;
<span class="kw">pub const </span>TSQueryErrorStructure: TSQueryError = <span class="number">5</span>;
<span class="kw">pub const </span>TSQueryErrorLanguage: TSQueryError = <span class="number">6</span>;
<span class="kw">pub type </span>TSQueryError = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSQueryCursorState {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>current_byte_offset: u32,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSQueryCursorOptions {
    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="kw">pub </span>progress_callback:
        ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(state: <span class="kw-2">*mut </span>TSQueryCursorState) -&gt; bool&gt;,
}
<span class="attr">#[doc = <span class="string">" The metadata associated with a language.\n\n Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)\n of the language. This version information should be used to signal if a given parser might\n be incompatible with existing queries when upgrading between major versions, or minor versions\n if it's in zerover."</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSLanguageMetadata {
    <span class="kw">pub </span>major_version: u8,
    <span class="kw">pub </span>minor_version: u8,
    <span class="kw">pub </span>patch_version: u8,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a new parser."</span>]
    </span><span class="kw">pub fn </span>ts_parser_new() -&gt; <span class="kw-2">*mut </span>TSParser;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete the parser, freeing all of the memory that it used."</span>]
    </span><span class="kw">pub fn </span>ts_parser_delete(self_: <span class="kw-2">*mut </span>TSParser);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the parser's current language."</span>]
    </span><span class="kw">pub fn </span>ts_parser_language(self_: <span class="kw-2">*const </span>TSParser) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the language that the parser should use for parsing.\n\n Returns a boolean indicating whether or not the language was successfully\n assigned. True means assignment succeeded. False means there was a version\n mismatch: the language was generated with an incompatible version of the\n Tree-sitter CLI. Check the language's ABI version using [`ts_language_abi_version`]\n and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and\n [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants."</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_language(self_: <span class="kw-2">*mut </span>TSParser, language: <span class="kw-2">*const </span>TSLanguage) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the ranges of text that the parser should include when parsing.\n\n By default, the parser will always include entire documents. This function\n allows you to parse only a *portion* of a document but still return a syntax\n tree whose ranges match up with the document as a whole. You can also pass\n multiple disjoint ranges.\n\n The second and third parameters specify the location and length of an array\n of ranges. The parser does *not* take ownership of these ranges; it copies\n the data, so it doesn't matter how these ranges are allocated.\n\n If `count` is zero, then the entire document will be parsed. Otherwise,\n the given ranges must be ordered from earliest to latest in the document,\n and they must not overlap. That is, the following must hold for all:\n\n `i &lt; count - 1`: `ranges[i].end_byte &lt;= ranges[i + 1].start_byte`\n\n If this requirement is not satisfied, the operation will fail, the ranges\n will not be assigned, and this function will return `false`. On success,\n this function returns `true`"</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_included_ranges(
        self_: <span class="kw-2">*mut </span>TSParser,
        ranges: <span class="kw-2">*const </span>TSRange,
        count: u32,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the ranges of text that the parser will include when parsing.\n\n The returned pointer is owned by the parser. The caller should not free it\n or write to it. The length of the array will be written to the given\n `count` pointer."</span>]
    </span><span class="kw">pub fn </span>ts_parser_included_ranges(self_: <span class="kw-2">*const </span>TSParser, count: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*const </span>TSRange;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code and create a syntax tree.\n\n If you are parsing this document for the first time, pass `NULL` for the\n `old_tree` parameter. Otherwise, if you have already parsed an earlier\n version of this document and the document has since been edited, pass the\n previous syntax tree so that the unchanged parts of it can be reused.\n This will save time and memory. For this to work correctly, you must have\n already edited the old syntax tree using the [`ts_tree_edit`] function in a\n way that exactly matches the source code changes.\n\n The [`TSInput`] parameter lets you specify how to read the text. It has the\n following three fields:\n 1. [`read`]: A function to retrieve a chunk of text at a given byte offset\n    and (row, column) position. The function should return a pointer to the\n    text and write its length to the [`bytes_read`] pointer. The parser does\n    not take ownership of this buffer; it just borrows it until it has\n    finished reading it. The function should write a zero value to the\n    [`bytes_read`] pointer to indicate the end of the document.\n 2. [`payload`]: An arbitrary pointer that will be passed to each invocation\n    of the [`read`] function.\n 3. [`encoding`]: An indication of how the text is encoded. Either\n    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.\n\n This function returns a syntax tree on success, and `NULL` on failure. There\n are four possible reasons for failure:\n 1. The parser does not have a language assigned. Check for this using the\n[`ts_parser_language`] function.\n 2. Parsing was cancelled due to a timeout that was set by an earlier call to\n    the [`ts_parser_set_timeout_micros`] function. You can resume parsing from\n    where the parser left out by calling [`ts_parser_parse`] again with the\n    same arguments. Or you can start parsing from scratch by first calling\n    [`ts_parser_reset`].\n 3. Parsing was cancelled using a cancellation flag that was set by an\n    earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing\n    from where the parser left out by calling [`ts_parser_parse`] again with\n    the same arguments.\n 4. Parsing was cancelled due to the progress callback returning true. This callback\n    is passed in [`ts_parser_parse_with_options`] inside the [`TSParseOptions`] struct.\n\n [`read`]: TSInput::read\n [`payload`]: TSInput::payload\n [`encoding`]: TSInput::encoding\n [`bytes_read`]: TSInput::read"</span>]
    </span><span class="kw">pub fn </span>ts_parser_parse(
        self_: <span class="kw-2">*mut </span>TSParser,
        old_tree: <span class="kw-2">*const </span>TSTree,
        input: TSInput,
    ) -&gt; <span class="kw-2">*mut </span>TSTree;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code and create a syntax tree, with some options.\n\n See [`ts_parser_parse`] for more details.\n\n See [`TSParseOptions`] for more details on the options."</span>]
    </span><span class="kw">pub fn </span>ts_parser_parse_with_options(
        self_: <span class="kw-2">*mut </span>TSParser,
        old_tree: <span class="kw-2">*const </span>TSTree,
        input: TSInput,
        parse_options: TSParseOptions,
    ) -&gt; <span class="kw-2">*mut </span>TSTree;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code stored in one contiguous buffer.\n The first two parameters are the same as in the [`ts_parser_parse`] function\n above. The second two parameters indicate the location of the buffer and its\n length in bytes."</span>]
    </span><span class="kw">pub fn </span>ts_parser_parse_string(
        self_: <span class="kw-2">*mut </span>TSParser,
        old_tree: <span class="kw-2">*const </span>TSTree,
        string: <span class="kw-2">*const </span>::core::ffi::c_char,
        length: u32,
    ) -&gt; <span class="kw-2">*mut </span>TSTree;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code stored in one contiguous buffer with\n a given encoding. The first four parameters work the same as in the\n [`ts_parser_parse_string`] method above. The final parameter indicates whether\n the text is encoded as UTF8 or UTF16."</span>]
    </span><span class="kw">pub fn </span>ts_parser_parse_string_encoding(
        self_: <span class="kw-2">*mut </span>TSParser,
        old_tree: <span class="kw-2">*const </span>TSTree,
        string: <span class="kw-2">*const </span>::core::ffi::c_char,
        length: u32,
        encoding: TSInputEncoding,
    ) -&gt; <span class="kw-2">*mut </span>TSTree;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Instruct the parser to start the next parse from the beginning.\n\n If the parser previously failed because of a timeout or a cancellation, then\n by default, it will resume where it left off on the next call to\n [`ts_parser_parse`] or other parsing functions. If you don't want to resume,\n and instead intend to use this parser to parse some other document, you must\n call [`ts_parser_reset`] first."</span>]
    </span><span class="kw">pub fn </span>ts_parser_reset(self_: <span class="kw-2">*mut </span>TSParser);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the maximum duration in microseconds that parsing should be allowed to\n take before halting.\n\n If parsing takes longer than this, it will halt early, returning NULL.\n See [`ts_parser_parse`] for more information."</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_timeout_micros(self_: <span class="kw-2">*mut </span>TSParser, timeout_micros: u64);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the duration in microseconds that parsing is allowed to take."</span>]
    </span><span class="kw">pub fn </span>ts_parser_timeout_micros(self_: <span class="kw-2">*const </span>TSParser) -&gt; u64;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the parser's current cancellation flag pointer.\n\n If a non-null pointer is assigned, then the parser will periodically read\n from this pointer during parsing. If it reads a non-zero value, it will\n halt early, returning NULL. See [`ts_parser_parse`] for more information."</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_cancellation_flag(self_: <span class="kw-2">*mut </span>TSParser, flag: <span class="kw-2">*const </span>usize);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the parser's current cancellation flag pointer."</span>]
    </span><span class="kw">pub fn </span>ts_parser_cancellation_flag(self_: <span class="kw-2">*const </span>TSParser) -&gt; <span class="kw-2">*const </span>usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the logger that a parser should use during parsing.\n\n The parser does not take ownership over the logger payload. If a logger was\n previously assigned, the caller is responsible for releasing any memory\n owned by the previous logger."</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_logger(self_: <span class="kw-2">*mut </span>TSParser, logger: TSLogger);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the parser's current logger."</span>]
    </span><span class="kw">pub fn </span>ts_parser_logger(self_: <span class="kw-2">*const </span>TSParser) -&gt; TSLogger;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the file descriptor to which the parser should write debugging graphs\n during parsing. The graphs are formatted in the DOT language. You may want\n to pipe these graphs directly to a `dot(1)` process in order to generate\n SVG output. You can turn off this logging by passing a negative number."</span>]
    </span><span class="kw">pub fn </span>ts_parser_print_dot_graphs(self_: <span class="kw-2">*mut </span>TSParser, fd: ::core::ffi::c_int);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a shallow copy of the syntax tree. This is very fast.\n\n You need to copy a syntax tree in order to use it on more than one thread at\n a time, as syntax trees are not thread safe."</span>]
    </span><span class="kw">pub fn </span>ts_tree_copy(self_: <span class="kw-2">*const </span>TSTree) -&gt; <span class="kw-2">*mut </span>TSTree;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete the syntax tree, freeing all of the memory that it used."</span>]
    </span><span class="kw">pub fn </span>ts_tree_delete(self_: <span class="kw-2">*mut </span>TSTree);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the root node of the syntax tree."</span>]
    </span><span class="kw">pub fn </span>ts_tree_root_node(self_: <span class="kw-2">*const </span>TSTree) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the root node of the syntax tree, but with its position\n shifted forward by the given offset."</span>]
    </span><span class="kw">pub fn </span>ts_tree_root_node_with_offset(
        self_: <span class="kw-2">*const </span>TSTree,
        offset_bytes: u32,
        offset_extent: TSPoint,
    ) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the language that was used to parse the syntax tree."</span>]
    </span><span class="kw">pub fn </span>ts_tree_language(self_: <span class="kw-2">*const </span>TSTree) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the array of included ranges that was used to parse the syntax tree.\n\n The returned pointer must be freed by the caller."</span>]
    </span><span class="kw">pub fn </span>ts_tree_included_ranges(self_: <span class="kw-2">*const </span>TSTree, length: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*mut </span>TSRange;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Edit the syntax tree to keep it in sync with source code that has been\n edited.\n\n You must describe the edit both in terms of byte offsets and in terms of\n (row, column) coordinates."</span>]
    </span><span class="kw">pub fn </span>ts_tree_edit(self_: <span class="kw-2">*mut </span>TSTree, edit: <span class="kw-2">*const </span>TSInputEdit);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Compare an old edited syntax tree to a new syntax tree representing the same\n document, returning an array of ranges whose syntactic structure has changed.\n\n For this to work correctly, the old syntax tree must have been edited such\n that its ranges match up to the new tree. Generally, you'll want to call\n this function right after calling one of the [`ts_parser_parse`] functions.\n You need to pass the old tree that was passed to parse, as well as the new\n tree that was returned from that function.\n\n The returned ranges indicate areas where the hierarchical structure of syntax\n nodes (from root to leaf) has changed between the old and new trees. Characters\n outside these ranges have identical ancestor nodes in both trees.\n\n Note that the returned ranges may be slightly larger than the exact changed areas,\n but Tree-sitter attempts to make them as small as possible.\n\n The returned array is allocated using `malloc` and the caller is responsible\n for freeing it using `free`. The length of the array will be written to the\n given `length` pointer."</span>]
    </span><span class="kw">pub fn </span>ts_tree_get_changed_ranges(
        old_tree: <span class="kw-2">*const </span>TSTree,
        new_tree: <span class="kw-2">*const </span>TSTree,
        length: <span class="kw-2">*mut </span>u32,
    ) -&gt; <span class="kw-2">*mut </span>TSRange;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Write a DOT graph describing the syntax tree to the given file."</span>]
    </span><span class="kw">pub fn </span>ts_tree_print_dot_graph(self_: <span class="kw-2">*const </span>TSTree, file_descriptor: ::core::ffi::c_int);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's type as a null-terminated string."</span>]
    </span><span class="kw">pub fn </span>ts_node_type(self_: TSNode) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's type as a numerical id."</span>]
    </span><span class="kw">pub fn </span>ts_node_symbol(self_: TSNode) -&gt; TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's language."</span>]
    </span><span class="kw">pub fn </span>ts_node_language(self_: TSNode) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's type as it appears in the grammar ignoring aliases as a\n null-terminated string."</span>]
    </span><span class="kw">pub fn </span>ts_node_grammar_type(self_: TSNode) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's type as a numerical id as it appears in the grammar ignoring\n aliases. This should be used in [`ts_language_next_state`] instead of\n [`ts_node_symbol`]."</span>]
    </span><span class="kw">pub fn </span>ts_node_grammar_symbol(self_: TSNode) -&gt; TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's start byte."</span>]
    </span><span class="kw">pub fn </span>ts_node_start_byte(self_: TSNode) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's start position in terms of rows and columns."</span>]
    </span><span class="kw">pub fn </span>ts_node_start_point(self_: TSNode) -&gt; TSPoint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's end byte."</span>]
    </span><span class="kw">pub fn </span>ts_node_end_byte(self_: TSNode) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's end position in terms of rows and columns."</span>]
    </span><span class="kw">pub fn </span>ts_node_end_point(self_: TSNode) -&gt; TSPoint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get an S-expression representing the node as a string.\n\n This string is allocated with `malloc` and the caller is responsible for\n freeing it using `free`."</span>]
    </span><span class="kw">pub fn </span>ts_node_string(self_: TSNode) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is null. Functions like [`ts_node_child`] and\n [`ts_node_next_sibling`] will return a null node to indicate that no such node\n was found."</span>]
    </span><span class="kw">pub fn </span>ts_node_is_null(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is *named*. Named nodes correspond to named rules in the\n grammar, whereas *anonymous* nodes correspond to string literals in the\n grammar."</span>]
    </span><span class="kw">pub fn </span>ts_node_is_named(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is *missing*. Missing nodes are inserted by the parser in\n order to recover from certain kinds of syntax errors."</span>]
    </span><span class="kw">pub fn </span>ts_node_is_missing(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is *extra*. Extra nodes represent things like comments,\n which are not required the grammar, but can appear anywhere."</span>]
    </span><span class="kw">pub fn </span>ts_node_is_extra(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if a syntax node has been edited."</span>]
    </span><span class="kw">pub fn </span>ts_node_has_changes(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is a syntax error or contains any syntax errors."</span>]
    </span><span class="kw">pub fn </span>ts_node_has_error(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the node is a syntax error."</span>]
    </span><span class="kw">pub fn </span>ts_node_is_error(self_: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get this node's parse state."</span>]
    </span><span class="kw">pub fn </span>ts_node_parse_state(self_: TSNode) -&gt; TSStateId;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the parse state after this node."</span>]
    </span><span class="kw">pub fn </span>ts_node_next_parse_state(self_: TSNode) -&gt; TSStateId;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's immediate parent.\n Prefer [`ts_node_child_with_descendant`] for\n iterating over the node's ancestors."</span>]
    </span><span class="kw">pub fn </span>ts_node_parent(self_: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node that contains `descendant`.\n\n Note that this can return `descendant` itself."</span>]
    </span><span class="kw">pub fn </span>ts_node_child_with_descendant(self_: TSNode, descendant: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's child at the given index, where zero represents the first\n child."</span>]
    </span><span class="kw">pub fn </span>ts_node_child(self_: TSNode, child_index: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the field name for node's child at the given index, where zero represents\n the first child. Returns NULL, if no field is found."</span>]
    </span><span class="kw">pub fn </span>ts_node_field_name_for_child(
        self_: TSNode,
        child_index: u32,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the field name for node's named child at the given index, where zero\n represents the first named child. Returns NULL, if no field is found."</span>]
    </span><span class="kw">pub fn </span>ts_node_field_name_for_named_child(
        self_: TSNode,
        named_child_index: u32,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's number of children."</span>]
    </span><span class="kw">pub fn </span>ts_node_child_count(self_: TSNode) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's *named* child at the given index.\n\n See also [`ts_node_is_named`]."</span>]
    </span><span class="kw">pub fn </span>ts_node_named_child(self_: TSNode, child_index: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's number of *named* children.\n\n See also [`ts_node_is_named`]."</span>]
    </span><span class="kw">pub fn </span>ts_node_named_child_count(self_: TSNode) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's child with the given field name."</span>]
    </span><span class="kw">pub fn </span>ts_node_child_by_field_name(
        self_: TSNode,
        name: <span class="kw-2">*const </span>::core::ffi::c_char,
        name_length: u32,
    ) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's child with the given numerical field id.\n\n You can convert a field name to an id using the\n [`ts_language_field_id_for_name`] function."</span>]
    </span><span class="kw">pub fn </span>ts_node_child_by_field_id(self_: TSNode, field_id: TSFieldId) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's next / previous sibling."</span>]
    </span><span class="kw">pub fn </span>ts_node_next_sibling(self_: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_node_prev_sibling(self_: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's next / previous *named* sibling."</span>]
    </span><span class="kw">pub fn </span>ts_node_next_named_sibling(self_: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_node_prev_named_sibling(self_: TSNode) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's first child that contains or starts after the given byte offset."</span>]
    </span><span class="kw">pub fn </span>ts_node_first_child_for_byte(self_: TSNode, byte: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's first named child that contains or starts after the given byte offset."</span>]
    </span><span class="kw">pub fn </span>ts_node_first_named_child_for_byte(self_: TSNode, byte: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the node's number of descendants, including one for the node itself."</span>]
    </span><span class="kw">pub fn </span>ts_node_descendant_count(self_: TSNode) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the smallest node within this node that spans the given range of bytes\n or (row, column) positions."</span>]
    </span><span class="kw">pub fn </span>ts_node_descendant_for_byte_range(self_: TSNode, start: u32, end: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_node_descendant_for_point_range(
        self_: TSNode,
        start: TSPoint,
        end: TSPoint,
    ) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the smallest named node within this node that spans the given range of\n bytes or (row, column) positions."</span>]
    </span><span class="kw">pub fn </span>ts_node_named_descendant_for_byte_range(self_: TSNode, start: u32, end: u32) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_node_named_descendant_for_point_range(
        self_: TSNode,
        start: TSPoint,
        end: TSPoint,
    ) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Edit the node to keep it in-sync with source code that has been edited.\n\n This function is only rarely needed. When you edit a syntax tree with the\n [`ts_tree_edit`] function, all of the nodes that you retrieve from the tree\n afterward will already reflect the edit. You only need to use [`ts_node_edit`]\n when you have a [`TSNode`] instance that you want to keep and continue to use\n after an edit."</span>]
    </span><span class="kw">pub fn </span>ts_node_edit(self_: <span class="kw-2">*mut </span>TSNode, edit: <span class="kw-2">*const </span>TSInputEdit);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if two nodes are identical."</span>]
    </span><span class="kw">pub fn </span>ts_node_eq(self_: TSNode, other: TSNode) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a new tree cursor starting from the given node.\n\n A tree cursor allows you to walk a syntax tree more efficiently than is\n possible using the [`TSNode`] functions. It is a mutable object that is always\n on a certain syntax node, and can be moved imperatively to different nodes.\n\n Note that the given node is considered the root of the cursor,\n and the cursor cannot walk outside this node."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_new(node: TSNode) -&gt; TSTreeCursor;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete a tree cursor, freeing all of the memory that it used."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_delete(self_: <span class="kw-2">*mut </span>TSTreeCursor);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Re-initialize a tree cursor to start at the original node that the cursor was\n constructed with."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_reset(self_: <span class="kw-2">*mut </span>TSTreeCursor, node: TSNode);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Re-initialize a tree cursor to the same position as another cursor.\n\n Unlike [`ts_tree_cursor_reset`], this will not lose parent information and\n allows reusing already created cursors."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_reset_to(dst: <span class="kw-2">*mut </span>TSTreeCursor, src: <span class="kw-2">*const </span>TSTreeCursor);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the tree cursor's current node."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_current_node(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSNode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the field name of the tree cursor's current node.\n\n This returns `NULL` if the current node doesn't have a field.\n See also [`ts_node_child_by_field_name`]."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_current_field_name(
        self_: <span class="kw-2">*const </span>TSTreeCursor,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the field id of the tree cursor's current node.\n\n This returns zero if the current node doesn't have a field.\n See also [`ts_node_child_by_field_id`], [`ts_language_field_id_for_name`]."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_current_field_id(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSFieldId;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the parent of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there was no parent node (the cursor was already on the root node).\n\n Note that the node the cursor was constructed with is considered the root\n of the cursor, and the cursor cannot walk outside this node."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_parent(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the next sibling of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there was no next sibling node.\n\n Note that the node the cursor was constructed with is considered the root\n of the cursor, and the cursor cannot walk outside this node."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_next_sibling(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the previous sibling of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false` if\n there was no previous sibling node.\n\n Note, that this function may be slower than\n [`ts_tree_cursor_goto_next_sibling`] due to how node positions are stored. In\n the worst case, this will need to iterate through all the children up to the\n previous sibling node to recalculate its position. Also note that the node the cursor\n was constructed with is considered the root of the cursor, and the cursor cannot\n walk outside this node."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_previous_sibling(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the first child of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there were no children."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_first_child(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the last child of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false` if\n there were no children.\n\n Note that this function may be slower than [`ts_tree_cursor_goto_first_child`]\n because it needs to iterate through all the children to compute the child's\n position."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_last_child(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the node that is the nth descendant of\n the original node that the cursor was constructed with, where\n zero represents the original node itself."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_descendant(self_: <span class="kw-2">*mut </span>TSTreeCursor, goal_descendant_index: u32);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the index of the cursor's current node out of all of the\n descendants of the original node that the cursor was constructed with."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_current_descendant_index(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the depth of the cursor's current node relative to the original\n node that the cursor was constructed with."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_current_depth(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Move the cursor to the first child of its current node that contains or starts after\n the given byte offset or point.\n\n This returns the index of the child node if one was found, and returns -1\n if no such child was found."</span>]
    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_first_child_for_byte(
        self_: <span class="kw-2">*mut </span>TSTreeCursor,
        goal_byte: u32,
    ) -&gt; i64;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_tree_cursor_goto_first_child_for_point(
        self_: <span class="kw-2">*mut </span>TSTreeCursor,
        goal_point: TSPoint,
    ) -&gt; i64;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_tree_cursor_copy(cursor: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSTreeCursor;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a new query from a string containing one or more S-expression\n patterns. The query is associated with a particular language, and can\n only be run on syntax nodes parsed with that language.\n\n If all of the given patterns are valid, this returns a [`TSQuery`].\n If a pattern is invalid, this returns `NULL`, and provides two pieces\n of information about the problem:\n 1. The byte offset of the error is written to the `error_offset` parameter.\n 2. The type of error is written to the `error_type` parameter."</span>]
    </span><span class="kw">pub fn </span>ts_query_new(
        language: <span class="kw-2">*const </span>TSLanguage,
        source: <span class="kw-2">*const </span>::core::ffi::c_char,
        source_len: u32,
        error_offset: <span class="kw-2">*mut </span>u32,
        error_type: <span class="kw-2">*mut </span>TSQueryError,
    ) -&gt; <span class="kw-2">*mut </span>TSQuery;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete a query, freeing all of the memory that it used."</span>]
    </span><span class="kw">pub fn </span>ts_query_delete(self_: <span class="kw-2">*mut </span>TSQuery);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the number of patterns, captures, or string literals in the query."</span>]
    </span><span class="kw">pub fn </span>ts_query_pattern_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_capture_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_string_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the byte offset where the given pattern starts in the query's source.\n\n This can be useful when combining queries by concatenating their source\n code strings."</span>]
    </span><span class="kw">pub fn </span>ts_query_start_byte_for_pattern(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the byte offset where the given pattern ends in the query's source.\n\n This can be useful when combining queries by concatenating their source\n code strings."</span>]
    </span><span class="kw">pub fn </span>ts_query_end_byte_for_pattern(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get all of the predicates for the given pattern in the query.\n\n The predicates are represented as a single array of steps. There are three\n types of steps in this array, which correspond to the three legal values for\n the `type` field:\n - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names\n    of captures. Their `value_id` can be used with the\n   [`ts_query_capture_name_for_id`] function to obtain the name of the capture.\n - `TSQueryPredicateStepTypeString` - Steps with this type represent literal\n    strings. Their `value_id` can be used with the\n    [`ts_query_string_value_for_id`] function to obtain their string value.\n - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*\n    that represent the end of an individual predicate. If a pattern has two\n    predicates, then there will be two steps with this `type` in the array."</span>]
    </span><span class="kw">pub fn </span>ts_query_predicates_for_pattern(
        self_: <span class="kw-2">*const </span>TSQuery,
        pattern_index: u32,
        step_count: <span class="kw-2">*mut </span>u32,
    ) -&gt; <span class="kw-2">*const </span>TSQueryPredicateStep;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_is_pattern_rooted(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_is_pattern_non_local(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_is_pattern_guaranteed_at_step(self_: <span class="kw-2">*const </span>TSQuery, byte_offset: u32) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the name and length of one of the query's captures, or one of the\n query's string literals. Each capture and string is associated with a\n numeric id based on the order that it appeared in the query's source."</span>]
    </span><span class="kw">pub fn </span>ts_query_capture_name_for_id(
        self_: <span class="kw-2">*const </span>TSQuery,
        index: u32,
        length: <span class="kw-2">*mut </span>u32,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the quantifier of the query's captures. Each capture is * associated\n with a numeric id based on the order that it appeared in the query's source."</span>]
    </span><span class="kw">pub fn </span>ts_query_capture_quantifier_for_id(
        self_: <span class="kw-2">*const </span>TSQuery,
        pattern_index: u32,
        capture_index: u32,
    ) -&gt; TSQuantifier;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_string_value_for_id(
        self_: <span class="kw-2">*const </span>TSQuery,
        index: u32,
        length: <span class="kw-2">*mut </span>u32,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Disable a certain capture within a query.\n\n This prevents the capture from being returned in matches, and also avoids\n any resource usage associated with recording the capture. Currently, there\n is no way to undo this."</span>]
    </span><span class="kw">pub fn </span>ts_query_disable_capture(
        self_: <span class="kw-2">*mut </span>TSQuery,
        name: <span class="kw-2">*const </span>::core::ffi::c_char,
        length: u32,
    );
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Disable a certain pattern within a query.\n\n This prevents the pattern from matching and removes most of the overhead\n associated with the pattern. Currently, there is no way to undo this."</span>]
    </span><span class="kw">pub fn </span>ts_query_disable_pattern(self_: <span class="kw-2">*mut </span>TSQuery, pattern_index: u32);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a new cursor for executing a given query.\n\n The cursor stores the state that is needed to iteratively search\n for matches. To use the query cursor, first call [`ts_query_cursor_exec`]\n to start running a given query on a given syntax node. Then, there are\n two options for consuming the results of the query:\n 1. Repeatedly call [`ts_query_cursor_next_match`] to iterate over all of the\n    *matches* in the order that they were found. Each match contains the\n    index of the pattern that matched, and an array of captures. Because\n    multiple patterns can match the same set of nodes, one match may contain\n    captures that appear *before* some of the captures from a previous match.\n 2. Repeatedly call [`ts_query_cursor_next_capture`] to iterate over all of the\n    individual *captures* in the order that they appear. This is useful if\n    don't care about which pattern matched, and just want a single ordered\n    sequence of captures.\n\n If you don't care about consuming all of the results, you can stop calling\n [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] at any point.\n  You can then start executing another query on another node by calling\n  [`ts_query_cursor_exec`] again."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_new() -&gt; <span class="kw-2">*mut </span>TSQueryCursor;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete a query cursor, freeing all of the memory that it used."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_delete(self_: <span class="kw-2">*mut </span>TSQueryCursor);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Start running a given query on a given node."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_exec(self_: <span class="kw-2">*mut </span>TSQueryCursor, query: <span class="kw-2">*const </span>TSQuery, node: TSNode);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Start running a given query on a given node, with some options."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_exec_with_options(
        self_: <span class="kw-2">*mut </span>TSQueryCursor,
        query: <span class="kw-2">*const </span>TSQuery,
        node: TSNode,
        query_options: <span class="kw-2">*const </span>TSQueryCursorOptions,
    );
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Manage the maximum number of in-progress matches allowed by this query\n cursor.\n\n Query cursors have an optional maximum capacity for storing lists of\n in-progress captures. If this capacity is exceeded, then the\n earliest-starting match will silently be dropped to make room for further\n matches. This maximum capacity is optional — by default, query cursors allow\n any number of pending matches, dynamically allocating new space for them as\n needed as the query is executed."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_did_exceed_match_limit(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_cursor_match_limit(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_cursor_set_match_limit(self_: <span class="kw-2">*mut </span>TSQueryCursor, limit: u32);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the maximum duration in microseconds that query execution should be allowed to\n take before halting.\n\n If query execution takes longer than this, it will halt early, returning NULL.\n See [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] for more information."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_set_timeout_micros(self_: <span class="kw-2">*mut </span>TSQueryCursor, timeout_micros: u64);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the duration in microseconds that query execution is allowed to take.\n\n This is set via [`ts_query_cursor_set_timeout_micros`]."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_timeout_micros(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; u64;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the range of bytes in which the query will be executed.\n\n The query cursor will return matches that intersect with the given point range.\n This means that a match may be returned even if some of its captures fall\n outside the specified range, as long as at least part of the match\n overlaps with the range.\n\n For example, if a query pattern matches a node that spans a larger area\n than the specified range, but part of that node intersects with the range,\n the entire match will be returned.\n\n This will return `false` if the start byte is greater than the end byte, otherwise\n it will return `true`."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_set_byte_range(
        self_: <span class="kw-2">*mut </span>TSQueryCursor,
        start_byte: u32,
        end_byte: u32,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the range of (row, column) positions in which the query will be executed.\n\n The query cursor will return matches that intersect with the given point range.\n This means that a match may be returned even if some of its captures fall\n outside the specified range, as long as at least part of the match\n overlaps with the range.\n\n For example, if a query pattern matches a node that spans a larger area\n than the specified range, but part of that node intersects with the range,\n the entire match will be returned.\n\n This will return `false` if the start point is greater than the end point, otherwise\n it will return `true`."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_set_point_range(
        self_: <span class="kw-2">*mut </span>TSQueryCursor,
        start_point: TSPoint,
        end_point: TSPoint,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Advance to the next match of the currently running query.\n\n If there is a match, write it to `*match` and return `true`.\n Otherwise, return `false`."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_next_match(self_: <span class="kw-2">*mut </span>TSQueryCursor, match_: <span class="kw-2">*mut </span>TSQueryMatch)
        -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ts_query_cursor_remove_match(self_: <span class="kw-2">*mut </span>TSQueryCursor, match_id: u32);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Advance to the next capture of the currently running query.\n\n If there is a capture, write its match to `*match` and its index within\n the match's capture list to `*capture_index`. Otherwise, return `false`."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_next_capture(
        self_: <span class="kw-2">*mut </span>TSQueryCursor,
        match_: <span class="kw-2">*mut </span>TSQueryMatch,
        capture_index: <span class="kw-2">*mut </span>u32,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the maximum start depth for a query cursor.\n\n This prevents cursors from exploring children nodes at a certain depth.\n Note if a pattern includes many children, then they will still be checked.\n\n The zero max start depth value can be used as a special behavior and\n it helps to destructure a subtree by staying on a node and using captures\n for interested parts. Note that the zero max start depth only limit a search\n depth for a pattern's root node but other nodes that are parts of the pattern\n may be searched at any depth what defined by the pattern structure.\n\n Set to `UINT32_MAX` to remove the maximum start depth."</span>]
    </span><span class="kw">pub fn </span>ts_query_cursor_set_max_start_depth(self_: <span class="kw-2">*mut </span>TSQueryCursor, max_start_depth: u32);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get another reference to the given language."</span>]
    </span><span class="kw">pub fn </span>ts_language_copy(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Free any dynamically-allocated resources for this language, if\n this is the last reference."</span>]
    </span><span class="kw">pub fn </span>ts_language_delete(self_: <span class="kw-2">*const </span>TSLanguage);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the number of distinct node types in the language."</span>]
    </span><span class="kw">pub fn </span>ts_language_symbol_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the number of valid states in this language."</span>]
    </span><span class="kw">pub fn </span>ts_language_state_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the numerical id for the given node type string."</span>]
    </span><span class="kw">pub fn </span>ts_language_symbol_for_name(
        self_: <span class="kw-2">*const </span>TSLanguage,
        string: <span class="kw-2">*const </span>::core::ffi::c_char,
        length: u32,
        is_named: bool,
    ) -&gt; TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the number of distinct field names in the language."</span>]
    </span><span class="kw">pub fn </span>ts_language_field_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the field name string for the given numerical id."</span>]
    </span><span class="kw">pub fn </span>ts_language_field_name_for_id(
        self_: <span class="kw-2">*const </span>TSLanguage,
        id: TSFieldId,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the numerical id for the given field name string."</span>]
    </span><span class="kw">pub fn </span>ts_language_field_id_for_name(
        self_: <span class="kw-2">*const </span>TSLanguage,
        name: <span class="kw-2">*const </span>::core::ffi::c_char,
        name_length: u32,
    ) -&gt; TSFieldId;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get a list of all supertype symbols for the language."</span>]
    </span><span class="kw">pub fn </span>ts_language_supertypes(self_: <span class="kw-2">*const </span>TSLanguage, length: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*const </span>TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get a list of all subtype symbol ids for a given supertype symbol.\n\n See [`ts_language_supertypes`] for fetching all supertype symbols."</span>]
    </span><span class="kw">pub fn </span>ts_language_subtypes(
        self_: <span class="kw-2">*const </span>TSLanguage,
        supertype: TSSymbol,
        length: <span class="kw-2">*mut </span>u32,
    ) -&gt; <span class="kw-2">*const </span>TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get a node type string for the given numerical id."</span>]
    </span><span class="kw">pub fn </span>ts_language_symbol_name(
        self_: <span class="kw-2">*const </span>TSLanguage,
        symbol: TSSymbol,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check whether the given node type id belongs to named nodes, anonymous nodes,\n or a hidden nodes.\n\n See also [`ts_node_is_named`]. Hidden nodes are never returned from the API."</span>]
    </span><span class="kw">pub fn </span>ts_language_symbol_type(self_: <span class="kw-2">*const </span>TSLanguage, symbol: TSSymbol) -&gt; TSSymbolType;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_language_abi_version`] instead, this will be removed in 0.26.\n\n Get the ABI version number for this language. This version number is used\n to ensure that languages were generated by a compatible version of\n Tree-sitter.\n\n See also [`ts_parser_set_language`]."</span>]
    </span><span class="kw">pub fn </span>ts_language_version(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the ABI version number for this language. This version number is used\n to ensure that languages were generated by a compatible version of\n Tree-sitter.\n\n See also [`ts_parser_set_language`]."</span>]
    </span><span class="kw">pub fn </span>ts_language_abi_version(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the metadata for this language. This information is generated by the\n CLI, and relies on the language author providing the correct metadata in\n the language's `tree-sitter.json` file.\n\n See also [`TSMetadata`]."</span>]
    </span><span class="kw">pub fn </span>ts_language_metadata(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>TSLanguageMetadata;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the next parse state. Combine this with lookahead iterators to generate\n completion suggestions or valid symbols in error nodes. Use\n [`ts_node_grammar_symbol`] for valid symbols."</span>]
    </span><span class="kw">pub fn </span>ts_language_next_state(
        self_: <span class="kw-2">*const </span>TSLanguage,
        state: TSStateId,
        symbol: TSSymbol,
    ) -&gt; TSStateId;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the name of this language. This returns `NULL` in older parsers."</span>]
    </span><span class="kw">pub fn </span>ts_language_name(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a new lookahead iterator for the given language and parse state.\n\n This returns `NULL` if state is invalid for the language.\n\n Repeatedly using [`ts_lookahead_iterator_next`] and\n [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the\n given parse state. Newly created lookahead iterators will contain the `ERROR`\n symbol.\n\n Lookahead iterators can be useful to generate suggestions and improve syntax\n error diagnostics. To get symbols valid in an ERROR node, use the lookahead\n iterator on its first leaf node state. For `MISSING` nodes, a lookahead\n iterator created on the previous non-extra leaf node may be appropriate."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_new(
        self_: <span class="kw-2">*const </span>TSLanguage,
        state: TSStateId,
    ) -&gt; <span class="kw-2">*mut </span>TSLookaheadIterator;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Delete a lookahead iterator freeing all the memory used."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_delete(self_: <span class="kw-2">*mut </span>TSLookaheadIterator);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Reset the lookahead iterator to another state.\n\n This returns `true` if the iterator was reset to the given state and `false`\n otherwise."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_reset_state(
        self_: <span class="kw-2">*mut </span>TSLookaheadIterator,
        state: TSStateId,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Reset the lookahead iterator.\n\n This returns `true` if the language was set successfully and `false`\n otherwise."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_reset(
        self_: <span class="kw-2">*mut </span>TSLookaheadIterator,
        language: <span class="kw-2">*const </span>TSLanguage,
        state: TSStateId,
    ) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the current language of the lookahead iterator."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_language(self_: <span class="kw-2">*const </span>TSLookaheadIterator) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Advance the lookahead iterator to the next symbol.\n\n This returns `true` if there is a new symbol and `false` otherwise."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_next(self_: <span class="kw-2">*mut </span>TSLookaheadIterator) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the current symbol of the lookahead iterator;"</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_current_symbol(self_: <span class="kw-2">*const </span>TSLookaheadIterator) -&gt; TSSymbol;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the current symbol type of the lookahead iterator as a null terminated\n string."</span>]
    </span><span class="kw">pub fn </span>ts_lookahead_iterator_current_symbol_name(
        self_: <span class="kw-2">*const </span>TSLookaheadIterator,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>wasm_engine_t {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub type </span>TSWasmEngine = wasm_engine_t;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSWasmStore {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub const </span>TSWasmErrorKindNone: TSWasmErrorKind = <span class="number">0</span>;
<span class="kw">pub const </span>TSWasmErrorKindParse: TSWasmErrorKind = <span class="number">1</span>;
<span class="kw">pub const </span>TSWasmErrorKindCompile: TSWasmErrorKind = <span class="number">2</span>;
<span class="kw">pub const </span>TSWasmErrorKindInstantiate: TSWasmErrorKind = <span class="number">3</span>;
<span class="kw">pub const </span>TSWasmErrorKindAllocate: TSWasmErrorKind = <span class="number">4</span>;
<span class="kw">pub type </span>TSWasmErrorKind = ::core::ffi::c_uint;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>TSWasmError {
    <span class="kw">pub </span>kind: TSWasmErrorKind,
    <span class="kw">pub </span>message: <span class="kw-2">*mut </span>::core::ffi::c_char,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a Wasm store."</span>]
    </span><span class="kw">pub fn </span>ts_wasm_store_new(
        engine: <span class="kw-2">*mut </span>TSWasmEngine,
        error: <span class="kw-2">*mut </span>TSWasmError,
    ) -&gt; <span class="kw-2">*mut </span>TSWasmStore;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Free the memory associated with the given Wasm store."</span>]
    </span><span class="kw">pub fn </span>ts_wasm_store_delete(arg1: <span class="kw-2">*mut </span>TSWasmStore);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Create a language from a buffer of Wasm. The resulting language behaves\n like any other Tree-sitter language, except that in order to use it with\n a parser, that parser must have a Wasm store. Note that the language\n can be used with any Wasm store, it doesn't need to be the same store that\n was used to originally load it."</span>]
    </span><span class="kw">pub fn </span>ts_wasm_store_load_language(
        arg1: <span class="kw-2">*mut </span>TSWasmStore,
        name: <span class="kw-2">*const </span>::core::ffi::c_char,
        wasm: <span class="kw-2">*const </span>::core::ffi::c_char,
        wasm_len: u32,
        error: <span class="kw-2">*mut </span>TSWasmError,
    ) -&gt; <span class="kw-2">*const </span>TSLanguage;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Get the number of languages instantiated in the given wasm store."</span>]
    </span><span class="kw">pub fn </span>ts_wasm_store_language_count(arg1: <span class="kw-2">*const </span>TSWasmStore) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Check if the language came from a Wasm module. If so, then in order to use\n this language with a Parser, that parser must have a Wasm store assigned."</span>]
    </span><span class="kw">pub fn </span>ts_language_is_wasm(arg1: <span class="kw-2">*const </span>TSLanguage) -&gt; bool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Assign the given Wasm store to the parser. A parser must have a Wasm store\n in order to use Wasm languages."</span>]
    </span><span class="kw">pub fn </span>ts_parser_set_wasm_store(arg1: <span class="kw-2">*mut </span>TSParser, arg2: <span class="kw-2">*mut </span>TSWasmStore);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Remove the parser's current Wasm store and return it. This returns NULL if\n the parser doesn't have a Wasm store."</span>]
    </span><span class="kw">pub fn </span>ts_parser_take_wasm_store(arg1: <span class="kw-2">*mut </span>TSParser) -&gt; <span class="kw-2">*mut </span>TSWasmStore;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Set the allocation functions used by the library.\n\n By default, Tree-sitter uses the standard libc allocation functions,\n but aborts the process when an allocation fails. This function lets\n you supply alternative allocation functions at runtime.\n\n If you pass `NULL` for any parameter, Tree-sitter will switch back to\n its default implementation of that function.\n\n If you call this function after the library has already been used, then\n you must ensure that either:\n  1. All the existing objects have been freed.\n  2. The new allocator shares its state with the old one, so it is capable\n     of freeing memory that was allocated by the old allocator."</span>]
    </span><span class="kw">pub fn </span>ts_set_allocator(
        new_malloc: ::core::option::Option&lt;
            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: usize) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
        &gt;,
        new_calloc: ::core::option::Option&lt;
            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: usize, arg2: usize) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
        &gt;,
        new_realloc: ::core::option::Option&lt;
            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
                arg1: <span class="kw-2">*mut </span>::core::ffi::c_void,
                arg2: usize,
            ) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
        &gt;,
        new_free: ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: <span class="kw-2">*mut </span>::core::ffi::c_void)&gt;,
    );
}
</code></pre></div></section></main></body></html>