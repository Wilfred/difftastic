<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/ignore-0.4.18/src/types.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>types.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../ignore/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../ignore/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../ignore/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
The types module provides a way of associating globs on file names to file
types.

This can be used to match specific types of files. For example, among
the default file types provided, the Rust file type is defined to be `*.rs`
with name `rust`. Similarly, the C file type is defined to be `*.{c,h}` with
name `c`.

Note that the set of default types may change over time.

# Example

This shows how to create and use a simple file type matcher using the default
file types defined in this crate.

```
use ignore::types::TypesBuilder;

let mut builder = TypesBuilder::new();
builder.add_defaults();
builder.select(&quot;rust&quot;);
let matcher = builder.build().unwrap();

assert!(matcher.matched(&quot;foo.rs&quot;, false).is_whitelist());
assert!(matcher.matched(&quot;foo.c&quot;, false).is_ignore());
```

# Example: negation

This is like the previous example, but shows how negating a file type works.
That is, this will let us match file paths that *don&#39;t* correspond to a
particular file type.

```
use ignore::types::TypesBuilder;

let mut builder = TypesBuilder::new();
builder.add_defaults();
builder.negate(&quot;c&quot;);
let matcher = builder.build().unwrap();

assert!(matcher.matched(&quot;foo.rs&quot;, false).is_none());
assert!(matcher.matched(&quot;foo.c&quot;, false).is_ignore());
```

# Example: custom file type definitions

This shows how to extend this library default file type definitions with
your own.

```
use ignore::types::TypesBuilder;

let mut builder = TypesBuilder::new();
builder.add_defaults();
builder.add(&quot;foo&quot;, &quot;*.foo&quot;);
// Another way of adding a file type definition.
// This is useful when accepting input from an end user.
builder.add_def(&quot;bar:*.bar&quot;);
// Note: we only select `foo`, not `bar`.
builder.select(&quot;foo&quot;);
let matcher = builder.build().unwrap();

assert!(matcher.matched(&quot;x.foo&quot;, false).is_whitelist());
// This is ignored because we only selected the `foo` file type.
assert!(matcher.matched(&quot;x.bar&quot;, false).is_ignore());
```

We can also add file type definitions based on other definitions.

```
use ignore::types::TypesBuilder;

let mut builder = TypesBuilder::new();
builder.add_defaults();
builder.add(&quot;foo&quot;, &quot;*.foo&quot;);
builder.add_def(&quot;bar:include:foo,cpp&quot;);
builder.select(&quot;bar&quot;);
let matcher = builder.build().unwrap();

assert!(matcher.matched(&quot;x.foo&quot;, false).is_whitelist());
assert!(matcher.matched(&quot;y.cpp&quot;, false).is_whitelist());
```
*/

</span><span class="kw">use </span>std::cell::RefCell;
<span class="kw">use </span>std::collections::HashMap;
<span class="kw">use </span>std::path::Path;
<span class="kw">use </span>std::sync::Arc;

<span class="kw">use </span>globset::{GlobBuilder, GlobSet, GlobSetBuilder};
<span class="kw">use </span>regex::Regex;
<span class="kw">use </span>thread_local::ThreadLocal;

<span class="kw">use </span><span class="kw">crate</span>::default_types::DEFAULT_TYPES;
<span class="kw">use </span><span class="kw">crate</span>::pathutil::file_name;
<span class="kw">use crate</span>::{Error, Match};

<span class="doccomment">/// Glob represents a single glob in a set of file type definitions.
///
/// There may be more than one glob for a particular file type.
///
/// This is used to report information about the highest precedent glob
/// that matched.
///
/// Note that not all matches necessarily correspond to a specific glob.
/// For example, if there are one or more selections and a file path doesn&#39;t
/// match any of those selections, then the file path is considered to be
/// ignored.
///
/// The lifetime `&#39;a` refers to the lifetime of the underlying file type
/// definition, which corresponds to the lifetime of the file type matcher.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>Glob&lt;<span class="lifetime">&#39;a</span>&gt;(GlobInner&lt;<span class="lifetime">&#39;a</span>&gt;);

<span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">enum </span>GlobInner&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="doccomment">/// No glob matched, but the file path should still be ignored.
    </span>UnmatchedIgnore,
    <span class="doccomment">/// A glob matched.
    </span>Matched {
        <span class="doccomment">/// The file type definition which provided the glob.
        </span>def: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>FileTypeDef,
        <span class="doccomment">/// The index of the glob that matched inside the file type definition.
        </span>which: usize,
        <span class="doccomment">/// Whether the selection was negated or not.
        </span>negated: bool,
    },
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Glob&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>unmatched() -&gt; Glob&lt;<span class="lifetime">&#39;a</span>&gt; {
        Glob(GlobInner::UnmatchedIgnore)
    }

    <span class="doccomment">/// Return the file type definition that matched, if one exists. A file type
    /// definition always exists when a specific definition matches a file
    /// path.
    </span><span class="kw">pub fn </span>file_type_def(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>FileTypeDef&gt; {
        <span class="kw">match </span><span class="self">self </span>{
            Glob(GlobInner::UnmatchedIgnore) =&gt; <span class="prelude-val">None</span>,
            Glob(GlobInner::Matched { def, .. }) =&gt; <span class="prelude-val">Some</span>(def),
        }
    }
}

<span class="doccomment">/// A single file type definition.
///
/// File type definitions can be retrieved in aggregate from a file type
/// matcher. File type definitions are also reported when its responsible
/// for a match.
</span><span class="attribute">#[derive(Clone, Debug, Eq, PartialEq)]
</span><span class="kw">pub struct </span>FileTypeDef {
    name: String,
    globs: Vec&lt;String&gt;,
}

<span class="kw">impl </span>FileTypeDef {
    <span class="doccomment">/// Return the name of this file type.
    </span><span class="kw">pub fn </span>name(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>str {
        <span class="kw-2">&amp;</span><span class="self">self</span>.name
    }

    <span class="doccomment">/// Return the globs used to recognize this file type.
    </span><span class="kw">pub fn </span>globs(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[String] {
        <span class="kw-2">&amp;</span><span class="self">self</span>.globs
    }
}

<span class="doccomment">/// Types is a file type matcher.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>Types {
    <span class="doccomment">/// All of the file type definitions, sorted lexicographically by name.
    </span>defs: Vec&lt;FileTypeDef&gt;,
    <span class="doccomment">/// All of the selections made by the user.
    </span>selections: Vec&lt;Selection&lt;FileTypeDef&gt;&gt;,
    <span class="doccomment">/// Whether there is at least one Selection::Select in our selections.
    /// When this is true, a Match::None is converted to Match::Ignore.
    </span>has_selected: bool,
    <span class="doccomment">/// A mapping from glob index in the set to two indices. The first is an
    /// index into `selections` and the second is an index into the
    /// corresponding file type definition&#39;s list of globs.
    </span>glob_to_selection: Vec&lt;(usize, usize)&gt;,
    <span class="doccomment">/// The set of all glob selections, used for actual matching.
    </span>set: GlobSet,
    <span class="doccomment">/// Temporary storage for globs that match.
    </span>matches: Arc&lt;ThreadLocal&lt;RefCell&lt;Vec&lt;usize&gt;&gt;&gt;&gt;,
}

<span class="doccomment">/// Indicates the type of a selection for a particular file type.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">enum </span>Selection&lt;T&gt; {
    Select(String, T),
    Negate(String, T),
}

<span class="kw">impl</span>&lt;T&gt; Selection&lt;T&gt; {
    <span class="kw">fn </span>is_negated(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self">self </span>{
            Selection::Select(..) =&gt; <span class="bool-val">false</span>,
            Selection::Negate(..) =&gt; <span class="bool-val">true</span>,
        }
    }

    <span class="kw">fn </span>name(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>str {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self">self </span>{
            Selection::Select(<span class="kw-2">ref </span>name, <span class="kw">_</span>) =&gt; name,
            Selection::Negate(<span class="kw-2">ref </span>name, <span class="kw">_</span>) =&gt; name,
        }
    }

    <span class="kw">fn </span>map&lt;U, F: FnOnce(T) -&gt; U&gt;(<span class="self">self</span>, f: F) -&gt; Selection&lt;U&gt; {
        <span class="kw">match </span><span class="self">self </span>{
            Selection::Select(name, inner) =&gt; {
                Selection::Select(name, f(inner))
            }
            Selection::Negate(name, inner) =&gt; {
                Selection::Negate(name, f(inner))
            }
        }
    }

    <span class="kw">fn </span>inner(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>T {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self">self </span>{
            Selection::Select(<span class="kw">_</span>, <span class="kw-2">ref </span>inner) =&gt; inner,
            Selection::Negate(<span class="kw">_</span>, <span class="kw-2">ref </span>inner) =&gt; inner,
        }
    }
}

<span class="kw">impl </span>Types {
    <span class="doccomment">/// Creates a new file type matcher that never matches any path and
    /// contains no file type definitions.
    </span><span class="kw">pub fn </span>empty() -&gt; Types {
        Types {
            defs: <span class="macro">vec!</span>[],
            selections: <span class="macro">vec!</span>[],
            has_selected: <span class="bool-val">false</span>,
            glob_to_selection: <span class="macro">vec!</span>[],
            set: GlobSetBuilder::new().build().unwrap(),
            matches: Arc::new(ThreadLocal::default()),
        }
    }

    <span class="doccomment">/// Returns true if and only if this matcher has zero selections.
    </span><span class="kw">pub fn </span>is_empty(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.selections.is_empty()
    }

    <span class="doccomment">/// Returns the number of selections used in this matcher.
    </span><span class="kw">pub fn </span>len(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.selections.len()
    }

    <span class="doccomment">/// Return the set of current file type definitions.
    ///
    /// Definitions and globs are sorted.
    </span><span class="kw">pub fn </span>definitions(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[FileTypeDef] {
        <span class="kw-2">&amp;</span><span class="self">self</span>.defs
    }

    <span class="doccomment">/// Returns a match for the given path against this file type matcher.
    ///
    /// The path is considered whitelisted if it matches a selected file type.
    /// The path is considered ignored if it matches a negated file type.
    /// If at least one file type is selected and `path` doesn&#39;t match, then
    /// the path is also considered ignored.
    </span><span class="kw">pub fn </span>matched&lt;<span class="lifetime">&#39;a</span>, P: AsRef&lt;Path&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>,
        path: P,
        is_dir: bool,
    ) -&gt; Match&lt;Glob&lt;<span class="lifetime">&#39;a</span>&gt;&gt; {
        <span class="comment">// File types don&#39;t apply to directories, and we can&#39;t do anything
        // if our glob set is empty.
        </span><span class="kw">if </span>is_dir || <span class="self">self</span>.set.is_empty() {
            <span class="kw">return </span>Match::None;
        }
        <span class="comment">// We only want to match against the file name, so extract it.
        // If one doesn&#39;t exist, then we can&#39;t match it.
        </span><span class="kw">let </span>name = <span class="kw">match </span>file_name(path.as_ref()) {
            <span class="prelude-val">Some</span>(name) =&gt; name,
            <span class="prelude-val">None </span><span class="kw">if </span><span class="self">self</span>.has_selected =&gt; {
                <span class="kw">return </span>Match::Ignore(Glob::unmatched());
            }
            <span class="prelude-val">None </span>=&gt; {
                <span class="kw">return </span>Match::None;
            }
        };
        <span class="kw">let </span><span class="kw-2">mut </span>matches = <span class="self">self</span>.matches.get_or_default().borrow_mut();
        <span class="self">self</span>.set.matches_into(name, <span class="kw-2">&amp;mut *</span>matches);
        <span class="comment">// The highest precedent match is the last one.
        </span><span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>i) = matches.last() {
            <span class="kw">let </span>(isel, iglob) = <span class="self">self</span>.glob_to_selection[i];
            <span class="kw">let </span>sel = <span class="kw-2">&amp;</span><span class="self">self</span>.selections[isel];
            <span class="kw">let </span>glob = Glob(GlobInner::Matched {
                def: sel.inner(),
                which: iglob,
                negated: sel.is_negated(),
            });
            <span class="kw">return if </span>sel.is_negated() {
                Match::Ignore(glob)
            } <span class="kw">else </span>{
                Match::Whitelist(glob)
            };
        }
        <span class="kw">if </span><span class="self">self</span>.has_selected {
            Match::Ignore(Glob::unmatched())
        } <span class="kw">else </span>{
            Match::None
        }
    }
}

<span class="doccomment">/// TypesBuilder builds a type matcher from a set of file type definitions and
/// a set of file type selections.
</span><span class="kw">pub struct </span>TypesBuilder {
    types: HashMap&lt;String, FileTypeDef&gt;,
    selections: Vec&lt;Selection&lt;()&gt;&gt;,
}

<span class="kw">impl </span>TypesBuilder {
    <span class="doccomment">/// Create a new builder for a file type matcher.
    ///
    /// The builder contains *no* type definitions to start with. A set
    /// of default type definitions can be added with `add_defaults`, and
    /// additional type definitions can be added with `select` and `negate`.
    </span><span class="kw">pub fn </span>new() -&gt; TypesBuilder {
        TypesBuilder { types: HashMap::new(), selections: <span class="macro">vec!</span>[] }
    }

    <span class="doccomment">/// Build the current set of file type definitions *and* selections into
    /// a file type matcher.
    </span><span class="kw">pub fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;Types, Error&gt; {
        <span class="kw">let </span>defs = <span class="self">self</span>.definitions();
        <span class="kw">let </span>has_selected = <span class="self">self</span>.selections.iter().any(|s| !s.is_negated());

        <span class="kw">let </span><span class="kw-2">mut </span>selections = <span class="macro">vec!</span>[];
        <span class="kw">let </span><span class="kw-2">mut </span>glob_to_selection = <span class="macro">vec!</span>[];
        <span class="kw">let </span><span class="kw-2">mut </span>build_set = GlobSetBuilder::new();
        <span class="kw">for </span>(isel, selection) <span class="kw">in </span><span class="self">self</span>.selections.iter().enumerate() {
            <span class="kw">let </span>def = <span class="kw">match </span><span class="self">self</span>.types.get(selection.name()) {
                <span class="prelude-val">Some</span>(def) =&gt; def.clone(),
                <span class="prelude-val">None </span>=&gt; {
                    <span class="kw">let </span>name = selection.name().to_string();
                    <span class="kw">return </span><span class="prelude-val">Err</span>(Error::UnrecognizedFileType(name));
                }
            };
            <span class="kw">for </span>(iglob, glob) <span class="kw">in </span>def.globs.iter().enumerate() {
                build_set.add(
                    GlobBuilder::new(glob)
                        .literal_separator(<span class="bool-val">true</span>)
                        .build()
                        .map_err(|err| Error::Glob {
                            glob: <span class="prelude-val">Some</span>(glob.to_string()),
                            err: err.kind().to_string(),
                        })<span class="question-mark">?</span>,
                );
                glob_to_selection.push((isel, iglob));
            }
            selections.push(selection.clone().map(<span class="kw">move </span>|<span class="kw">_</span>| def));
        }
        <span class="kw">let </span>set = build_set
            .build()
            .map_err(|err| Error::Glob { glob: <span class="prelude-val">None</span>, err: err.to_string() })<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(Types {
            defs: defs,
            selections: selections,
            has_selected: has_selected,
            glob_to_selection: glob_to_selection,
            set: set,
            matches: Arc::new(ThreadLocal::default()),
        })
    }

    <span class="doccomment">/// Return the set of current file type definitions.
    ///
    /// Definitions and globs are sorted.
    </span><span class="kw">pub fn </span>definitions(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;FileTypeDef&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>defs = <span class="macro">vec!</span>[];
        <span class="kw">for </span>def <span class="kw">in </span><span class="self">self</span>.types.values() {
            <span class="kw">let </span><span class="kw-2">mut </span>def = def.clone();
            def.globs.sort();
            defs.push(def);
        }
        defs.sort_by(|def1, def2| def1.name().cmp(def2.name()));
        defs
    }

    <span class="doccomment">/// Select the file type given by `name`.
    ///
    /// If `name` is `all`, then all file types currently defined are selected.
    </span><span class="kw">pub fn </span>select(<span class="kw-2">&amp;mut </span><span class="self">self</span>, name: <span class="kw-2">&amp;</span>str) -&gt; <span class="kw-2">&amp;mut </span>TypesBuilder {
        <span class="kw">if </span>name == <span class="string">&quot;all&quot; </span>{
            <span class="kw">for </span>name <span class="kw">in </span><span class="self">self</span>.types.keys() {
                <span class="self">self</span>.selections.push(Selection::Select(name.to_string(), ()));
            }
        } <span class="kw">else </span>{
            <span class="self">self</span>.selections.push(Selection::Select(name.to_string(), ()));
        }
        <span class="self">self
    </span>}

    <span class="doccomment">/// Ignore the file type given by `name`.
    ///
    /// If `name` is `all`, then all file types currently defined are negated.
    </span><span class="kw">pub fn </span>negate(<span class="kw-2">&amp;mut </span><span class="self">self</span>, name: <span class="kw-2">&amp;</span>str) -&gt; <span class="kw-2">&amp;mut </span>TypesBuilder {
        <span class="kw">if </span>name == <span class="string">&quot;all&quot; </span>{
            <span class="kw">for </span>name <span class="kw">in </span><span class="self">self</span>.types.keys() {
                <span class="self">self</span>.selections.push(Selection::Negate(name.to_string(), ()));
            }
        } <span class="kw">else </span>{
            <span class="self">self</span>.selections.push(Selection::Negate(name.to_string(), ()));
        }
        <span class="self">self
    </span>}

    <span class="doccomment">/// Clear any file type definitions for the type name given.
    </span><span class="kw">pub fn </span>clear(<span class="kw-2">&amp;mut </span><span class="self">self</span>, name: <span class="kw-2">&amp;</span>str) -&gt; <span class="kw-2">&amp;mut </span>TypesBuilder {
        <span class="self">self</span>.types.remove(name);
        <span class="self">self
    </span>}

    <span class="doccomment">/// Add a new file type definition. `name` can be arbitrary and `pat`
    /// should be a glob recognizing file paths belonging to the `name` type.
    ///
    /// If `name` is `all` or otherwise contains any character that is not a
    /// Unicode letter or number, then an error is returned.
    </span><span class="kw">pub fn </span>add(<span class="kw-2">&amp;mut </span><span class="self">self</span>, name: <span class="kw-2">&amp;</span>str, glob: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
        <span class="macro">lazy_static::lazy_static! </span>{
            <span class="kw">static </span><span class="kw-2">ref </span>RE: Regex = Regex::new(<span class="string">r&quot;^[\pL\pN]+$&quot;</span>).unwrap();
        };
        <span class="kw">if </span>name == <span class="string">&quot;all&quot; </span>|| !RE.is_match(name) {
            <span class="kw">return </span><span class="prelude-val">Err</span>(Error::InvalidDefinition);
        }
        <span class="kw">let </span>(key, glob) = (name.to_string(), glob.to_string());
        <span class="self">self</span>.types
            .entry(key)
            .or_insert_with(|| FileTypeDef {
                name: name.to_string(),
                globs: <span class="macro">vec!</span>[],
            })
            .globs
            .push(glob);
        <span class="prelude-val">Ok</span>(())
    }

    <span class="doccomment">/// Add a new file type definition specified in string form. There are two
    /// valid formats:
    /// 1. `{name}:{glob}`.  This defines a &#39;root&#39; definition that associates the
    ///     given name with the given glob.
    /// 2. `{name}:include:{comma-separated list of already defined names}.
    ///     This defines an &#39;include&#39; definition that associates the given name
    ///     with the definitions of the given existing types.
    /// Names may not include any characters that are not
    /// Unicode letters or numbers.
    </span><span class="kw">pub fn </span>add_def(<span class="kw-2">&amp;mut </span><span class="self">self</span>, def: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
        <span class="kw">let </span>parts: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = def.split(<span class="string">&#39;:&#39;</span>).collect();
        <span class="kw">match </span>parts.len() {
            <span class="number">2 </span>=&gt; {
                <span class="kw">let </span>name = parts[<span class="number">0</span>];
                <span class="kw">let </span>glob = parts[<span class="number">1</span>];
                <span class="kw">if </span>name.is_empty() || glob.is_empty() {
                    <span class="kw">return </span><span class="prelude-val">Err</span>(Error::InvalidDefinition);
                }
                <span class="self">self</span>.add(name, glob)
            }
            <span class="number">3 </span>=&gt; {
                <span class="kw">let </span>name = parts[<span class="number">0</span>];
                <span class="kw">let </span>types_string = parts[<span class="number">2</span>];
                <span class="kw">if </span>name.is_empty()
                    || parts[<span class="number">1</span>] != <span class="string">&quot;include&quot;
                    </span>|| types_string.is_empty()
                {
                    <span class="kw">return </span><span class="prelude-val">Err</span>(Error::InvalidDefinition);
                }
                <span class="kw">let </span>types = types_string.split(<span class="string">&#39;,&#39;</span>);
                <span class="comment">// Check ahead of time to ensure that all types specified are
                // present and fail fast if not.
                </span><span class="kw">if </span>types.clone().any(|t| !<span class="self">self</span>.types.contains_key(t)) {
                    <span class="kw">return </span><span class="prelude-val">Err</span>(Error::InvalidDefinition);
                }
                <span class="kw">for </span>type_name <span class="kw">in </span>types {
                    <span class="kw">let </span>globs =
                        <span class="self">self</span>.types.get(type_name).unwrap().globs.clone();
                    <span class="kw">for </span>glob <span class="kw">in </span>globs {
                        <span class="self">self</span>.add(name, <span class="kw-2">&amp;</span>glob)<span class="question-mark">?</span>;
                    }
                }
                <span class="prelude-val">Ok</span>(())
            }
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(Error::InvalidDefinition),
        }
    }

    <span class="doccomment">/// Add a set of default file type definitions.
    </span><span class="kw">pub fn </span>add_defaults(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut </span>TypesBuilder {
        <span class="kw">static </span>MSG: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str = <span class="string">&quot;adding a default type should never fail&quot;</span>;
        <span class="kw">for </span><span class="kw-2">&amp;</span>(name, exts) <span class="kw">in </span>DEFAULT_TYPES {
            <span class="kw">for </span>ext <span class="kw">in </span>exts {
                <span class="self">self</span>.add(name, ext).expect(MSG);
            }
        }
        <span class="self">self
    </span>}
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>tests {
    <span class="kw">use </span><span class="kw">super</span>::TypesBuilder;

    <span class="macro">macro_rules! </span>matched {
        (<span class="macro-nonterminal">$name</span>:ident, <span class="macro-nonterminal">$types</span>:expr, <span class="macro-nonterminal">$sel</span>:expr, <span class="macro-nonterminal">$selnot</span>:expr,
         <span class="macro-nonterminal">$path</span>:expr) =&gt; {
            <span class="macro">matched!</span>(<span class="macro-nonterminal">$name</span>, <span class="macro-nonterminal">$types</span>, <span class="macro-nonterminal">$sel</span>, <span class="macro-nonterminal">$selnot</span>, <span class="macro-nonterminal">$path</span>, <span class="bool-val">true</span>);
        };
        (not, <span class="macro-nonterminal">$name</span>:ident, <span class="macro-nonterminal">$types</span>:expr, <span class="macro-nonterminal">$sel</span>:expr, <span class="macro-nonterminal">$selnot</span>:expr,
         <span class="macro-nonterminal">$path</span>:expr) =&gt; {
            <span class="macro">matched!</span>(<span class="macro-nonterminal">$name</span>, <span class="macro-nonterminal">$types</span>, <span class="macro-nonterminal">$sel</span>, <span class="macro-nonterminal">$selnot</span>, <span class="macro-nonterminal">$path</span>, <span class="bool-val">false</span>);
        };
        (<span class="macro-nonterminal">$name</span>:ident, <span class="macro-nonterminal">$types</span>:expr, <span class="macro-nonterminal">$sel</span>:expr, <span class="macro-nonterminal">$selnot</span>:expr,
         <span class="macro-nonterminal">$path</span>:expr, <span class="macro-nonterminal">$matched</span>:expr) =&gt; {
            <span class="attribute">#[test]
            </span><span class="kw">fn </span><span class="macro-nonterminal">$name</span>() {
                <span class="kw">let </span><span class="kw-2">mut </span>btypes = TypesBuilder::new();
                <span class="kw">for </span>tydef <span class="kw">in </span><span class="macro-nonterminal">$types </span>{
                    btypes.add_def(tydef).unwrap();
                }
                <span class="kw">for </span>sel <span class="kw">in </span><span class="macro-nonterminal">$sel </span>{
                    btypes.select(sel);
                }
                <span class="kw">for </span>selnot <span class="kw">in </span><span class="macro-nonterminal">$selnot </span>{
                    btypes.negate(selnot);
                }
                <span class="kw">let </span>types = btypes.build().unwrap();
                <span class="kw">let </span>mat = types.matched(<span class="macro-nonterminal">$path</span>, <span class="bool-val">false</span>);
                <span class="macro">assert_eq!</span>(<span class="macro-nonterminal">$matched</span>, !mat.is_ignore());
            }
        };
    }

    <span class="kw">fn </span>types() -&gt; Vec&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
        <span class="macro">vec!</span>[
            <span class="string">&quot;html:*.html&quot;</span>,
            <span class="string">&quot;html:*.htm&quot;</span>,
            <span class="string">&quot;rust:*.rs&quot;</span>,
            <span class="string">&quot;js:*.js&quot;</span>,
            <span class="string">&quot;foo:*.{rs,foo}&quot;</span>,
            <span class="string">&quot;combo:include:html,rust&quot;</span>,
        ]
    }

    <span class="macro">matched!</span>(match1, types(), <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;lib.rs&quot;</span>);
    <span class="macro">matched!</span>(match2, types(), <span class="macro">vec!</span>[<span class="string">&quot;html&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;index.html&quot;</span>);
    <span class="macro">matched!</span>(match3, types(), <span class="macro">vec!</span>[<span class="string">&quot;html&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;index.htm&quot;</span>);
    <span class="macro">matched!</span>(match4, types(), <span class="macro">vec!</span>[<span class="string">&quot;html&quot;</span>, <span class="string">&quot;rust&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;main.rs&quot;</span>);
    <span class="macro">matched!</span>(match5, types(), <span class="macro">vec!</span>[], <span class="macro">vec!</span>[], <span class="string">&quot;index.html&quot;</span>);
    <span class="macro">matched!</span>(match6, types(), <span class="macro">vec!</span>[], <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="string">&quot;index.html&quot;</span>);
    <span class="macro">matched!</span>(match7, types(), <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>], <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="string">&quot;main.foo&quot;</span>);
    <span class="macro">matched!</span>(match8, types(), <span class="macro">vec!</span>[<span class="string">&quot;combo&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;index.html&quot;</span>);
    <span class="macro">matched!</span>(match9, types(), <span class="macro">vec!</span>[<span class="string">&quot;combo&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;lib.rs&quot;</span>);

    <span class="macro">matched!</span>(not, matchnot1, types(), <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;index.html&quot;</span>);
    <span class="macro">matched!</span>(not, matchnot2, types(), <span class="macro">vec!</span>[], <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="string">&quot;main.rs&quot;</span>);
    <span class="macro">matched!</span>(not, matchnot3, types(), <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>], <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="string">&quot;main.rs&quot;</span>);
    <span class="macro">matched!</span>(not, matchnot4, types(), <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>], <span class="string">&quot;main.rs&quot;</span>);
    <span class="macro">matched!</span>(not, matchnot5, types(), <span class="macro">vec!</span>[<span class="string">&quot;rust&quot;</span>], <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>], <span class="string">&quot;main.foo&quot;</span>);
    <span class="macro">matched!</span>(not, matchnot6, types(), <span class="macro">vec!</span>[<span class="string">&quot;combo&quot;</span>], <span class="macro">vec!</span>[], <span class="string">&quot;leftpad.js&quot;</span>);

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_invalid_defs() {
        <span class="kw">let </span><span class="kw-2">mut </span>btypes = TypesBuilder::new();
        <span class="kw">for </span>tydef <span class="kw">in </span>types() {
            btypes.add_def(tydef).unwrap();
        }
        <span class="comment">// Preserve the original definitions for later comparison.
        </span><span class="kw">let </span>original_defs = btypes.definitions();
        <span class="kw">let </span>bad_defs = <span class="macro">vec!</span>[
            <span class="comment">// Reference to type that does not exist
            </span><span class="string">&quot;combo:include:html,python&quot;</span>,
            <span class="comment">// Bad format
            </span><span class="string">&quot;combo:foobar:html,rust&quot;</span>,
            <span class="string">&quot;&quot;</span>,
        ];
        <span class="kw">for </span>def <span class="kw">in </span>bad_defs {
            <span class="macro">assert!</span>(btypes.add_def(def).is_err());
            <span class="comment">// Ensure that nothing changed, even if some of the includes were valid.
            </span><span class="macro">assert_eq!</span>(btypes.definitions(), original_defs);
        }
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="ignore" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>