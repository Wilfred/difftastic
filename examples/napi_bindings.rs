/* automatically generated by rust-bindgen */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_uid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type char16_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_env__ {
    _unused: [u8; 0],
}
pub type napi_env = *mut napi_env__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_value__ {
    _unused: [u8; 0],
}
pub type napi_value = *mut napi_value__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_ref__ {
    _unused: [u8; 0],
}
pub type napi_ref = *mut napi_ref__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_handle_scope__ {
    _unused: [u8; 0],
}
pub type napi_handle_scope = *mut napi_handle_scope__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_escapable_handle_scope__ {
    _unused: [u8; 0],
}
pub type napi_escapable_handle_scope = *mut napi_escapable_handle_scope__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_callback_info__ {
    _unused: [u8; 0],
}
pub type napi_callback_info = *mut napi_callback_info__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_async_context__ {
    _unused: [u8; 0],
}
pub type napi_async_context = *mut napi_async_context__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_async_work__ {
    _unused: [u8; 0],
}
pub type napi_async_work = *mut napi_async_work__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_deferred__ {
    _unused: [u8; 0],
}
pub type napi_deferred = *mut napi_deferred__;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum napi_property_attributes {
    napi_default = 0,
    napi_writable = 1,
    napi_enumerable = 2,
    napi_configurable = 4,
    napi_static = 1024,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum napi_valuetype {
    napi_undefined = 0,
    napi_null = 1,
    napi_boolean = 2,
    napi_number = 3,
    napi_string = 4,
    napi_symbol = 5,
    napi_object = 6,
    napi_function = 7,
    napi_external = 8,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum napi_typedarray_type {
    napi_int8_array = 0,
    napi_uint8_array = 1,
    napi_uint8_clamped_array = 2,
    napi_int16_array = 3,
    napi_uint16_array = 4,
    napi_int32_array = 5,
    napi_uint32_array = 6,
    napi_float32_array = 7,
    napi_float64_array = 8,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum napi_status {
    napi_ok = 0,
    napi_invalid_arg = 1,
    napi_object_expected = 2,
    napi_string_expected = 3,
    napi_name_expected = 4,
    napi_function_expected = 5,
    napi_number_expected = 6,
    napi_boolean_expected = 7,
    napi_array_expected = 8,
    napi_generic_failure = 9,
    napi_pending_exception = 10,
    napi_cancelled = 11,
    napi_escape_called_twice = 12,
    napi_handle_scope_mismatch = 13,
}
pub type napi_callback = ::std::option::Option<
    unsafe extern "C" fn(env: napi_env, info: napi_callback_info) -> napi_value,
>;
pub type napi_finalize = ::std::option::Option<
    unsafe extern "C" fn(
        env: napi_env,
        finalize_data: *mut ::std::os::raw::c_void,
        finalize_hint: *mut ::std::os::raw::c_void,
    ),
>;
pub type napi_async_execute_callback =
    ::std::option::Option<unsafe extern "C" fn(env: napi_env, data: *mut ::std::os::raw::c_void)>;
pub type napi_async_complete_callback = ::std::option::Option<
    unsafe extern "C" fn(env: napi_env, status: napi_status, data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_property_descriptor {
    pub utf8name: *const ::std::os::raw::c_char,
    pub name: napi_value,
    pub method: napi_callback,
    pub getter: napi_callback,
    pub setter: napi_callback,
    pub value: napi_value,
    pub attributes: napi_property_attributes,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_napi_property_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<napi_property_descriptor>(),
        64usize,
        concat!("Size of: ", stringify!(napi_property_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<napi_property_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(napi_property_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_property_descriptor>())).utf8name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(utf8name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).method as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).getter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(getter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).setter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(setter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).value as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_property_descriptor>())).attributes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_property_descriptor>())).data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_property_descriptor),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_extended_error_info {
    pub error_message: *const ::std::os::raw::c_char,
    pub engine_reserved: *mut ::std::os::raw::c_void,
    pub engine_error_code: u32,
    pub error_code: napi_status,
}
#[test]
fn bindgen_test_layout_napi_extended_error_info() {
    assert_eq!(
        ::std::mem::size_of::<napi_extended_error_info>(),
        24usize,
        concat!("Size of: ", stringify!(napi_extended_error_info))
    );
    assert_eq!(
        ::std::mem::align_of::<napi_extended_error_info>(),
        8usize,
        concat!("Alignment of ", stringify!(napi_extended_error_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_extended_error_info>())).error_message as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_extended_error_info),
            "::",
            stringify!(error_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_extended_error_info>())).engine_reserved as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_extended_error_info),
            "::",
            stringify!(engine_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_extended_error_info>())).engine_error_code as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_extended_error_info),
            "::",
            stringify!(engine_error_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<napi_extended_error_info>())).error_code as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_extended_error_info),
            "::",
            stringify!(error_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_node_version {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub release: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_napi_node_version() {
    assert_eq!(
        ::std::mem::size_of::<napi_node_version>(),
        24usize,
        concat!("Size of: ", stringify!(napi_node_version))
    );
    assert_eq!(
        ::std::mem::align_of::<napi_node_version>(),
        8usize,
        concat!("Alignment of ", stringify!(napi_node_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_node_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_node_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_node_version>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_node_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_node_version>())).patch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_node_version),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_node_version>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_node_version),
            "::",
            stringify!(release)
        )
    );
}
pub type napi_addon_register_func =
    ::std::option::Option<unsafe extern "C" fn(env: napi_env, exports: napi_value) -> napi_value>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_module {
    pub nm_version: ::std::os::raw::c_int,
    pub nm_flags: ::std::os::raw::c_uint,
    pub nm_filename: *const ::std::os::raw::c_char,
    pub nm_register_func: napi_addon_register_func,
    pub nm_modname: *const ::std::os::raw::c_char,
    pub nm_priv: *mut ::std::os::raw::c_void,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_napi_module() {
    assert_eq!(
        ::std::mem::size_of::<napi_module>(),
        72usize,
        concat!("Size of: ", stringify!(napi_module))
    );
    assert_eq!(
        ::std::mem::align_of::<napi_module>(),
        8usize,
        concat!("Alignment of ", stringify!(napi_module))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_filename as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_register_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_register_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_modname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_modname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).nm_priv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(nm_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<napi_module>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(napi_module),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_napi_module_register"]
    pub fn napi_module_register(mod_: *mut napi_module);
}
extern "C" {
    #[link_name = "\u{1}_napi_get_last_error_info"]
    pub fn napi_get_last_error_info(
        env: napi_env,
        result: *mut *const napi_extended_error_info,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_fatal_error"]
    pub fn napi_fatal_error(
        location: *const ::std::os::raw::c_char,
        location_len: usize,
        message: *const ::std::os::raw::c_char,
        message_len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_napi_get_undefined"]
    pub fn napi_get_undefined(env: napi_env, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_null"]
    pub fn napi_get_null(env: napi_env, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_global"]
    pub fn napi_get_global(env: napi_env, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_boolean"]
    pub fn napi_get_boolean(env: napi_env, value: bool, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_object"]
    pub fn napi_create_object(env: napi_env, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_array"]
    pub fn napi_create_array(env: napi_env, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_array_with_length"]
    pub fn napi_create_array_with_length(
        env: napi_env,
        length: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_double"]
    pub fn napi_create_double(env: napi_env, value: f64, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_int32"]
    pub fn napi_create_int32(env: napi_env, value: i32, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_uint32"]
    pub fn napi_create_uint32(env: napi_env, value: u32, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_int64"]
    pub fn napi_create_int64(env: napi_env, value: i64, result: *mut napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_string_latin1"]
    pub fn napi_create_string_latin1(
        env: napi_env,
        str: *const ::std::os::raw::c_char,
        length: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_string_utf8"]
    pub fn napi_create_string_utf8(
        env: napi_env,
        str: *const ::std::os::raw::c_char,
        length: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_string_utf16"]
    pub fn napi_create_string_utf16(
        env: napi_env,
        str: *const char16_t,
        length: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_symbol"]
    pub fn napi_create_symbol(
        env: napi_env,
        description: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_function"]
    pub fn napi_create_function(
        env: napi_env,
        utf8name: *const ::std::os::raw::c_char,
        length: usize,
        cb: napi_callback,
        data: *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_error"]
    pub fn napi_create_error(
        env: napi_env,
        code: napi_value,
        msg: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_type_error"]
    pub fn napi_create_type_error(
        env: napi_env,
        code: napi_value,
        msg: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_range_error"]
    pub fn napi_create_range_error(
        env: napi_env,
        code: napi_value,
        msg: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_typeof"]
    pub fn napi_typeof(
        env: napi_env,
        value: napi_value,
        result: *mut napi_valuetype,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_double"]
    pub fn napi_get_value_double(env: napi_env, value: napi_value, result: *mut f64)
        -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_int32"]
    pub fn napi_get_value_int32(env: napi_env, value: napi_value, result: *mut i32) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_uint32"]
    pub fn napi_get_value_uint32(env: napi_env, value: napi_value, result: *mut u32)
        -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_int64"]
    pub fn napi_get_value_int64(env: napi_env, value: napi_value, result: *mut i64) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_bool"]
    pub fn napi_get_value_bool(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_string_latin1"]
    pub fn napi_get_value_string_latin1(
        env: napi_env,
        value: napi_value,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        result: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_string_utf8"]
    pub fn napi_get_value_string_utf8(
        env: napi_env,
        value: napi_value,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        result: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_string_utf16"]
    pub fn napi_get_value_string_utf16(
        env: napi_env,
        value: napi_value,
        buf: *mut char16_t,
        bufsize: usize,
        result: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_coerce_to_bool"]
    pub fn napi_coerce_to_bool(
        env: napi_env,
        value: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_coerce_to_number"]
    pub fn napi_coerce_to_number(
        env: napi_env,
        value: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_coerce_to_object"]
    pub fn napi_coerce_to_object(
        env: napi_env,
        value: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_coerce_to_string"]
    pub fn napi_coerce_to_string(
        env: napi_env,
        value: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_prototype"]
    pub fn napi_get_prototype(
        env: napi_env,
        object: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_property_names"]
    pub fn napi_get_property_names(
        env: napi_env,
        object: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_set_property"]
    pub fn napi_set_property(
        env: napi_env,
        object: napi_value,
        key: napi_value,
        value: napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_has_property"]
    pub fn napi_has_property(
        env: napi_env,
        object: napi_value,
        key: napi_value,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_property"]
    pub fn napi_get_property(
        env: napi_env,
        object: napi_value,
        key: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_delete_property"]
    pub fn napi_delete_property(
        env: napi_env,
        object: napi_value,
        key: napi_value,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_has_own_property"]
    pub fn napi_has_own_property(
        env: napi_env,
        object: napi_value,
        key: napi_value,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_set_named_property"]
    pub fn napi_set_named_property(
        env: napi_env,
        object: napi_value,
        utf8name: *const ::std::os::raw::c_char,
        value: napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_has_named_property"]
    pub fn napi_has_named_property(
        env: napi_env,
        object: napi_value,
        utf8name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_named_property"]
    pub fn napi_get_named_property(
        env: napi_env,
        object: napi_value,
        utf8name: *const ::std::os::raw::c_char,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_set_element"]
    pub fn napi_set_element(
        env: napi_env,
        object: napi_value,
        index: u32,
        value: napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_has_element"]
    pub fn napi_has_element(
        env: napi_env,
        object: napi_value,
        index: u32,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_element"]
    pub fn napi_get_element(
        env: napi_env,
        object: napi_value,
        index: u32,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_delete_element"]
    pub fn napi_delete_element(
        env: napi_env,
        object: napi_value,
        index: u32,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_define_properties"]
    pub fn napi_define_properties(
        env: napi_env,
        object: napi_value,
        property_count: usize,
        properties: *const napi_property_descriptor,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_array"]
    pub fn napi_is_array(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_array_length"]
    pub fn napi_get_array_length(env: napi_env, value: napi_value, result: *mut u32)
        -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_strict_equals"]
    pub fn napi_strict_equals(
        env: napi_env,
        lhs: napi_value,
        rhs: napi_value,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_call_function"]
    pub fn napi_call_function(
        env: napi_env,
        recv: napi_value,
        func: napi_value,
        argc: usize,
        argv: *const napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_new_instance"]
    pub fn napi_new_instance(
        env: napi_env,
        constructor: napi_value,
        argc: usize,
        argv: *const napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_instanceof"]
    pub fn napi_instanceof(
        env: napi_env,
        object: napi_value,
        constructor: napi_value,
        result: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_cb_info"]
    pub fn napi_get_cb_info(
        env: napi_env,
        cbinfo: napi_callback_info,
        argc: *mut usize,
        argv: *mut napi_value,
        this_arg: *mut napi_value,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_new_target"]
    pub fn napi_get_new_target(
        env: napi_env,
        cbinfo: napi_callback_info,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_define_class"]
    pub fn napi_define_class(
        env: napi_env,
        utf8name: *const ::std::os::raw::c_char,
        length: usize,
        constructor: napi_callback,
        data: *mut ::std::os::raw::c_void,
        property_count: usize,
        properties: *const napi_property_descriptor,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_wrap"]
    pub fn napi_wrap(
        env: napi_env,
        js_object: napi_value,
        native_object: *mut ::std::os::raw::c_void,
        finalize_cb: napi_finalize,
        finalize_hint: *mut ::std::os::raw::c_void,
        result: *mut napi_ref,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_unwrap"]
    pub fn napi_unwrap(
        env: napi_env,
        js_object: napi_value,
        result: *mut *mut ::std::os::raw::c_void,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_remove_wrap"]
    pub fn napi_remove_wrap(
        env: napi_env,
        js_object: napi_value,
        result: *mut *mut ::std::os::raw::c_void,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_external"]
    pub fn napi_create_external(
        env: napi_env,
        data: *mut ::std::os::raw::c_void,
        finalize_cb: napi_finalize,
        finalize_hint: *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_value_external"]
    pub fn napi_get_value_external(
        env: napi_env,
        value: napi_value,
        result: *mut *mut ::std::os::raw::c_void,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_reference"]
    pub fn napi_create_reference(
        env: napi_env,
        value: napi_value,
        initial_refcount: u32,
        result: *mut napi_ref,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_delete_reference"]
    pub fn napi_delete_reference(env: napi_env, ref_: napi_ref) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_reference_ref"]
    pub fn napi_reference_ref(env: napi_env, ref_: napi_ref, result: *mut u32) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_reference_unref"]
    pub fn napi_reference_unref(env: napi_env, ref_: napi_ref, result: *mut u32) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_reference_value"]
    pub fn napi_get_reference_value(
        env: napi_env,
        ref_: napi_ref,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_open_handle_scope"]
    pub fn napi_open_handle_scope(env: napi_env, result: *mut napi_handle_scope) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_close_handle_scope"]
    pub fn napi_close_handle_scope(env: napi_env, scope: napi_handle_scope) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_open_escapable_handle_scope"]
    pub fn napi_open_escapable_handle_scope(
        env: napi_env,
        result: *mut napi_escapable_handle_scope,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_close_escapable_handle_scope"]
    pub fn napi_close_escapable_handle_scope(
        env: napi_env,
        scope: napi_escapable_handle_scope,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_escape_handle"]
    pub fn napi_escape_handle(
        env: napi_env,
        scope: napi_escapable_handle_scope,
        escapee: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_throw"]
    pub fn napi_throw(env: napi_env, error: napi_value) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_throw_error"]
    pub fn napi_throw_error(
        env: napi_env,
        code: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_throw_type_error"]
    pub fn napi_throw_type_error(
        env: napi_env,
        code: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_throw_range_error"]
    pub fn napi_throw_range_error(
        env: napi_env,
        code: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_error"]
    pub fn napi_is_error(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_exception_pending"]
    pub fn napi_is_exception_pending(env: napi_env, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_and_clear_last_exception"]
    pub fn napi_get_and_clear_last_exception(env: napi_env, result: *mut napi_value)
        -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_buffer"]
    pub fn napi_create_buffer(
        env: napi_env,
        length: usize,
        data: *mut *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_external_buffer"]
    pub fn napi_create_external_buffer(
        env: napi_env,
        length: usize,
        data: *mut ::std::os::raw::c_void,
        finalize_cb: napi_finalize,
        finalize_hint: *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_buffer_copy"]
    pub fn napi_create_buffer_copy(
        env: napi_env,
        length: usize,
        data: *const ::std::os::raw::c_void,
        result_data: *mut *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_buffer"]
    pub fn napi_is_buffer(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_buffer_info"]
    pub fn napi_get_buffer_info(
        env: napi_env,
        value: napi_value,
        data: *mut *mut ::std::os::raw::c_void,
        length: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_arraybuffer"]
    pub fn napi_is_arraybuffer(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_arraybuffer"]
    pub fn napi_create_arraybuffer(
        env: napi_env,
        byte_length: usize,
        data: *mut *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_external_arraybuffer"]
    pub fn napi_create_external_arraybuffer(
        env: napi_env,
        external_data: *mut ::std::os::raw::c_void,
        byte_length: usize,
        finalize_cb: napi_finalize,
        finalize_hint: *mut ::std::os::raw::c_void,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_arraybuffer_info"]
    pub fn napi_get_arraybuffer_info(
        env: napi_env,
        arraybuffer: napi_value,
        data: *mut *mut ::std::os::raw::c_void,
        byte_length: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_typedarray"]
    pub fn napi_is_typedarray(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_typedarray"]
    pub fn napi_create_typedarray(
        env: napi_env,
        type_: napi_typedarray_type,
        length: usize,
        arraybuffer: napi_value,
        byte_offset: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_typedarray_info"]
    pub fn napi_get_typedarray_info(
        env: napi_env,
        typedarray: napi_value,
        type_: *mut napi_typedarray_type,
        length: *mut usize,
        data: *mut *mut ::std::os::raw::c_void,
        arraybuffer: *mut napi_value,
        byte_offset: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_dataview"]
    pub fn napi_create_dataview(
        env: napi_env,
        length: usize,
        arraybuffer: napi_value,
        byte_offset: usize,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_dataview"]
    pub fn napi_is_dataview(env: napi_env, value: napi_value, result: *mut bool) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_dataview_info"]
    pub fn napi_get_dataview_info(
        env: napi_env,
        dataview: napi_value,
        bytelength: *mut usize,
        data: *mut *mut ::std::os::raw::c_void,
        arraybuffer: *mut napi_value,
        byte_offset: *mut usize,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_async_work"]
    pub fn napi_create_async_work(
        env: napi_env,
        async_resource: napi_value,
        async_resource_name: napi_value,
        execute: napi_async_execute_callback,
        complete: napi_async_complete_callback,
        data: *mut ::std::os::raw::c_void,
        result: *mut napi_async_work,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_delete_async_work"]
    pub fn napi_delete_async_work(env: napi_env, work: napi_async_work) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_queue_async_work"]
    pub fn napi_queue_async_work(env: napi_env, work: napi_async_work) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_cancel_async_work"]
    pub fn napi_cancel_async_work(env: napi_env, work: napi_async_work) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_async_init"]
    pub fn napi_async_init(
        env: napi_env,
        async_resource: napi_value,
        async_resource_name: napi_value,
        result: *mut napi_async_context,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_async_destroy"]
    pub fn napi_async_destroy(env: napi_env, async_context: napi_async_context) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_make_callback"]
    pub fn napi_make_callback(
        env: napi_env,
        async_context: napi_async_context,
        recv: napi_value,
        func: napi_value,
        argc: usize,
        argv: *const napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_version"]
    pub fn napi_get_version(env: napi_env, result: *mut u32) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_get_node_version"]
    pub fn napi_get_node_version(
        env: napi_env,
        version: *mut *const napi_node_version,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_create_promise"]
    pub fn napi_create_promise(
        env: napi_env,
        deferred: *mut napi_deferred,
        promise: *mut napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_resolve_deferred"]
    pub fn napi_resolve_deferred(
        env: napi_env,
        deferred: napi_deferred,
        resolution: napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_reject_deferred"]
    pub fn napi_reject_deferred(
        env: napi_env,
        deferred: napi_deferred,
        rejection: napi_value,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_is_promise"]
    pub fn napi_is_promise(
        env: napi_env,
        promise: napi_value,
        is_promise: *mut bool,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_adjust_external_memory"]
    pub fn napi_adjust_external_memory(
        env: napi_env,
        change_in_bytes: i64,
        adjusted_value: *mut i64,
    ) -> napi_status;
}
extern "C" {
    #[link_name = "\u{1}_napi_run_script"]
    pub fn napi_run_script(
        env: napi_env,
        script: napi_value,
        result: *mut napi_value,
    ) -> napi_status;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
pub type off_t = __darwin_off_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type mode_t = __darwin_mode_t;
pub type uid_t = __darwin_uid_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: ino_t,
    pub d_reclen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_namlen: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        264usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        4usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__u6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
pub type tcflag_t = ::std::os::raw::c_ulong;
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_cc: [cc_t; 20usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        72usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        8usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ispeed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ospeed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ospeed)
        )
    );
}
pub type mach_port_t = __darwin_mach_port_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__work {
    pub work: ::std::option::Option<unsafe extern "C" fn(w: *mut uv__work)>,
    pub done: ::std::option::Option<
        unsafe extern "C" fn(w: *mut uv__work, status: ::std::os::raw::c_int),
    >,
    pub loop_: *mut uv_loop_s,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv__work() {
    assert_eq!(
        ::std::mem::size_of::<uv__work>(),
        40usize,
        concat!("Size of: ", stringify!(uv__work))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__work>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).done as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).loop_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__work>())).wq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__work),
            "::",
            stringify!(wq)
        )
    );
}
pub type semaphore_t = mach_port_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _uv_barrier {
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub threshold: ::std::os::raw::c_uint,
    pub in_: ::std::os::raw::c_uint,
    pub out: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__uv_barrier() {
    assert_eq!(
        ::std::mem::size_of::<_uv_barrier>(),
        128usize,
        concat!("Size of: ", stringify!(_uv_barrier))
    );
    assert_eq!(
        ::std::mem::align_of::<_uv_barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(_uv_barrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_uv_barrier>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_uv_barrier),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_uv_barrier>())).cond as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_uv_barrier),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_uv_barrier>())).threshold as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_uv_barrier),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_uv_barrier>())).in_ as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_uv_barrier),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_uv_barrier>())).out as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_uv_barrier),
            "::",
            stringify!(out)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub b: *mut _uv_barrier,
    pub _pad: [::std::os::raw::c_char; 72usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        80usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>()))._pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(_pad)
        )
    );
}
pub type uv__io_cb = ::std::option::Option<
    unsafe extern "C" fn(loop_: *mut uv_loop_s, w: *mut uv__io_s, events: ::std::os::raw::c_uint),
>;
pub type uv__io_t = uv__io_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__io_s {
    pub cb: uv__io_cb,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pevents: ::std::os::raw::c_uint,
    pub events: ::std::os::raw::c_uint,
    pub fd: ::std::os::raw::c_int,
    pub rcount: ::std::os::raw::c_int,
    pub wcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv__io_s() {
    assert_eq!(
        ::std::mem::size_of::<uv__io_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv__io_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__io_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__io_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pending_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).watcher_queue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pevents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).events as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).rcount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(rcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).wcount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(wcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_buf_t {
    pub base: *mut ::std::os::raw::c_char,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_uv_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_buf_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_buf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(len)
        )
    );
}
pub type uv_file = ::std::os::raw::c_int;
pub type uv_os_sock_t = ::std::os::raw::c_int;
pub type uv_os_fd_t = ::std::os::raw::c_int;
pub type uv_once_t = pthread_once_t;
pub type uv_thread_t = pthread_t;
pub type uv_mutex_t = pthread_mutex_t;
pub type uv_rwlock_t = pthread_rwlock_t;
pub type uv_sem_t = semaphore_t;
pub type uv_cond_t = pthread_cond_t;
pub type uv_key_t = pthread_key_t;
pub type uv_barrier_t = pthread_barrier_t;
pub type uv_gid_t = gid_t;
pub type uv_uid_t = uid_t;
pub type uv__dirent_t = dirent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_lib_t {
    pub handle: *mut ::std::os::raw::c_void,
    pub errmsg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uv_lib_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_lib_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_lib_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_lib_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_lib_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_lib_t>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_lib_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_lib_t>())).errmsg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_lib_t),
            "::",
            stringify!(errmsg)
        )
    );
}
#[repr(i32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_errno_t {
    UV_E2BIG = -7,
    UV_EACCES = -13,
    UV_EADDRINUSE = -48,
    UV_EADDRNOTAVAIL = -49,
    UV_EAFNOSUPPORT = -47,
    UV_EAGAIN = -35,
    UV_EAI_ADDRFAMILY = -3000,
    UV_EAI_AGAIN = -3001,
    UV_EAI_BADFLAGS = -3002,
    UV_EAI_BADHINTS = -3013,
    UV_EAI_CANCELED = -3003,
    UV_EAI_FAIL = -3004,
    UV_EAI_FAMILY = -3005,
    UV_EAI_MEMORY = -3006,
    UV_EAI_NODATA = -3007,
    UV_EAI_NONAME = -3008,
    UV_EAI_OVERFLOW = -3009,
    UV_EAI_PROTOCOL = -3014,
    UV_EAI_SERVICE = -3010,
    UV_EAI_SOCKTYPE = -3011,
    UV_EALREADY = -37,
    UV_EBADF = -9,
    UV_EBUSY = -16,
    UV_ECANCELED = -89,
    UV_ECHARSET = -4080,
    UV_ECONNABORTED = -53,
    UV_ECONNREFUSED = -61,
    UV_ECONNRESET = -54,
    UV_EDESTADDRREQ = -39,
    UV_EEXIST = -17,
    UV_EFAULT = -14,
    UV_EFBIG = -27,
    UV_EHOSTUNREACH = -65,
    UV_EINTR = -4,
    UV_EINVAL = -22,
    UV_EIO = -5,
    UV_EISCONN = -56,
    UV_EISDIR = -21,
    UV_ELOOP = -62,
    UV_EMFILE = -24,
    UV_EMSGSIZE = -40,
    UV_ENAMETOOLONG = -63,
    UV_ENETDOWN = -50,
    UV_ENETUNREACH = -51,
    UV_ENFILE = -23,
    UV_ENOBUFS = -55,
    UV_ENODEV = -19,
    UV_ENOENT = -2,
    UV_ENOMEM = -12,
    UV_ENONET = -4056,
    UV_ENOPROTOOPT = -42,
    UV_ENOSPC = -28,
    UV_ENOSYS = -78,
    UV_ENOTCONN = -57,
    UV_ENOTDIR = -20,
    UV_ENOTEMPTY = -66,
    UV_ENOTSOCK = -38,
    UV_ENOTSUP = -45,
    UV_EPERM = -1,
    UV_EPIPE = -32,
    UV_EPROTO = -100,
    UV_EPROTONOSUPPORT = -43,
    UV_EPROTOTYPE = -41,
    UV_ERANGE = -34,
    UV_EROFS = -30,
    UV_ESHUTDOWN = -58,
    UV_ESPIPE = -29,
    UV_ESRCH = -3,
    UV_ETIMEDOUT = -60,
    UV_ETXTBSY = -26,
    UV_EXDEV = -18,
    UV_UNKNOWN = -4094,
    UV_EOF = -4095,
    UV_ENXIO = -6,
    UV_EMLINK = -31,
    UV_EHOSTDOWN = -64,
    UV_EREMOTEIO = -4030,
    UV_ERRNO_MAX = -4096,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_handle_type {
    UV_UNKNOWN_HANDLE = 0,
    UV_ASYNC = 1,
    UV_CHECK = 2,
    UV_FS_EVENT = 3,
    UV_FS_POLL = 4,
    UV_HANDLE = 5,
    UV_IDLE = 6,
    UV_NAMED_PIPE = 7,
    UV_POLL = 8,
    UV_PREPARE = 9,
    UV_PROCESS = 10,
    UV_STREAM = 11,
    UV_TCP = 12,
    UV_TIMER = 13,
    UV_TTY = 14,
    UV_UDP = 15,
    UV_SIGNAL = 16,
    UV_FILE = 17,
    UV_HANDLE_TYPE_MAX = 18,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_req_type {
    UV_UNKNOWN_REQ = 0,
    UV_REQ = 1,
    UV_CONNECT = 2,
    UV_WRITE = 3,
    UV_SHUTDOWN = 4,
    UV_UDP_SEND = 5,
    UV_FS = 6,
    UV_WORK = 7,
    UV_GETADDRINFO = 8,
    UV_GETNAMEINFO = 9,
    UV_REQ_TYPE_MAX = 10,
}
pub type uv_loop_t = uv_loop_s;
pub type uv_handle_t = uv_handle_s;
pub type uv_stream_t = uv_stream_s;
pub type uv_tcp_t = uv_tcp_s;
pub type uv_udp_t = uv_udp_s;
pub type uv_pipe_t = uv_pipe_s;
pub type uv_tty_t = uv_tty_s;
pub type uv_poll_t = uv_poll_s;
pub type uv_timer_t = uv_timer_s;
pub type uv_prepare_t = uv_prepare_s;
pub type uv_check_t = uv_check_s;
pub type uv_idle_t = uv_idle_s;
pub type uv_async_t = uv_async_s;
pub type uv_process_t = uv_process_s;
pub type uv_fs_event_t = uv_fs_event_s;
pub type uv_fs_poll_t = uv_fs_poll_s;
pub type uv_signal_t = uv_signal_s;
pub type uv_req_t = uv_req_s;
pub type uv_getaddrinfo_t = uv_getaddrinfo_s;
pub type uv_getnameinfo_t = uv_getnameinfo_s;
pub type uv_shutdown_t = uv_shutdown_s;
pub type uv_write_t = uv_write_s;
pub type uv_connect_t = uv_connect_s;
pub type uv_udp_send_t = uv_udp_send_s;
pub type uv_fs_t = uv_fs_s;
pub type uv_work_t = uv_work_s;
pub type uv_cpu_info_t = uv_cpu_info_s;
pub type uv_interface_address_t = uv_interface_address_s;
pub type uv_dirent_t = uv_dirent_s;
pub type uv_passwd_t = uv_passwd_s;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_loop_option {
    UV_LOOP_BLOCK_SIGNAL = 0,
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_run_mode {
    UV_RUN_DEFAULT = 0,
    UV_RUN_ONCE = 1,
    UV_RUN_NOWAIT = 2,
}
extern "C" {
    #[link_name = "\u{1}_uv_version"]
    pub fn uv_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_uv_version_string"]
    pub fn uv_version_string() -> *const ::std::os::raw::c_char;
}
pub type uv_malloc_func =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type uv_realloc_func = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void,
>;
pub type uv_calloc_func = ::std::option::Option<
    unsafe extern "C" fn(count: usize, size: usize) -> *mut ::std::os::raw::c_void,
>;
pub type uv_free_func =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[link_name = "\u{1}_uv_replace_allocator"]
    pub fn uv_replace_allocator(
        malloc_func: uv_malloc_func,
        realloc_func: uv_realloc_func,
        calloc_func: uv_calloc_func,
        free_func: uv_free_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_default_loop"]
    pub fn uv_default_loop() -> *mut uv_loop_t;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_init"]
    pub fn uv_loop_init(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_close"]
    pub fn uv_loop_close(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_new"]
    pub fn uv_loop_new() -> *mut uv_loop_t;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_delete"]
    pub fn uv_loop_delete(arg1: *mut uv_loop_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_size"]
    pub fn uv_loop_size() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_alive"]
    pub fn uv_loop_alive(loop_: *const uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_configure"]
    pub fn uv_loop_configure(
        loop_: *mut uv_loop_t,
        option: uv_loop_option,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_loop_fork"]
    pub fn uv_loop_fork(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_run"]
    pub fn uv_run(arg1: *mut uv_loop_t, mode: uv_run_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_stop"]
    pub fn uv_stop(arg1: *mut uv_loop_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_ref"]
    pub fn uv_ref(arg1: *mut uv_handle_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_unref"]
    pub fn uv_unref(arg1: *mut uv_handle_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_has_ref"]
    pub fn uv_has_ref(arg1: *const uv_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_update_time"]
    pub fn uv_update_time(arg1: *mut uv_loop_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_now"]
    pub fn uv_now(arg1: *const uv_loop_t) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_uv_backend_fd"]
    pub fn uv_backend_fd(arg1: *const uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_backend_timeout"]
    pub fn uv_backend_timeout(arg1: *const uv_loop_t) -> ::std::os::raw::c_int;
}
pub type uv_alloc_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_handle_t, suggested_size: usize, buf: *mut uv_buf_t),
>;
pub type uv_read_cb = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut uv_stream_t, nread: isize, buf: *const uv_buf_t),
>;
pub type uv_write_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_write_t, status: ::std::os::raw::c_int),
>;
pub type uv_connect_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_connect_t, status: ::std::os::raw::c_int),
>;
pub type uv_shutdown_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_shutdown_t, status: ::std::os::raw::c_int),
>;
pub type uv_connection_cb = ::std::option::Option<
    unsafe extern "C" fn(server: *mut uv_stream_t, status: ::std::os::raw::c_int),
>;
pub type uv_close_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_handle_t)>;
pub type uv_poll_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_poll_t,
        status: ::std::os::raw::c_int,
        events: ::std::os::raw::c_int,
    ),
>;
pub type uv_timer_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_timer_t)>;
pub type uv_async_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_async_t)>;
pub type uv_prepare_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_prepare_t)>;
pub type uv_check_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_check_t)>;
pub type uv_idle_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_idle_t)>;
pub type uv_exit_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut uv_process_t,
        exit_status: i64,
        term_signal: ::std::os::raw::c_int,
    ),
>;
pub type uv_walk_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_handle_t, arg: *mut ::std::os::raw::c_void),
>;
pub type uv_fs_cb = ::std::option::Option<unsafe extern "C" fn(req: *mut uv_fs_t)>;
pub type uv_work_cb = ::std::option::Option<unsafe extern "C" fn(req: *mut uv_work_t)>;
pub type uv_after_work_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut uv_work_t, status: ::std::os::raw::c_int)>;
pub type uv_getaddrinfo_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut uv_getaddrinfo_t,
        status: ::std::os::raw::c_int,
        res: *mut addrinfo,
    ),
>;
pub type uv_getnameinfo_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut uv_getnameinfo_t,
        status: ::std::os::raw::c_int,
        hostname: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timespec_t {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_uv_timespec_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_timespec_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_timespec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timespec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timespec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timespec_t>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timespec_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timespec_t>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timespec_t),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_stat_t {
    pub st_dev: u64,
    pub st_mode: u64,
    pub st_nlink: u64,
    pub st_uid: u64,
    pub st_gid: u64,
    pub st_rdev: u64,
    pub st_ino: u64,
    pub st_size: u64,
    pub st_blksize: u64,
    pub st_blocks: u64,
    pub st_flags: u64,
    pub st_gen: u64,
    pub st_atim: uv_timespec_t,
    pub st_mtim: uv_timespec_t,
    pub st_ctim: uv_timespec_t,
    pub st_birthtim: uv_timespec_t,
}
#[test]
fn bindgen_test_layout_uv_stat_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_stat_t>(),
        160usize,
        concat!("Size of: ", stringify!(uv_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_uid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_ino as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_blksize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_blocks as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_gen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_atim as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_mtim as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_ctim as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stat_t>())).st_birthtim as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stat_t),
            "::",
            stringify!(st_birthtim)
        )
    );
}
pub type uv_fs_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_fs_event_t,
        filename: *const ::std::os::raw::c_char,
        events: ::std::os::raw::c_int,
        status: ::std::os::raw::c_int,
    ),
>;
pub type uv_fs_poll_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_fs_poll_t,
        status: ::std::os::raw::c_int,
        prev: *const uv_stat_t,
        curr: *const uv_stat_t,
    ),
>;
pub type uv_signal_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_signal_t, signum: ::std::os::raw::c_int),
>;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_membership {
    UV_LEAVE_GROUP = 0,
    UV_JOIN_GROUP = 1,
}
extern "C" {
    #[link_name = "\u{1}_uv_translate_sys_error"]
    pub fn uv_translate_sys_error(sys_errno: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_strerror"]
    pub fn uv_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_uv_err_name"]
    pub fn uv_err_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_req_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_uv_req_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_req_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv_req_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_req_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_req_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_req_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_req_s),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_shutdown"]
    pub fn uv_shutdown(
        req: *mut uv_shutdown_t,
        handle: *mut uv_stream_t,
        cb: uv_shutdown_cb,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_shutdown_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub handle: *mut uv_stream_t,
    pub cb: uv_shutdown_cb,
}
#[test]
fn bindgen_test_layout_uv_shutdown_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_shutdown_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_shutdown_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(cb)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_handle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_handle_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_handle_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_handle_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_handle_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_handle_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_handle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_handle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_handle_size"]
    pub fn uv_handle_size(type_: uv_handle_type) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_uv_req_size"]
    pub fn uv_req_size(type_: uv_req_type) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_uv_is_active"]
    pub fn uv_is_active(handle: *const uv_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_walk"]
    pub fn uv_walk(loop_: *mut uv_loop_t, walk_cb: uv_walk_cb, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_uv_print_all_handles"]
    pub fn uv_print_all_handles(loop_: *mut uv_loop_t, stream: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_uv_print_active_handles"]
    pub fn uv_print_active_handles(loop_: *mut uv_loop_t, stream: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_uv_close"]
    pub fn uv_close(handle: *mut uv_handle_t, close_cb: uv_close_cb);
}
extern "C" {
    #[link_name = "\u{1}_uv_send_buffer_size"]
    pub fn uv_send_buffer_size(
        handle: *mut uv_handle_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_recv_buffer_size"]
    pub fn uv_recv_buffer_size(
        handle: *mut uv_handle_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fileno"]
    pub fn uv_fileno(handle: *const uv_handle_t, fd: *mut uv_os_fd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_buf_init"]
    pub fn uv_buf_init(base: *mut ::std::os::raw::c_char, len: ::std::os::raw::c_uint) -> uv_buf_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_stream_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_stream_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub select: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_stream_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_stream_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_stream_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_stream_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stream_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stream_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stream_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_stream_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_stream_s>(),
        264usize,
        concat!("Size of: ", stringify!(uv_stream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).alloc_cb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).read_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connect_req as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).shutdown_req as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).io_watcher as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stream_s>())).write_completed_queue as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connection_cb as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).delayed_error as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).accepted_fd as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).queued_fds as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).select as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(select)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_listen"]
    pub fn uv_listen(
        stream: *mut uv_stream_t,
        backlog: ::std::os::raw::c_int,
        cb: uv_connection_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_accept"]
    pub fn uv_accept(server: *mut uv_stream_t, client: *mut uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_read_start"]
    pub fn uv_read_start(
        arg1: *mut uv_stream_t,
        alloc_cb: uv_alloc_cb,
        read_cb: uv_read_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_read_stop"]
    pub fn uv_read_stop(arg1: *mut uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_write"]
    pub fn uv_write(
        req: *mut uv_write_t,
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        cb: uv_write_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_write2"]
    pub fn uv_write2(
        req: *mut uv_write_t,
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        send_handle: *mut uv_stream_t,
        cb: uv_write_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_try_write"]
    pub fn uv_try_write(
        handle: *mut uv_stream_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_write_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub cb: uv_write_cb,
    pub send_handle: *mut uv_stream_t,
    pub handle: *mut uv_stream_t,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_index: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub nbufs: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_int,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_write_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_write_s>(),
        192usize,
        concat!("Size of: ", stringify!(uv_write_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_write_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_write_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).send_handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(send_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).handle as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).queue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).write_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(write_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).bufs as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).nbufs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).error as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_write_s>())).bufsml as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_write_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_is_readable"]
    pub fn uv_is_readable(handle: *const uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_is_writable"]
    pub fn uv_is_writable(handle: *const uv_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_stream_set_blocking"]
    pub fn uv_stream_set_blocking(
        handle: *mut uv_stream_t,
        blocking: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_is_closing"]
    pub fn uv_is_closing(handle: *const uv_handle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_tcp_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_tcp_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub select: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_tcp_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_tcp_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_tcp_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_tcp_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tcp_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tcp_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s__bindgen_ty_1>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_tcp_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_tcp_s>(),
        264usize,
        concat!("Size of: ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tcp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).alloc_cb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).read_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connect_req as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).shutdown_req as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).io_watcher as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_completed_queue as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connection_cb as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).delayed_error as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).accepted_fd as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).queued_fds as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).select as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(select)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_init"]
    pub fn uv_tcp_init(arg1: *mut uv_loop_t, handle: *mut uv_tcp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_init_ex"]
    pub fn uv_tcp_init_ex(
        arg1: *mut uv_loop_t,
        handle: *mut uv_tcp_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_open"]
    pub fn uv_tcp_open(handle: *mut uv_tcp_t, sock: uv_os_sock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_nodelay"]
    pub fn uv_tcp_nodelay(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_keepalive"]
    pub fn uv_tcp_keepalive(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_simultaneous_accepts"]
    pub fn uv_tcp_simultaneous_accepts(
        handle: *mut uv_tcp_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_tcp_flags {
    UV_TCP_IPV6ONLY = 1,
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_bind"]
    pub fn uv_tcp_bind(
        handle: *mut uv_tcp_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_getsockname"]
    pub fn uv_tcp_getsockname(
        handle: *const uv_tcp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_getpeername"]
    pub fn uv_tcp_getpeername(
        handle: *const uv_tcp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tcp_connect"]
    pub fn uv_tcp_connect(
        req: *mut uv_connect_t,
        handle: *mut uv_tcp_t,
        addr: *const sockaddr,
        cb: uv_connect_cb,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_connect_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub cb: uv_connect_cb,
    pub handle: *mut uv_stream_t,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_connect_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_connect_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_connect_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_connect_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_connect_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(queue)
        )
    );
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_udp_flags {
    UV_UDP_IPV6ONLY = 1,
    UV_UDP_PARTIAL = 2,
    UV_UDP_REUSEADDR = 4,
}
pub type uv_udp_send_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_udp_send_t, status: ::std::os::raw::c_int),
>;
pub type uv_udp_recv_cb = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut uv_udp_t,
        nread: isize,
        buf: *const uv_buf_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_udp_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_udp_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub send_queue_size: usize,
    pub send_queue_count: usize,
    pub alloc_cb: uv_alloc_cb,
    pub recv_cb: uv_udp_recv_cb,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_udp_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_udp_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_udp_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_udp_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_udp_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_udp_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s__bindgen_ty_1>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_udp_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_udp_s>(),
        224usize,
        concat!("Size of: ", stringify!(uv_udp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_udp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_udp_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).send_queue_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(send_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).send_queue_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(send_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).alloc_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).recv_cb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(recv_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).io_watcher as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).write_queue as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_s>())).write_completed_queue as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_udp_send_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub handle: *mut uv_udp_t,
    pub cb: uv_udp_send_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub addr: sockaddr_storage,
    pub nbufs: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub status: isize,
    pub send_cb: uv_udp_send_cb,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_udp_send_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_udp_send_s>(),
        320usize,
        concat!("Size of: ", stringify!(uv_udp_send_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_udp_send_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_udp_send_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).addr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).nbufs as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).bufs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).status as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).send_cb as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(send_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_udp_send_s>())).bufsml as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_udp_send_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_init"]
    pub fn uv_udp_init(arg1: *mut uv_loop_t, handle: *mut uv_udp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_init_ex"]
    pub fn uv_udp_init_ex(
        arg1: *mut uv_loop_t,
        handle: *mut uv_udp_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_open"]
    pub fn uv_udp_open(handle: *mut uv_udp_t, sock: uv_os_sock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_bind"]
    pub fn uv_udp_bind(
        handle: *mut uv_udp_t,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_getsockname"]
    pub fn uv_udp_getsockname(
        handle: *const uv_udp_t,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_membership"]
    pub fn uv_udp_set_membership(
        handle: *mut uv_udp_t,
        multicast_addr: *const ::std::os::raw::c_char,
        interface_addr: *const ::std::os::raw::c_char,
        membership: uv_membership,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_multicast_loop"]
    pub fn uv_udp_set_multicast_loop(
        handle: *mut uv_udp_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_multicast_ttl"]
    pub fn uv_udp_set_multicast_ttl(
        handle: *mut uv_udp_t,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_multicast_interface"]
    pub fn uv_udp_set_multicast_interface(
        handle: *mut uv_udp_t,
        interface_addr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_broadcast"]
    pub fn uv_udp_set_broadcast(
        handle: *mut uv_udp_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_set_ttl"]
    pub fn uv_udp_set_ttl(
        handle: *mut uv_udp_t,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_send"]
    pub fn uv_udp_send(
        req: *mut uv_udp_send_t,
        handle: *mut uv_udp_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        addr: *const sockaddr,
        send_cb: uv_udp_send_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_try_send"]
    pub fn uv_udp_try_send(
        handle: *mut uv_udp_t,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        addr: *const sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_recv_start"]
    pub fn uv_udp_recv_start(
        handle: *mut uv_udp_t,
        alloc_cb: uv_alloc_cb,
        recv_cb: uv_udp_recv_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_udp_recv_stop"]
    pub fn uv_udp_recv_stop(handle: *mut uv_udp_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_tty_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_tty_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub select: *mut ::std::os::raw::c_void,
    pub orig_termios: termios,
    pub mode: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_tty_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_tty_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_tty_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_tty_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tty_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tty_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s__bindgen_ty_1>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_tty_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_tty_s>(),
        344usize,
        concat!("Size of: ", stringify!(uv_tty_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tty_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tty_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_queue_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).alloc_cb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).read_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).connect_req as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).shutdown_req as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).io_watcher as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_queue as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).write_completed_queue as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).connection_cb as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).delayed_error as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).accepted_fd as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).queued_fds as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).select as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).orig_termios as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(orig_termios)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tty_s>())).mode as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tty_s),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_tty_mode_t {
    UV_TTY_MODE_NORMAL = 0,
    UV_TTY_MODE_RAW = 1,
    UV_TTY_MODE_IO = 2,
}
extern "C" {
    #[link_name = "\u{1}_uv_tty_init"]
    pub fn uv_tty_init(
        arg1: *mut uv_loop_t,
        arg2: *mut uv_tty_t,
        fd: uv_file,
        readable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tty_set_mode"]
    pub fn uv_tty_set_mode(arg1: *mut uv_tty_t, mode: uv_tty_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tty_reset_mode"]
    pub fn uv_tty_reset_mode() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_tty_get_winsize"]
    pub fn uv_tty_get_winsize(
        arg1: *mut uv_tty_t,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_guess_handle"]
    pub fn uv_guess_handle(file: uv_file) -> uv_handle_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_pipe_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_pipe_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
    pub select: *mut ::std::os::raw::c_void,
    pub ipc: ::std::os::raw::c_int,
    pub pipe_fname: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_pipe_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_pipe_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_pipe_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_pipe_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_pipe_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_pipe_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_pipe_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_pipe_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_pipe_s>(),
        280usize,
        concat!("Size of: ", stringify!(uv_pipe_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_pipe_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_pipe_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_queue_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).alloc_cb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).read_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).connect_req as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).shutdown_req as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).io_watcher as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_queue as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).write_completed_queue as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).connection_cb as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).delayed_error as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).accepted_fd as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).queued_fds as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(queued_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).select as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).ipc as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(ipc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_pipe_s>())).pipe_fname as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_pipe_s),
            "::",
            stringify!(pipe_fname)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_init"]
    pub fn uv_pipe_init(
        arg1: *mut uv_loop_t,
        handle: *mut uv_pipe_t,
        ipc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_open"]
    pub fn uv_pipe_open(arg1: *mut uv_pipe_t, file: uv_file) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_bind"]
    pub fn uv_pipe_bind(
        handle: *mut uv_pipe_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_connect"]
    pub fn uv_pipe_connect(
        req: *mut uv_connect_t,
        handle: *mut uv_pipe_t,
        name: *const ::std::os::raw::c_char,
        cb: uv_connect_cb,
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_getsockname"]
    pub fn uv_pipe_getsockname(
        handle: *const uv_pipe_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_getpeername"]
    pub fn uv_pipe_getpeername(
        handle: *const uv_pipe_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_pending_instances"]
    pub fn uv_pipe_pending_instances(handle: *mut uv_pipe_t, count: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_pending_count"]
    pub fn uv_pipe_pending_count(handle: *mut uv_pipe_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_pipe_pending_type"]
    pub fn uv_pipe_pending_type(handle: *mut uv_pipe_t) -> uv_handle_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_poll_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_poll_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub poll_cb: uv_poll_cb,
    pub io_watcher: uv__io_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_poll_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_poll_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_poll_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_poll_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_poll_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_poll_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_poll_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_poll_s>(),
        168usize,
        concat!("Size of: ", stringify!(uv_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).poll_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(poll_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_poll_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_poll_s),
            "::",
            stringify!(io_watcher)
        )
    );
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_poll_event {
    UV_READABLE = 1,
    UV_WRITABLE = 2,
    UV_DISCONNECT = 4,
    UV_PRIORITIZED = 8,
}
extern "C" {
    #[link_name = "\u{1}_uv_poll_init"]
    pub fn uv_poll_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_poll_t,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_poll_init_socket"]
    pub fn uv_poll_init_socket(
        loop_: *mut uv_loop_t,
        handle: *mut uv_poll_t,
        socket: uv_os_sock_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_poll_start"]
    pub fn uv_poll_start(
        handle: *mut uv_poll_t,
        events: ::std::os::raw::c_int,
        cb: uv_poll_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_poll_stop"]
    pub fn uv_poll_stop(handle: *mut uv_poll_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_prepare_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_prepare_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub prepare_cb: uv_prepare_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_prepare_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_prepare_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_prepare_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_prepare_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_prepare_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_prepare_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_prepare_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_prepare_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_prepare_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_prepare_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_prepare_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_prepare_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).prepare_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(prepare_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_prepare_s>())).queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_prepare_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_prepare_init"]
    pub fn uv_prepare_init(
        arg1: *mut uv_loop_t,
        prepare: *mut uv_prepare_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_prepare_start"]
    pub fn uv_prepare_start(prepare: *mut uv_prepare_t, cb: uv_prepare_cb)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_prepare_stop"]
    pub fn uv_prepare_stop(prepare: *mut uv_prepare_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_check_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_check_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub check_cb: uv_check_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_check_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_check_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_check_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_check_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_check_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_check_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_check_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_check_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_check_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_check_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_check_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_check_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).check_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(check_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_check_s>())).queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_check_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_check_init"]
    pub fn uv_check_init(arg1: *mut uv_loop_t, check: *mut uv_check_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_check_start"]
    pub fn uv_check_start(check: *mut uv_check_t, cb: uv_check_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_check_stop"]
    pub fn uv_check_stop(check: *mut uv_check_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_idle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_idle_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub idle_cb: uv_idle_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_idle_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_idle_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_idle_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_idle_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_idle_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_idle_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_idle_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_idle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_idle_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_idle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_idle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_idle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).idle_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(idle_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_idle_s>())).queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_idle_s),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_idle_init"]
    pub fn uv_idle_init(arg1: *mut uv_loop_t, idle: *mut uv_idle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_idle_start"]
    pub fn uv_idle_start(idle: *mut uv_idle_t, cb: uv_idle_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_idle_stop"]
    pub fn uv_idle_stop(idle: *mut uv_idle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_async_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_async_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub async_cb: uv_async_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pending: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_async_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_async_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_async_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_async_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_async_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s>(),
        128usize,
        concat!("Size of: ", stringify!(uv_async_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).async_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(async_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).pending as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(pending)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_async_init"]
    pub fn uv_async_init(
        arg1: *mut uv_loop_t,
        async: *mut uv_async_t,
        async_cb: uv_async_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_async_send"]
    pub fn uv_async_send(async: *mut uv_async_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_timer_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_timer_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub timer_cb: uv_timer_cb,
    pub heap_node: [*mut ::std::os::raw::c_void; 3usize],
    pub timeout: u64,
    pub repeat: u64,
    pub start_id: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_timer_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_timer_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_timer_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_timer_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timer_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timer_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_timer_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_timer_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_timer_s>(),
        152usize,
        concat!("Size of: ", stringify!(uv_timer_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timer_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).timer_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(timer_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).heap_node as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(heap_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).timeout as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).repeat as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timer_s>())).start_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timer_s),
            "::",
            stringify!(start_id)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_init"]
    pub fn uv_timer_init(arg1: *mut uv_loop_t, handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_start"]
    pub fn uv_timer_start(
        handle: *mut uv_timer_t,
        cb: uv_timer_cb,
        timeout: u64,
        repeat: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_stop"]
    pub fn uv_timer_stop(handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_again"]
    pub fn uv_timer_again(handle: *mut uv_timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_set_repeat"]
    pub fn uv_timer_set_repeat(handle: *mut uv_timer_t, repeat: u64);
}
extern "C" {
    #[link_name = "\u{1}_uv_timer_get_repeat"]
    pub fn uv_timer_get_repeat(handle: *const uv_timer_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_getaddrinfo_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub loop_: *mut uv_loop_t,
    pub work_req: uv__work,
    pub cb: uv_getaddrinfo_cb,
    pub hints: *mut addrinfo,
    pub hostname: *mut ::std::os::raw::c_char,
    pub service: *mut ::std::os::raw::c_char,
    pub addrinfo: *mut addrinfo,
    pub retcode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_getaddrinfo_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_getaddrinfo_s>(),
        160usize,
        concat!("Size of: ", stringify!(uv_getaddrinfo_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_getaddrinfo_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_getaddrinfo_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).work_req as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).hints as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).hostname as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).service as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).addrinfo as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(addrinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getaddrinfo_s>())).retcode as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getaddrinfo_s),
            "::",
            stringify!(retcode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_getaddrinfo"]
    pub fn uv_getaddrinfo(
        loop_: *mut uv_loop_t,
        req: *mut uv_getaddrinfo_t,
        getaddrinfo_cb: uv_getaddrinfo_cb,
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_freeaddrinfo"]
    pub fn uv_freeaddrinfo(ai: *mut addrinfo);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_getnameinfo_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub loop_: *mut uv_loop_t,
    pub work_req: uv__work,
    pub getnameinfo_cb: uv_getnameinfo_cb,
    pub storage: sockaddr_storage,
    pub flags: ::std::os::raw::c_int,
    pub host: [::std::os::raw::c_char; 1025usize],
    pub service: [::std::os::raw::c_char; 32usize],
    pub retcode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_getnameinfo_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_getnameinfo_s>(),
        1320usize,
        concat!("Size of: ", stringify!(uv_getnameinfo_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_getnameinfo_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_getnameinfo_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).work_req as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).getnameinfo_cb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(getnameinfo_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).storage as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).flags as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).host as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).service as *const _ as usize },
        1277usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_getnameinfo_s>())).retcode as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_getnameinfo_s),
            "::",
            stringify!(retcode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_getnameinfo"]
    pub fn uv_getnameinfo(
        loop_: *mut uv_loop_t,
        req: *mut uv_getnameinfo_t,
        getnameinfo_cb: uv_getnameinfo_cb,
        addr: *const sockaddr,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_stdio_flags {
    UV_IGNORE = 0,
    UV_CREATE_PIPE = 1,
    UV_INHERIT_FD = 2,
    UV_INHERIT_STREAM = 4,
    UV_READABLE_PIPE = 16,
    UV_WRITABLE_PIPE = 32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_stdio_container_s {
    pub flags: uv_stdio_flags,
    pub data: uv_stdio_container_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_stdio_container_s__bindgen_ty_1 {
    pub stream: *mut uv_stream_t,
    pub fd: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_uv_stdio_container_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_stdio_container_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(uv_stdio_container_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stdio_container_s__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uv_stdio_container_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stdio_container_s__bindgen_ty_1>())).stream as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s__bindgen_ty_1),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stdio_container_s__bindgen_ty_1>())).fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_stdio_container_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_stdio_container_s>(),
        16usize,
        concat!("Size of: ", stringify!(uv_stdio_container_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stdio_container_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stdio_container_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stdio_container_s>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stdio_container_s>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stdio_container_s),
            "::",
            stringify!(data)
        )
    );
}
pub type uv_stdio_container_t = uv_stdio_container_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_process_options_s {
    pub exit_cb: uv_exit_cb,
    pub file: *const ::std::os::raw::c_char,
    pub args: *mut *mut ::std::os::raw::c_char,
    pub env: *mut *mut ::std::os::raw::c_char,
    pub cwd: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub stdio_count: ::std::os::raw::c_int,
    pub stdio: *mut uv_stdio_container_t,
    pub uid: uv_uid_t,
    pub gid: uv_gid_t,
}
#[test]
fn bindgen_test_layout_uv_process_options_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_process_options_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv_process_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_process_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_process_options_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).exit_cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(exit_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).env as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).cwd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_process_options_s>())).stdio_count as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(stdio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).stdio as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).uid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_options_s>())).gid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_options_s),
            "::",
            stringify!(gid)
        )
    );
}
pub type uv_process_options_t = uv_process_options_s;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_process_flags {
    UV_PROCESS_SETUID = 1,
    UV_PROCESS_SETGID = 2,
    UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = 4,
    UV_PROCESS_DETACHED = 8,
    UV_PROCESS_WINDOWS_HIDE = 16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_process_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_process_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub exit_cb: uv_exit_cb,
    pub pid: ::std::os::raw::c_int,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub status: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_process_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_process_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_process_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_process_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_process_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_process_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_process_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_process_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_process_s>(),
        136usize,
        concat!("Size of: ", stringify!(uv_process_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_process_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_process_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).exit_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(exit_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).pid as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).queue as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_process_s>())).status as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_process_s),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_spawn"]
    pub fn uv_spawn(
        loop_: *mut uv_loop_t,
        handle: *mut uv_process_t,
        options: *const uv_process_options_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_process_kill"]
    pub fn uv_process_kill(
        arg1: *mut uv_process_t,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_kill"]
    pub fn uv_kill(
        pid: ::std::os::raw::c_int,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_work_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub loop_: *mut uv_loop_t,
    pub work_cb: uv_work_cb,
    pub after_work_cb: uv_after_work_cb,
    pub work_req: uv__work,
}
#[test]
fn bindgen_test_layout_uv_work_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_work_s>(),
        128usize,
        concat!("Size of: ", stringify!(uv_work_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_work_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_work_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).loop_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).work_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(work_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).after_work_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(after_work_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_work_s>())).work_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_s),
            "::",
            stringify!(work_req)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_queue_work"]
    pub fn uv_queue_work(
        loop_: *mut uv_loop_t,
        req: *mut uv_work_t,
        work_cb: uv_work_cb,
        after_work_cb: uv_after_work_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_cancel"]
    pub fn uv_cancel(req: *mut uv_req_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_cpu_info_s {
    pub model: *mut ::std::os::raw::c_char,
    pub speed: ::std::os::raw::c_int,
    pub cpu_times: uv_cpu_info_s_uv_cpu_times_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_cpu_info_s_uv_cpu_times_s {
    pub user: u64,
    pub nice: u64,
    pub sys: u64,
    pub idle: u64,
    pub irq: u64,
}
#[test]
fn bindgen_test_layout_uv_cpu_info_s_uv_cpu_times_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_cpu_info_s_uv_cpu_times_s>(),
        40usize,
        concat!("Size of: ", stringify!(uv_cpu_info_s_uv_cpu_times_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_cpu_info_s_uv_cpu_times_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_cpu_info_s_uv_cpu_times_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_cpu_info_s_uv_cpu_times_s>())).user as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s_uv_cpu_times_s),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_cpu_info_s_uv_cpu_times_s>())).nice as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s_uv_cpu_times_s),
            "::",
            stringify!(nice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_cpu_info_s_uv_cpu_times_s>())).sys as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s_uv_cpu_times_s),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_cpu_info_s_uv_cpu_times_s>())).idle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s_uv_cpu_times_s),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_cpu_info_s_uv_cpu_times_s>())).irq as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s_uv_cpu_times_s),
            "::",
            stringify!(irq)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_cpu_info_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_cpu_info_s>(),
        56usize,
        concat!("Size of: ", stringify!(uv_cpu_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_cpu_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_cpu_info_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).model as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).speed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_cpu_info_s>())).cpu_times as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_cpu_info_s),
            "::",
            stringify!(cpu_times)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_interface_address_s {
    pub name: *mut ::std::os::raw::c_char,
    pub phys_addr: [::std::os::raw::c_char; 6usize],
    pub is_internal: ::std::os::raw::c_int,
    pub address: uv_interface_address_s__bindgen_ty_1,
    pub netmask: uv_interface_address_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_interface_address_s__bindgen_ty_1 {
    pub address4: sockaddr_in,
    pub address6: sockaddr_in6,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_uv_interface_address_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s__bindgen_ty_1>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(uv_interface_address_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(uv_interface_address_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_1>())).address4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_1),
            "::",
            stringify!(address4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_1>())).address6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_1),
            "::",
            stringify!(address6)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_interface_address_s__bindgen_ty_2 {
    pub netmask4: sockaddr_in,
    pub netmask6: sockaddr_in6,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_uv_interface_address_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s__bindgen_ty_2>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(uv_interface_address_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(uv_interface_address_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_2>())).netmask4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_2),
            "::",
            stringify!(netmask4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s__bindgen_ty_2>())).netmask6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s__bindgen_ty_2),
            "::",
            stringify!(netmask6)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_interface_address_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_interface_address_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_interface_address_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_interface_address_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_interface_address_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s>())).phys_addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_interface_address_s>())).is_internal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(is_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).address as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_interface_address_s>())).netmask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_interface_address_s),
            "::",
            stringify!(netmask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_passwd_s {
    pub username: *mut ::std::os::raw::c_char,
    pub uid: ::std::os::raw::c_long,
    pub gid: ::std::os::raw::c_long,
    pub shell: *mut ::std::os::raw::c_char,
    pub homedir: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uv_passwd_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_passwd_s>(),
        40usize,
        concat!("Size of: ", stringify!(uv_passwd_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_passwd_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_passwd_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).username as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).gid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).shell as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(shell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_passwd_s>())).homedir as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_passwd_s),
            "::",
            stringify!(homedir)
        )
    );
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_dirent_type_t {
    UV_DIRENT_UNKNOWN = 0,
    UV_DIRENT_FILE = 1,
    UV_DIRENT_DIR = 2,
    UV_DIRENT_LINK = 3,
    UV_DIRENT_FIFO = 4,
    UV_DIRENT_SOCKET = 5,
    UV_DIRENT_CHAR = 6,
    UV_DIRENT_BLOCK = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_dirent_s {
    pub name: *const ::std::os::raw::c_char,
    pub type_: uv_dirent_type_t,
}
#[test]
fn bindgen_test_layout_uv_dirent_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_dirent_s>(),
        16usize,
        concat!("Size of: ", stringify!(uv_dirent_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_dirent_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_dirent_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dirent_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dirent_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_dirent_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_dirent_s),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_setup_args"]
    pub fn uv_setup_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_uv_get_process_title"]
    pub fn uv_get_process_title(
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_set_process_title"]
    pub fn uv_set_process_title(title: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_resident_set_memory"]
    pub fn uv_resident_set_memory(rss: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_uptime"]
    pub fn uv_uptime(uptime: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_get_osfhandle"]
    pub fn uv_get_osfhandle(fd: ::std::os::raw::c_int) -> uv_os_fd_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_timeval_t {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_uv_timeval_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_timeval_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_timeval_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_timeval_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_timeval_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval_t>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_timeval_t>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_timeval_t),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_rusage_t {
    pub ru_utime: uv_timeval_t,
    pub ru_stime: uv_timeval_t,
    pub ru_maxrss: u64,
    pub ru_ixrss: u64,
    pub ru_idrss: u64,
    pub ru_isrss: u64,
    pub ru_minflt: u64,
    pub ru_majflt: u64,
    pub ru_nswap: u64,
    pub ru_inblock: u64,
    pub ru_oublock: u64,
    pub ru_msgsnd: u64,
    pub ru_msgrcv: u64,
    pub ru_nsignals: u64,
    pub ru_nvcsw: u64,
    pub ru_nivcsw: u64,
}
#[test]
fn bindgen_test_layout_uv_rusage_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_rusage_t>(),
        144usize,
        concat!("Size of: ", stringify!(uv_rusage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_rusage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_rusage_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_rusage_t>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_rusage_t),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_getrusage"]
    pub fn uv_getrusage(rusage: *mut uv_rusage_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_homedir"]
    pub fn uv_os_homedir(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_tmpdir"]
    pub fn uv_os_tmpdir(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_get_passwd"]
    pub fn uv_os_get_passwd(pwd: *mut uv_passwd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_free_passwd"]
    pub fn uv_os_free_passwd(pwd: *mut uv_passwd_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_cpu_info"]
    pub fn uv_cpu_info(
        cpu_infos: *mut *mut uv_cpu_info_t,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_free_cpu_info"]
    pub fn uv_free_cpu_info(cpu_infos: *mut uv_cpu_info_t, count: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_uv_interface_addresses"]
    pub fn uv_interface_addresses(
        addresses: *mut *mut uv_interface_address_t,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_free_interface_addresses"]
    pub fn uv_free_interface_addresses(
        addresses: *mut uv_interface_address_t,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_os_getenv"]
    pub fn uv_os_getenv(
        name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_setenv"]
    pub fn uv_os_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_unsetenv"]
    pub fn uv_os_unsetenv(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_os_gethostname"]
    pub fn uv_os_gethostname(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_fs_type {
    UV_FS_UNKNOWN = -1,
    UV_FS_CUSTOM = 0,
    UV_FS_OPEN = 1,
    UV_FS_CLOSE = 2,
    UV_FS_READ = 3,
    UV_FS_WRITE = 4,
    UV_FS_SENDFILE = 5,
    UV_FS_STAT = 6,
    UV_FS_LSTAT = 7,
    UV_FS_FSTAT = 8,
    UV_FS_FTRUNCATE = 9,
    UV_FS_UTIME = 10,
    UV_FS_FUTIME = 11,
    UV_FS_ACCESS = 12,
    UV_FS_CHMOD = 13,
    UV_FS_FCHMOD = 14,
    UV_FS_FSYNC = 15,
    UV_FS_FDATASYNC = 16,
    UV_FS_UNLINK = 17,
    UV_FS_RMDIR = 18,
    UV_FS_MKDIR = 19,
    UV_FS_MKDTEMP = 20,
    UV_FS_RENAME = 21,
    UV_FS_SCANDIR = 22,
    UV_FS_LINK = 23,
    UV_FS_SYMLINK = 24,
    UV_FS_READLINK = 25,
    UV_FS_CHOWN = 26,
    UV_FS_FCHOWN = 27,
    UV_FS_REALPATH = 28,
    UV_FS_COPYFILE = 29,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_fs_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub fs_type: uv_fs_type,
    pub loop_: *mut uv_loop_t,
    pub cb: uv_fs_cb,
    pub result: isize,
    pub ptr: *mut ::std::os::raw::c_void,
    pub path: *const ::std::os::raw::c_char,
    pub statbuf: uv_stat_t,
    pub new_path: *const ::std::os::raw::c_char,
    pub file: uv_file,
    pub flags: ::std::os::raw::c_int,
    pub mode: mode_t,
    pub nbufs: ::std::os::raw::c_uint,
    pub bufs: *mut uv_buf_t,
    pub off: off_t,
    pub uid: uv_uid_t,
    pub gid: uv_gid_t,
    pub atime: f64,
    pub mtime: f64,
    pub work_req: uv__work,
    pub bufsml: [uv_buf_t; 4usize],
}
#[test]
fn bindgen_test_layout_uv_fs_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_s>(),
        440usize,
        concat!("Size of: ", stringify!(uv_fs_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).fs_type as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(fs_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).loop_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).result as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).ptr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).path as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).statbuf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(statbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).new_path as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(new_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).file as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).flags as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).mode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).nbufs as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(nbufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).bufs as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).off as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).uid as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).gid as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).atime as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).mtime as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).work_req as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(work_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_s>())).bufsml as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_s),
            "::",
            stringify!(bufsml)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_req_cleanup"]
    pub fn uv_fs_req_cleanup(req: *mut uv_fs_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_close"]
    pub fn uv_fs_close(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_open"]
    pub fn uv_fs_open(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_read"]
    pub fn uv_fs_read(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_unlink"]
    pub fn uv_fs_unlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_write"]
    pub fn uv_fs_write(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        bufs: *const uv_buf_t,
        nbufs: ::std::os::raw::c_uint,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_copyfile"]
    pub fn uv_fs_copyfile(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_mkdir"]
    pub fn uv_fs_mkdir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_mkdtemp"]
    pub fn uv_fs_mkdtemp(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        tpl: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_rmdir"]
    pub fn uv_fs_rmdir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_scandir"]
    pub fn uv_fs_scandir(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_scandir_next"]
    pub fn uv_fs_scandir_next(req: *mut uv_fs_t, ent: *mut uv_dirent_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_stat"]
    pub fn uv_fs_stat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_fstat"]
    pub fn uv_fs_fstat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_rename"]
    pub fn uv_fs_rename(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_fsync"]
    pub fn uv_fs_fsync(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_fdatasync"]
    pub fn uv_fs_fdatasync(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_ftruncate"]
    pub fn uv_fs_ftruncate(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        offset: i64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_sendfile"]
    pub fn uv_fs_sendfile(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        out_fd: uv_file,
        in_fd: uv_file,
        in_offset: i64,
        length: usize,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_access"]
    pub fn uv_fs_access(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_chmod"]
    pub fn uv_fs_chmod(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_utime"]
    pub fn uv_fs_utime(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_futime"]
    pub fn uv_fs_futime(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        atime: f64,
        mtime: f64,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_lstat"]
    pub fn uv_fs_lstat(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_link"]
    pub fn uv_fs_link(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_symlink"]
    pub fn uv_fs_symlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_readlink"]
    pub fn uv_fs_readlink(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_realpath"]
    pub fn uv_fs_realpath(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_fchmod"]
    pub fn uv_fs_fchmod(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        mode: ::std::os::raw::c_int,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_chown"]
    pub fn uv_fs_chown(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        path: *const ::std::os::raw::c_char,
        uid: uv_uid_t,
        gid: uv_gid_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_fchown"]
    pub fn uv_fs_fchown(
        loop_: *mut uv_loop_t,
        req: *mut uv_fs_t,
        file: uv_file,
        uid: uv_uid_t,
        gid: uv_gid_t,
        cb: uv_fs_cb,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_fs_event {
    UV_RENAME = 1,
    UV_CHANGE = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_fs_event_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_fs_event_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub path: *mut ::std::os::raw::c_char,
    pub cb: uv_fs_event_cb,
    pub event_watcher: uv__io_t,
    pub realpath: *mut ::std::os::raw::c_char,
    pub realpath_len: ::std::os::raw::c_int,
    pub cf_flags: ::std::os::raw::c_int,
    pub cf_cb: *mut uv_async_t,
    pub cf_events: [*mut ::std::os::raw::c_void; 2usize],
    pub cf_member: [*mut ::std::os::raw::c_void; 2usize],
    pub cf_error: ::std::os::raw::c_int,
    pub cf_mutex: uv_mutex_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_fs_event_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_fs_event_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_event_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_fs_event_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_event_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_event_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_fs_event_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_fs_event_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_event_s>(),
        304usize,
        concat!("Size of: ", stringify!(uv_fs_event_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_event_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_event_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).path as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).event_watcher as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(event_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).realpath as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(realpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).realpath_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(realpath_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_flags as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_events as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_member as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_member)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_error as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_event_s>())).cf_mutex as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_event_s),
            "::",
            stringify!(cf_mutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_fs_poll_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_fs_poll_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub poll_ctx: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_fs_poll_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_fs_poll_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_poll_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_fs_poll_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_poll_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_poll_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_fs_poll_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_fs_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_fs_poll_s>(),
        104usize,
        concat!("Size of: ", stringify!(uv_fs_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_fs_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_fs_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_fs_poll_s>())).poll_ctx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_fs_poll_s),
            "::",
            stringify!(poll_ctx)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_poll_init"]
    pub fn uv_fs_poll_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_fs_poll_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_poll_start"]
    pub fn uv_fs_poll_start(
        handle: *mut uv_fs_poll_t,
        poll_cb: uv_fs_poll_cb,
        path: *const ::std::os::raw::c_char,
        interval: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_poll_stop"]
    pub fn uv_fs_poll_stop(handle: *mut uv_fs_poll_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_poll_getpath"]
    pub fn uv_fs_poll_getpath(
        handle: *mut uv_fs_poll_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_signal_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub u: uv_signal_s__bindgen_ty_1,
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub signal_cb: uv_signal_cb,
    pub signum: ::std::os::raw::c_int,
    pub tree_entry: uv_signal_s__bindgen_ty_2,
    pub caught_signals: ::std::os::raw::c_uint,
    pub dispatched_signals: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_signal_s__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s__bindgen_ty_2 {
    pub rbe_left: *mut uv_signal_s,
    pub rbe_right: *mut uv_signal_s,
    pub rbe_parent: *mut uv_signal_s,
    pub rbe_color: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_left as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_right as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_right)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_parent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_2>())).rbe_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_2),
            "::",
            stringify!(rbe_color)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_signal_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s>(),
        152usize,
        concat!("Size of: ", stringify!(uv_signal_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).next_closing as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signal_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signal_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signum as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).tree_entry as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(tree_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).caught_signals as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(caught_signals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).dispatched_signals as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(dispatched_signals)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_uv_signal_init"]
    pub fn uv_signal_init(loop_: *mut uv_loop_t, handle: *mut uv_signal_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_signal_start"]
    pub fn uv_signal_start(
        handle: *mut uv_signal_t,
        signal_cb: uv_signal_cb,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_signal_start_oneshot"]
    pub fn uv_signal_start_oneshot(
        handle: *mut uv_signal_t,
        signal_cb: uv_signal_cb,
        signum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_signal_stop"]
    pub fn uv_signal_stop(handle: *mut uv_signal_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_loadavg"]
    pub fn uv_loadavg(avg: *mut f64);
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uv_fs_event_flags {
    UV_FS_EVENT_WATCH_ENTRY = 1,
    UV_FS_EVENT_STAT = 2,
    UV_FS_EVENT_RECURSIVE = 4,
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_event_init"]
    pub fn uv_fs_event_init(
        loop_: *mut uv_loop_t,
        handle: *mut uv_fs_event_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_event_start"]
    pub fn uv_fs_event_start(
        handle: *mut uv_fs_event_t,
        cb: uv_fs_event_cb,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_event_stop"]
    pub fn uv_fs_event_stop(handle: *mut uv_fs_event_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_fs_event_getpath"]
    pub fn uv_fs_event_getpath(
        handle: *mut uv_fs_event_t,
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_ip4_addr"]
    pub fn uv_ip4_addr(
        ip: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        addr: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_ip6_addr"]
    pub fn uv_ip6_addr(
        ip: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        addr: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_ip4_name"]
    pub fn uv_ip4_name(
        src: *const sockaddr_in,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_ip6_name"]
    pub fn uv_ip6_name(
        src: *const sockaddr_in6,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_inet_ntop"]
    pub fn uv_inet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_inet_pton"]
    pub fn uv_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_exepath"]
    pub fn uv_exepath(
        buffer: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_cwd"]
    pub fn uv_cwd(buffer: *mut ::std::os::raw::c_char, size: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_chdir"]
    pub fn uv_chdir(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_get_free_memory"]
    pub fn uv_get_free_memory() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_uv_get_total_memory"]
    pub fn uv_get_total_memory() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_uv_hrtime"]
    pub fn uv_hrtime() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_uv_disable_stdio_inheritance"]
    pub fn uv_disable_stdio_inheritance();
}
extern "C" {
    #[link_name = "\u{1}_uv_dlopen"]
    pub fn uv_dlopen(
        filename: *const ::std::os::raw::c_char,
        lib: *mut uv_lib_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_dlclose"]
    pub fn uv_dlclose(lib: *mut uv_lib_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_dlsym"]
    pub fn uv_dlsym(
        lib: *mut uv_lib_t,
        name: *const ::std::os::raw::c_char,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_dlerror"]
    pub fn uv_dlerror(lib: *const uv_lib_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_init"]
    pub fn uv_mutex_init(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_init_recursive"]
    pub fn uv_mutex_init_recursive(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_destroy"]
    pub fn uv_mutex_destroy(handle: *mut uv_mutex_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_lock"]
    pub fn uv_mutex_lock(handle: *mut uv_mutex_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_trylock"]
    pub fn uv_mutex_trylock(handle: *mut uv_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_mutex_unlock"]
    pub fn uv_mutex_unlock(handle: *mut uv_mutex_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_init"]
    pub fn uv_rwlock_init(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_destroy"]
    pub fn uv_rwlock_destroy(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_rdlock"]
    pub fn uv_rwlock_rdlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_tryrdlock"]
    pub fn uv_rwlock_tryrdlock(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_rdunlock"]
    pub fn uv_rwlock_rdunlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_wrlock"]
    pub fn uv_rwlock_wrlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_trywrlock"]
    pub fn uv_rwlock_trywrlock(rwlock: *mut uv_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_rwlock_wrunlock"]
    pub fn uv_rwlock_wrunlock(rwlock: *mut uv_rwlock_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_sem_init"]
    pub fn uv_sem_init(sem: *mut uv_sem_t, value: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_sem_destroy"]
    pub fn uv_sem_destroy(sem: *mut uv_sem_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_sem_post"]
    pub fn uv_sem_post(sem: *mut uv_sem_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_sem_wait"]
    pub fn uv_sem_wait(sem: *mut uv_sem_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_sem_trywait"]
    pub fn uv_sem_trywait(sem: *mut uv_sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_init"]
    pub fn uv_cond_init(cond: *mut uv_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_destroy"]
    pub fn uv_cond_destroy(cond: *mut uv_cond_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_signal"]
    pub fn uv_cond_signal(cond: *mut uv_cond_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_broadcast"]
    pub fn uv_cond_broadcast(cond: *mut uv_cond_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_barrier_init"]
    pub fn uv_barrier_init(
        barrier: *mut uv_barrier_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_barrier_destroy"]
    pub fn uv_barrier_destroy(barrier: *mut uv_barrier_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_barrier_wait"]
    pub fn uv_barrier_wait(barrier: *mut uv_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_wait"]
    pub fn uv_cond_wait(cond: *mut uv_cond_t, mutex: *mut uv_mutex_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_cond_timedwait"]
    pub fn uv_cond_timedwait(
        cond: *mut uv_cond_t,
        mutex: *mut uv_mutex_t,
        timeout: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_once"]
    pub fn uv_once(guard: *mut uv_once_t, callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[link_name = "\u{1}_uv_key_create"]
    pub fn uv_key_create(key: *mut uv_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_key_delete"]
    pub fn uv_key_delete(key: *mut uv_key_t);
}
extern "C" {
    #[link_name = "\u{1}_uv_key_get"]
    pub fn uv_key_get(key: *mut uv_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_uv_key_set"]
    pub fn uv_key_set(key: *mut uv_key_t, value: *mut ::std::os::raw::c_void);
}
pub type uv_thread_cb =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[link_name = "\u{1}_uv_thread_create"]
    pub fn uv_thread_create(
        tid: *mut uv_thread_t,
        entry: uv_thread_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_thread_self"]
    pub fn uv_thread_self() -> uv_thread_t;
}
extern "C" {
    #[link_name = "\u{1}_uv_thread_join"]
    pub fn uv_thread_join(tid: *mut uv_thread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uv_thread_equal"]
    pub fn uv_thread_equal(t1: *const uv_thread_t, t2: *const uv_thread_t)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_any_handle {
    pub async: uv_async_t,
    pub check: uv_check_t,
    pub fs_event: uv_fs_event_t,
    pub fs_poll: uv_fs_poll_t,
    pub handle: uv_handle_t,
    pub idle: uv_idle_t,
    pub pipe: uv_pipe_t,
    pub poll: uv_poll_t,
    pub prepare: uv_prepare_t,
    pub process: uv_process_t,
    pub stream: uv_stream_t,
    pub tcp: uv_tcp_t,
    pub timer: uv_timer_t,
    pub tty: uv_tty_t,
    pub udp: uv_udp_t,
    pub signal: uv_signal_t,
    _bindgen_union_align: [u64; 43usize],
}
#[test]
fn bindgen_test_layout_uv_any_handle() {
    assert_eq!(
        ::std::mem::size_of::<uv_any_handle>(),
        344usize,
        concat!("Size of: ", stringify!(uv_any_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_any_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_any_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).async as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).fs_event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(fs_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).fs_poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(fs_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).idle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).poll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).process as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).tcp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).tty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).udp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_handle>())).signal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_handle),
            "::",
            stringify!(signal)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uv_any_req {
    pub req: uv_req_t,
    pub connect: uv_connect_t,
    pub write: uv_write_t,
    pub shutdown: uv_shutdown_t,
    pub udp_send: uv_udp_send_t,
    pub fs: uv_fs_t,
    pub work: uv_work_t,
    pub getaddrinfo: uv_getaddrinfo_t,
    pub getnameinfo: uv_getnameinfo_t,
    _bindgen_union_align: [u64; 165usize],
}
#[test]
fn bindgen_test_layout_uv_any_req() {
    assert_eq!(
        ::std::mem::size_of::<uv_any_req>(),
        1320usize,
        concat!("Size of: ", stringify!(uv_any_req))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_any_req>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_any_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).req as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).connect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).shutdown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).udp_send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(udp_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).getaddrinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(getaddrinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_any_req>())).getnameinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_any_req),
            "::",
            stringify!(getnameinfo)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_loop_s {
    pub data: *mut ::std::os::raw::c_void,
    pub active_handles: ::std::os::raw::c_uint,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub active_reqs: [*mut ::std::os::raw::c_void; 2usize],
    pub stop_flag: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_ulong,
    pub backend_fd: ::std::os::raw::c_int,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watchers: *mut *mut uv__io_t,
    pub nwatchers: ::std::os::raw::c_uint,
    pub nfds: ::std::os::raw::c_uint,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
    pub wq_mutex: uv_mutex_t,
    pub wq_async: uv_async_t,
    pub cloexec_lock: uv_rwlock_t,
    pub closing_handles: *mut uv_handle_t,
    pub process_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub prepare_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub check_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub idle_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_unused: ::std::option::Option<unsafe extern "C" fn()>,
    pub async_io_watcher: uv__io_t,
    pub async_wfd: ::std::os::raw::c_int,
    pub timer_heap: uv_loop_s__bindgen_ty_1,
    pub timer_counter: u64,
    pub time: u64,
    pub signal_pipefd: [::std::os::raw::c_int; 2usize],
    pub signal_io_watcher: uv__io_t,
    pub child_watcher: uv_signal_t,
    pub emfile_fd: ::std::os::raw::c_int,
    pub cf_thread: uv_thread_t,
    pub _cf_reserved: *mut ::std::os::raw::c_void,
    pub cf_state: *mut ::std::os::raw::c_void,
    pub cf_mutex: uv_mutex_t,
    pub cf_sem: uv_sem_t,
    pub cf_signals: [*mut ::std::os::raw::c_void; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_loop_s__bindgen_ty_1 {
    pub min: *mut ::std::os::raw::c_void,
    pub nelts: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).nelts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(nelts)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_loop_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s>(),
        1072usize,
        concat!("Size of: ", stringify!(uv_loop_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).handle_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_reqs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_reqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).stop_flag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(stop_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).backend_fd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(backend_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).pending_queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watcher_queue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watchers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nwatchers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nwatchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nfds as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_mutex as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_async as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cloexec_lock as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cloexec_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).closing_handles as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(closing_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).process_handles as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(process_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).prepare_handles as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(prepare_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).check_handles as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(check_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).idle_handles as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(idle_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_handles as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_unused as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_io_watcher as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_wfd as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_wfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_heap as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_counter as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).time as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_pipefd as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_pipefd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_io_watcher as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).child_watcher as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(child_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).emfile_fd as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(emfile_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_thread as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>()))._cf_reserved as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(_cf_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_state as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_mutex as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_sem as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cf_signals as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cf_signals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extras_callback_scope__ {
    _unused: [u8; 0],
}
pub type extras_callback_scope = *mut extras_callback_scope__;
extern "C" {
    #[link_name = "\u{1}_extras_open_callback_scope"]
    pub fn extras_open_callback_scope(
        napi_async_context: napi_async_context,
        napi_resource_object: napi_value,
        result: *mut extras_callback_scope,
    );
}
extern "C" {
    #[link_name = "\u{1}_extras_close_callback_scope"]
    pub fn extras_close_callback_scope(callback_scope: extras_callback_scope);
}
